%!PS-Adobe-2.0
%%Creator: dvips(k) 5.98 Copyright 2009 Radical Eye Software
%%Title: DS_3.dvi
%%CreationDate: Fri Nov  5 19:48:36 2010
%%Pages: 2
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: Utopia-Regular Utopia-Bold Utopia-Italic
%%+ MathDesign-UT-Regular-T1-10
%%+ MathDesign-UT-Regular-Italic-MathItalic-10
%%+ MathDesign-UT-Regular-Symbol-10 MathDesign-UT-Regular-OT1-10
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips DS_3.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2010.11.05:1948
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: psfrag.pro 0 0
%%
%% This is file `psfrag.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% psfrag.dtx  (with options: `filepro')
%% 
%% Copyright (c) 1996 Craig Barratt, Michael C. Grant, and David Carlisle.
%% All rights reserved.
%% 
%% This file is part of the PSfrag package.
%% 
userdict begin
/PSfragLib 90 dict def
/PSfragDict 6 dict def
/PSfrag { PSfragLib begin load exec end } bind def
end
PSfragLib begin
/RO /readonly      load def
/CP /currentpoint  load def
/CM /currentmatrix load def
/B { bind RO def } bind def
/X { exch def } B
/MD { { X } forall } B
/OE { end exec PSfragLib begin } B
/S false def
/tstr 8 string def
/islev2 { languagelevel } stopped { false } { 2 ge } ifelse def
[ /sM /tM /srcM /dstM /dM /idM /srcFM /dstFM ] { matrix def } forall
sM currentmatrix RO pop
dM defaultmatrix RO idM invertmatrix RO pop
srcFM identmatrix pop
/Hide { gsave { CP } stopped not newpath clip { moveto } if } B
/Unhide { { CP } stopped not grestore { moveto } if } B
/setrepl islev2 {{ /glob currentglobal def true setglobal array astore
                   globaldict exch /PSfrags exch put glob setglobal }}
                {{ array astore /PSfrags X }} ifelse B
/getrepl islev2 {{ globaldict /PSfrags get aload length }}
                {{ PSfrags aload length }} ifelse B
/convert {
   /src X src length string
   /c 0 def src length {
      dup c src c get dup 32 lt { pop 32 } if put /c c 1 add def
   } repeat
} B
/Begin {
    /saver save def
    srcFM exch 3 exch put
    0 ne /debugMode X 0 setrepl
    dup /S exch dict def { S 3 1 roll exch convert exch put } repeat
    srcM CM dup invertmatrix pop
    mark { currentdict { end } stopped { pop exit } if } loop
    PSfragDict counttomark { begin } repeat pop
} B
/End {
    mark { currentdict end dup PSfragDict eq { pop exit } if } loop
    counttomark { begin } repeat pop
    getrepl saver restore
    7 idiv dup /S exch dict def {
        6 array astore /mtrx X tstr cvs /K X
        S K [ S K known { S K get aload pop } if mtrx ] put
    } repeat
} B
/Place {
    tstr cvs /K X
    S K known {
        bind /proc X tM CM pop
        CP /cY X /cX X
        0 0 transform idtransform neg /aY X neg /aX X
        S K get dup length /maxiter X
        /iter 1 def {
            iter maxiter ne { /saver save def } if
            tM setmatrix aX aY translate
            [ exch aload pop idtransform ] concat
            cX neg cY neg translate cX cY moveto
            /proc load OE
            iter maxiter ne { saver restore /iter iter 1 add def } if
        } forall
        /noXY { CP /cY X /cX X } stopped def
        tM setmatrix noXY { newpath } { cX cY moveto } ifelse
    } {
        Hide OE Unhide
    } ifelse
} B
/normalize {
    2 index dup mul 2 index dup mul add sqrt div
    dup 4 -1 roll exch mul 3 1 roll mul
} B
/replace {
    aload pop MD
    CP /bY X /lX X gsave sM setmatrix
    str stringwidth abs exch abs add dup 0 eq
        { pop } { 360 exch div dup scale } ifelse
    lX neg bY neg translate newpath lX bY moveto
    str { /ch X ( ) dup 0 ch put false charpath ch Kproc } forall
    flattenpath pathbbox [ /uY /uX /lY /lX ] MD
    CP grestore moveto
    currentfont /FontMatrix get dstFM copy dup
    0 get 0 lt { uX lX /uX X /lX X } if
    3 get 0 lt { uY lY /uY X /lY X } if
    /cX uX lX add 0.5 mul def
    /cY uY lY add 0.5 mul def
    debugMode { gsave 0 setgray 1 setlinewidth
        lX lY moveto lX uY lineto uX uY lineto uX lY lineto closepath
        lX bY moveto uX bY lineto lX cY moveto uX cY lineto
        cX lY moveto cX uY lineto stroke
    grestore } if
    dstFM dup invertmatrix dstM CM srcM
    2 { dstM concatmatrix } repeat pop
    getrepl /temp X
        S str convert get {
            aload pop [ /rot /scl /loc /K ] MD
            /aX cX def /aY cY def
            loc {
                dup 66  eq { /aY bY def } { % B
                dup 98  eq { /aY lY def } { % b
                dup 108 eq { /aX lX def } { % l
                dup 114 eq { /aX uX def } { % r
                dup 116 eq { /aY uY def }   % t
                if } ifelse } ifelse } ifelse } ifelse pop
            } forall
            K srcFM rot tM rotate dstM
            2 { tM concatmatrix } repeat aload pop pop pop
            2 { scl normalize 4 2 roll } repeat
            aX aY transform
            /temp temp 7 add def
        } forall
    temp setrepl
} B
/Rif {
    S 3 index convert known { pop replace } { exch pop OE } ifelse
} B
/XA { bind [ /Kproc /str } B /XC { ] 2 array astore def } B
/xs   { pop } XA XC
/xks  { /kern load OE } XA /kern XC
/xas  { pop ax ay rmoveto } XA /ay /ax XC
/xws  { c eq { cx cy rmoveto } if } XA /c /cy /cx XC
/xaws { ax ay rmoveto c eq { cx cy rmoveto } if }
    XA /ay /ax /c /cy /cx XC
/raws { xaws { awidthshow } Rif } B
/rws  { xws { widthshow } Rif } B
/rks  { xks { kshow } Rif } B
/ras  { xas { ashow } Rif } B
/rs   { xs { show } Rif } B
/rrs { getrepl dup 2 add -1 roll //restore exec setrepl } B
PSfragDict begin
islev2 not { /restore { /rrs PSfrag } B } if
/show       { /rs   PSfrag } B
/kshow      { /rks  PSfrag } B
/ashow      { /ras  PSfrag } B
/widthshow  { /rws  PSfrag } B
/awidthshow { /raws PSfrag } B
end PSfragDict RO pop
end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 90 2009-01-30 10:58:51Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.06, 2009/01/30
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
%/NArray { 
%   aload length 2 div dup dup cvi eq not { exch pop } if /n exch
%   cvi def 
%} def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  showpoints { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED /c ED /n ED 
  cvi dup 1 lt { pop 1 } if 
  /s ED 
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if
  /dx ED dy div round dy mul 
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 26 2008-06-14 11:50:02Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.01, 2008/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
end

% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 26 2008-06-14 11:50:02Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2008/04/18
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def

end
/PSTricksDotFont exch definefont pop

%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 90 2009-01-30 10:58:51Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.02, 2009/01/30.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  /next ED 			% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge { 
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  GetEdgeA GetEdgeB GetArmA GetArmB mark 
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  GetEdgeA GetArmA 
  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
  GetEdgeB 
  mark 
  xB1 yB1 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: solides.pro 0 0
%!
% PostScript prologue for pst-solides3d.tex.
% Version 4.15, 2009/07/03
%
%% COPYRIGHT 2009 by Jean-Paul Vignault
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN
%% archives in directory macros/latex/base/lppl.txt.
%
/SolidesDict 100 dict def
/SolidesbisDict 100 dict def
SolidesDict begin

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les variables globales gerees par PSTricks %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les lignes dessous sont a decommenter si l on veut utiliser le
%% %% fichier solides.pro independamment du package PSTricks
%% /Dobs 20 def
%% /THETA 20 def
%% /PHI 50 def
%% /Decran 30 def
%% /XpointVue {Dobs Cos1Cos2 mul} def
%% /YpointVue {Dobs Sin1Cos2 mul} def
%% /ZpointVue {Dobs Sin2 mul} def
%% /xunit 28.14 def
%% /solidhollow false def
%% /solidbiface false def
%% /xunit 28.45 def
%% /tracelignedeniveau? true def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% /solidgrid true def
/aretescachees true def
/defaultsolidmode 2 def
%
/Stroke { strokeopacity .setopacityalpha stroke } def
/Fill { fillopacity .setopacityalpha fill } def
%
%% variables globales specifiques a PSTricks
%% /activationgestioncouleurs true def
/xmin -10 def
/xmax 10 def
/ymin -10 def
/ymax 10 def

/fillstyle {} def
/startest false def
/cm {} def
/cm_1 {} def
/yunit {xunit} def
/angle_repere 90 def

/hadjust 2.5 def
/vadjust 2.5 def
/pl@n-en-cours false def

/pointilles { [6.25 3.75] 1.25 setdash } def
/stockcurrentcpath {} def
/newarrowpath {} def
/chaine 15 string def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% choix d une fonte accentuee pour le .ps %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/ReEncode { exch findfont
dup length dict begin { 1 index /FID eq {pop pop} {def} ifelse
}forall /Encoding ISOLatin1Encoding def currentdict end definefont
pop }bind def
/Font /Times-Roman /ISOfont ReEncode /ISOfont def
%Font findfont 10 scalefont setfont

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% extrait de color.pro pour pouvoir recuperer ses couleurs %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GreenYellow{0.15 0 0.69 0 setcmykcolor}def
/Yellow{0 0 1 0 setcmykcolor}def
/Goldenrod{0 0.10 0.84 0 setcmykcolor}def
/Dandelion{0 0.29 0.84 0 setcmykcolor}def
/Apricotq{0 0.32 0.52 0 setcmykcolor}def
/Peach{0 0.50 0.70 0 setcmykcolor}def
/Melon{0 0.46 0.50 0 setcmykcolor}def
/YellowOrange{0 0.42 1 0 setcmykcolor}def
/Orange{0 0.61 0.87 0 setcmykcolor}def
/BurntOrange{0 0.51 1 0 setcmykcolor}def
/Bittersweet{0 0.75 1 0.24 setcmykcolor}def
/RedOrange{0 0.77 0.87 0 setcmykcolor}def
/Mahogany{0 0.85 0.87 0.35 setcmykcolor}def
/Maroon{0 0.87 0.68 0.32 setcmykcolor}def
/BrickRed{0 0.89 0.94 0.28 setcmykcolor}def
/Red{0 1 1 0 setcmykcolor}def
/OrangeRed{0 1 0.50 0 setcmykcolor}def
/RubineRed{0 1 0.13 0 setcmykcolor}def
/WildStrawberry{0 0.96 0.39 0 setcmykcolor}def
/Salmon{0 0.53 0.38 0 setcmykcolor}def
/CarnationPink{0 0.63 0 0 setcmykcolor}def
/Magenta{0 1 0 0 setcmykcolor}def
/VioletRed{0 0.81 0 0 setcmykcolor}def
/Rhodamine{0 0.82 0 0 setcmykcolor}def
/Mulberry{0.34 0.90 0 0.02 setcmykcolor}def
/RedViolet{0.07 0.90 0 0.34 setcmykcolor}def
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}def
/Lavender{0 0.48 0 0 setcmykcolor}def
/Thistle{0.12 0.59 0 0 setcmykcolor}def
/Orchid{0.32 0.64 0 0 setcmykcolor}def
/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}def
/Purple{0.45 0.86 0 0 setcmykcolor}def
/Plum{0.50 1 0 0 setcmykcolor}def
/Violet{0.79 0.88 0 0 setcmykcolor}def
/RoyalPurple{0.75 0.90 0 0 setcmykcolor}def
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}def
/Periwinkle{0.57 0.55 0 0 setcmykcolor}def
/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}def
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}def
/MidnightBlue{0.98 0.13 0 0.43 setcmykcolor}def
/NavyBlue{0.94 0.54 0 0 setcmykcolor}def
/RoyalBlue{1 0.50 0 0 setcmykcolor}def
/Blue{1 1 0 0 setcmykcolor}def
/Cerulean{0.94 0.11 0 0 setcmykcolor}def
/Cyan{1 0 0 0 setcmykcolor}def
/ProcessBlue{0.96 0 0 0 setcmykcolor}def
/SkyBlue{0.62 0 0.12 0 setcmykcolor}def
/Turquoise{0.85 0 0.20 0 setcmykcolor}def
/TealBlue{0.86 0 0.34 0.02 setcmykcolor}def
/Aquamarine{0.82 0 0.30 0 setcmykcolor}def
/BlueGreen{0.85 0 0.33 0 setcmykcolor}def
/Emerald{1 0 0.50 0 setcmykcolor}def
/JungleGreen{0.99 0 0.52 0 setcmykcolor}def
/SeaGreen{0.69 0 0.50 0 setcmykcolor}def
/Green{1 0 1 0 setcmykcolor}def
/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}def
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}def
/LimeGreen{0.50 0 1 0 setcmykcolor}def
/YellowGreen{0.44 0 0.74 0 setcmykcolor}def
/SpringGreen{0.26 0 0.76 0 setcmykcolor}def
/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}def
/RawSienna{0 0.72 1 0.45 setcmykcolor}def
/Sepia{0 0.83 1 0.70 setcmykcolor}def
/Brown{0 0.81 1 0.60 setcmykcolor}def
/Tan{0.14 0.42 0.56 0 setcmykcolor}def
/Gray{0 0 0 0.50 setcmykcolor}def
/Black{0 0 0 1 setcmykcolor}def
/White{0 0 0 0 setcmykcolor}def
%% fin de l extrait color.pro

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             autres couleurs                        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/bleu {0 0 1 setrgbcolor} def
/rouge {1 0 0 setrgbcolor} def
/vert {0 .5 0 setrgbcolor} def
/gris {.4 .4 .4 setrgbcolor} def
/jaune {1 1 0 setrgbcolor} def
/noir {0 0 0 setrgbcolor} def
/blanc {1 1 1 setrgbcolor} def
/orange {1 .65 0 setrgbcolor} def
/rose {1 .01 .58  setrgbcolor} def
/cyan {1 0 0 0 setcmykcolor} def
/magenta {0 1 0 0 setcmykcolor} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             definition du point de vue             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pour la 3D conventionnelle
%% Dony : graphisme scientifique : page 187
%% Editeur : Masson

%% calcul des coefficients de la matrice
%% de transformation
/Sin1 {THETA sin} def
/Sin2 {PHI sin} def
/Cos1 {THETA cos} def
/Cos2 {PHI cos} def
/Cos1Sin2 {Cos1 Sin2 mul} def
/Sin1Sin2 {Sin1 Sin2 mul} def
/Cos1Cos2 {Cos1 Cos2 mul} def
/Sin1Cos2 {Sin1 Cos2 mul} def

/3dto2d {
6 dict begin
   /Zcote exch def
   /Yordonnee exch def
   /Xabscisse exch def
   /xObservateur
      Xabscisse Sin1 mul neg Yordonnee Cos1 mul add
   def
   /yObservateur
      Xabscisse Cos1Sin2 mul neg Yordonnee Sin1Sin2 mul sub Zcote Cos2
      mul add
   def
   /zObservateur
      Xabscisse neg Cos1Cos2 mul Yordonnee Sin1Cos2 mul sub Zcote Sin2
      mul sub Dobs add
   def
   %% maintenant on depose les resultats sur la pile
   Decran xObservateur mul zObservateur div cm
   Decran yObservateur mul zObservateur div cm
end
} def

/getpointVue {
   XpointVue
   YpointVue
   ZpointVue
} def

/GetCamPos {
   getpointVue
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         jps modifie pour PSTricks                  %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/solid {continu} def
/dashed {pointilles} def
/dotted { [2] 0 setdash } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             geometrie basique                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% syntaxe~: [x1 y1 ... xn yn] ligne
/ligne {
gsave
   newpath
      dup 0 getp smoveto
      ligne_
      starfill
   Stroke
grestore
} def

%% syntaxe~: [x1 y1 ... xn yn] ligne_
/ligne_ {
   reversep
   aload length 2 idiv
   {
      slineto
   } repeat
} def

%% syntaxe~: [x1 y1 ... xn yn] polygone
/polygone* {
1 dict begin
   /startest {true} def
   polygone
end
} def

/polygone_ {
   newpath
      aload length 2 idiv
      3 copy pop
      smoveto
      {
         slineto
      } repeat
   closepath
} def

/polygone {
   gsave
      polygone_
      starfill
      currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
} def

%% syntaxe : x y point
/point {
gsave
   1 setlinecap
   newpath
      smoveto
      0 0 rlineto
      5 setlinewidth
   Stroke
grestore
} def

/point_ {
   1 setlinecap
   5 setlinewidth
      smoveto
      0 0 rlineto
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%          insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              le repere jps                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### AAAopacity ###

%% les parametres pour la gestion de la transparence

/setstrokeopacity { /strokeopacity exch def } def
/setfillopacity { /fillopacity exch def } def

%% d apres un code de Jean-Michel Sarlat
%% http://melusine.eu.org/syracuse/swf/pdf2swf/setdash/
%% Mise en reserve de la procedure stroke originelle.
/sysstroke {systemdict /stroke get exec} def
/sysfill {systemdict /fill get exec} def
/sysatan {systemdict /atan get exec} def
/atan {2 copy 0 0 eqp {pop pop 0} {sysatan} ifelse} def
% Mise en place de la nouvelle procedure
/Stroke { /strokeopacity where { /strokeopacity get }{ 1 } ifelse
   .setopacityalpha sysstroke
} def
/Fill { /fillopacity where { /fillopacity get }{ 1 } ifelse
   .setopacityalpha sysfill
} def

%%%%% ### AAAscale ###
%%%%%%%%%%%%%%%% les deplacements a l echelle %%%%%%%%%%%%%%%%%%%

 /v@ct_I {xunit 0} def
 /v@ct_J {angle_repere cos yunit mul angle_repere sin yunit mul} def

/xscale {} def
/yscale {} def

/xscale-1 {} def
/yscale-1 {} def

/gtransform {} def
/gtransform-1 {} def

/jtoppoint {
2 dict begin
   gtransform
   /y exch yscale def
   /x exch xscale def
   v@ct_I x mulv
   v@ct_J y mulv
   addv
end
} def

/rptojpoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
   ptojpoint
} def

/rptoppoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
} def

/ptojpoint {
4 dict begin
   /Y exch yscale-1 def
   /X exch xscale-1 def
   /y Y yunit angle_repere sin mul div def
   /x X y yunit mul angle_repere cos mul sub xunit div def
   x y
   gtransform-1
end
} def

/smoveto {
   jtoppoint
   moveto
} def

/srmoveto {
   jtoppoint
   rmoveto
} def

/slineto {
   jtoppoint
   lineto
} def

/srlineto {
   jtoppoint
   rlineto
} def

/stranslate {
   jtoppoint
   translate
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%            methodes numeriques                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solve2nddegre ###
%% syntaxe : a b c solve2nddegre --> x1 x2
/solve2nddegre {
5 dict begin
   /@c exch def
   /@b exch def
   /@a exch def
   /delt@ @b dup mul 4 @a mul @c mul sub def
   @b neg delt@ sqrt sub 2 @a mul div
   @b neg delt@ sqrt add 2 @a mul div
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  la 2D                             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  points                            %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### tripointangle ###
%% syntaxe : A B C tripointangle --> angle ABC
/tripointangle {
9 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   B C angle
   B A angle
   sub
end   
} def

%%%%% ### angle ###
%% syntaxe : A B angle
%% --> num, l'angle defini par le vecteur AB dans le repere orthonorme jps 
/angle {
   vecteur exch atan
   dup 180 gt 
      {360 sub}
   if
} def

%% syntaxe : A B pangle
%% --> num, l'angle defini par le vecteur AB dans le repere postscript
/pangle {
   jtoppoint exchp jtoppoint exchp vecteur exch atan
   dup 180 gt 
	 {360 sub}
   if
} def

%%%%% ### setxrange ###
/setxrange {
   /xmax exch def
   /xmin exch def
} def

%%%%% ### setyrange ###
/setyrange {
   /ymax exch def
   /ymin exch def
} def

%%%%% ### defpoint ###
%% syntaxe : xA yA /A defpoint
/defpoint {
1 dict begin
   /t@mp@r@ire exch def
   [ 3 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### milieu ###
%% syntaxe~: A B milieu 
/milieu {  
                %% xA yA xB yB
   3 -1 roll    %% xA xB yB yA 
   add 2 div    %% xA xB yM
   3 1 roll     %% yM xA xB 
   add 2 div    %% yM xM
   exch
} def

%%%%% ### parallelopoint ###
%% syntaxe : A B C parallelopoint --> point D, tel que ABCD parallelogramme
/parallelopoint {
11 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /d1 {A B C paral} def
   /d2 {B C A paral} def
   d1 d2 interdroite
end
} def

%%%%% ### translatepoint ###
%% syntaxe : A u translatepoint --> B image de A par la translation de vecteur u
/translatepoint {
   addv
} def

%%%%% ### rotatepoint ###
%% syntaxe : B A r rotatepoint --> C image de B par la rotation de centre A,
%% d'angle r (en degre)
%% En prenant les affixes des pts associes, il vient
%%    (zC - zA) = (zB-zA) e^(ir)
%% soit 
%%    zC = (zB-zA) e^(ir) + zA
/rotatepoint {     %% B, A, r
   5 copy          %% B, A, r, B, A, r
   cos 5 1 roll    %% B, A, r, cos r, B, A
   4 1 roll        %% B, A, r, cos r, yA, B, xA
   4 1 roll        %% B, A, r, cos r, A, B 
   vecteur         %% B, A, r, cos r, xB-xA, yB-yA
   4 -1 roll sin   %% B, A, cos r, xB-xA, yB-yA, sin r
   4 copy mul      %% B, A, cos r, xB-xA, yB-yA, sin r, cos r, xB-xA, (yB-yA) sin r
   7 1 roll mul    %% B, A, (yB-yA) sin r, cos r, xB-xA, yB-yA, sin r, cos r (xB-xA)
   5 1 roll        %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, yB-yA, sin r
   exch            %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, sin r, yB-yA
   4 -1 roll mul   %% B, A, (yB-yA) sin r, cos r (xB-xA), xB-xA, sin r, (yB-yA)cos r
   3 1 roll mul    %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r, (xB-xA) sin r
   add             %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r +(xB-xA) sin r
   3 1 roll        %% B, A, (yB-yA) cos r + (xB-xA) sin r, (yB-yA) sin r, cos r (xB-xA), 
   exch sub        %% B, A, (yB-yA) cos r + (xB-xA) sin r, cos r (xB-xA)-(yB-yA) sin r 
   exch            %% B, zA, (zB-zA) e^(ir)
   addv
   3 -1 roll pop
   3 -1 roll pop
} def

%%%%% ### hompoint ###
%% syntaxe : B A alpha hompoint -> le point A' tel que AA' = alpha AB
/hompoint {
   5 copy
   pop
   vecteur      %% vecteur BA
   3 -1 roll
   neg
   mulv   %% alpha x vecteur AB
   addv
   4 -1 roll
   4 -1 roll
   pop pop
} def

%%%%% ### orthoproj ###
%% syntaxe : A D orthoproj --> B, le projete orthogonal de A sur D
/orthoproj {
   6 -1 roll
   6 -1 roll            %% D A
   6 copy               %% D A D A
   7 -1 roll pop
   7 -1 roll pop        %% D D A
   perp 
   interdroite
} def

%% syntaxe : A projx --> le projete orthogonal de A sur Ox
/projx {
   pop 0
} def

%% syntaxe : A projy --> le projete orthogonal de A sur Oy
/projy {
   exch pop 0 exch
} def

%%%%% ### sympoint ###
%% syntaxe : A I sympoint --> point A', le symetrique de A par rapport
%% au point I
/sympoint {
   4 copy
   pop pop
   vecteur 
   -2 mulv
   addv
} def

%%%%% ### axesympoint ###
%% syntaxe : A D axesympoint --> point B, le symetrique de A par rapport
%% a la droite D
/axesympoint {
2 dict begin
   6 copy
   pop pop pop pop
   /yA exch def
   /xA exch def
   orthoproj 
   xA yA vecteur 
   -2 mulv
   xA yA addv
end   
} def

%%%%% ### cpoint ###
%% syntaxe : alpha C cpoint -> M, le point du cercle C correspondant a
%% l'angle alpha
/cpoint {           %% a, xI, yI, r 
1 dict begin
   dup              %% a, xI, yI, r, r
   5 -1 roll        %% xI, yI, r, r, a
   /alpha exch def  
   alpha cos mul    %% xI, yI, r, r cos a
   exch
   alpha sin mul    %% xI, yI, r cos a, r sin a
   3 -1 roll add    %% xI, r cos a, yI + r sin a
   3 1 roll         %% yI + r sin a, xI, r cos a, 
   add exch         %% xI + r cos a, yI + r sin a
end
} def

%%%%% ### xdpoint ###
%% x A B xdpoint : le point de la droite (AB) d'abscisse x
/xdpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /x exch def
   /a pt1 pt2 coeffdir def
   /b pt1 pt2 ordorig def
   x dup a mul b add
end   
} def

%%%%% ### ydpoint ###
%% y A B ydpoint : le point de la droite (AB) d'ordonnee y
/ydpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /y exch def
   pt1 pt2 verticale? 
      {
         pt1 pop y
      }
      {
         /a pt1 pt2 coeffdir def
         /b pt1 pt2 ordorig def
         y b sub a div y
      }
   ifelse
end   
} def

%%%%% ### ordonnepoints ###
%% syntaxe : xA yA xB yB ordonnepoints --> idem si yB>yA ou si yB=yA
%% avec xB>xA, sinon xB yB xA yA
/ordonnepoints {
   4 copy
   exch pop             %% ... xA, yA, yB
   lt                   %% yA < yB ?
      {pop}                     %% oui, c'est fini
      {                         %% non : yA >= yB
         pop 4 copy  
         exch pop               %% ... xA, yA, yB
         eq                     %% yA = yB ?
            {
               3 copy                   %% oui, yA = yB
               pop pop                  %% ... xA, xB
               le                       %% xA =< xB ?
                  {}                          %% oui, c'est fini
                  {                           %% non, on echange A et B
                     4 -1 roll
                     4 -1 roll
                  }
               ifelse
            }
            {                           %% non : yA < yB => on echange A et B
               pop
               4 -1 roll
               4 -1 roll
            }
         ifelse
      } 
   ifelse
} def

%%%%% ### distance ###
%% syntaxe~: A B distance
/distance {      %% xA yA xB yB
   vecteur       %% x y
   dup mul exch  %% y^2 x
   dup mul       %% y^2 x^2
   add
   sqrt
} def

%%%%% ### dup ###
/dupp {2 copy} def
/dupc {3 copy} def
/dupd {4 copy} def

%%%%% ### fin insertion ###
/interdroites {interdroite} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 vecteurs                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### vecteur ###
%% syntaxe~: A B vecteur
/vecteur {
                %% xA yA xB yB 
   3 -1 roll    %% xA xB yB yA 
   sub          %% xA xB yB-yA 
   3 1 roll     %% yB-yA xA xB 
   exch sub     %% yB-yA xB-xA 
   exch
} def

%%%%% ### normalize ###
%% syntaxe : u normalize -> u / ||u||
/normalize {
2 dict begin
   /u defpoint
   /n u norme def
   u 1 n div mulv
end
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### subv ###
%% syntaxe : u v subv --> u - v
/subv {	%% xA yA xB yB
   -1 mulv
   addv
} def

%%%%% ### mulv ###
%% syntaxe : u a mulv --> au
/mulv {   %% xA, yA, a
   dup          %% xA, yA, a, a
   3 1 roll     %% xA, a, yA, a
   mul 3 1 roll %% ayA, xA, a
   mul exch
} def

%%%%% ### scalprod ###
%% syntaxe : u v scalprod --> le produit scalaire de u par v
/scalprod {
2 dict begin
   /y' exch def
   exch 
   /y exch def
   mul y y' mul add
end
} def

%%%%% ### normal ###
%% syntaxe : u normal --> v tel u.v = 0
/normal {
   neg exch
} def

%%%%% ### norme ###
%% syntaxe : u norme --> |u|
/norme {
   dup mul
   exch
   dup mul
   add sqrt
} def

%%%%% ### oldarrow ###
%% syntaxe : A B oldarrow --> trace fleche en B, direction AB
/oldarrow {
4 dict begin
gsave
   /B defpoint
   /A defpoint
   oldarrowscale scale
   oldarrowangle rotate
   newpath 
   B smoveto
   A B vecteur normalize /u defpoint
   u neg exch /v defpoint
   u oldarrowpointe neg mulv rmoveto %% ainsi c'est la pointe qui est en (0, 0)
   %% le pt extremal arriere haut
      u oldarrowplume neg mulv        %% l'abscisse
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul mulv addv %% l'ordonnee
   rlineto
      u oldarrowplume oldarrowpointe add mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto 
      u oldarrowplume oldarrowpointe add neg mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto
   closepath Fill
grestore
end
} def

/oldarrowpointe {xunit 5 div} def
/oldarrowplume {xunit 10 div} def 
/oldarrow@ngle 45 def        
/oldarrowscale {1 1} def
/oldarrowangle 0 def     %% pour l'utilisateur

%%%%% ### drawvecteur ###
%% syntaxe : A B drawvecteur
/drawvecteur {
2 dict begin
   /B defpoint
   /A defpoint
   [A B] ligne
   A B oldarrow
end
} def

%%%%% ### orthovecteur ###
%% syntaxe : u orthovecteur --> v, vecteur orthogonal a u
/orthovecteur {
   neg exch
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  cercles                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### defcercle ###
%% syntaxe : A r /d defcercle
/defcercle {
1 dict begin
   /t@mp@r@ire exch def
   [ 4 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### interdroitecercle ###
%% intersection de la droite y = ax+b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%% { --       b - y                   2          2           3
%% { |  x = - -----, y = (b + a x0 + a  y0 + (2 a  b y0 - 2 a  b x0 +
%% { --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%% 
%%    -- 
%%     |,
%%    -- 
%%     --       b - y                   2          2           3
%%     |  x = - -----, y = (b + a x0 + a  y0 - (2 a  b y0 - 2 a  b x0 +
%%     --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%%    -- }
%%     | }
%%    -- }

%% intersection de la droite x = a avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[x = a, y = y0 + (2 a x0 - a  + r  - x0 )   ],
%% 
%%                                2    2     2 1/2
%%    [x = a, y = y0 - (2 a x0 - a  + r  - x0 )   ]}

%% intersection de la droite y = b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[y = b, x = x0 + (2 b y0 - b  + r  - y0 )   ],
%% 
%%                                2    2     2 1/2
%%    [y = b, x = x0 - (2 b y0 - b  + r  - y0 )   ]}

%% syntaxe : D I r interdroitecercle
/interdroitecercle {
16 dict begin
   /r exch def
   /y0 exch def
   /x0 exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def

   xA yA xB yB verticale?

   %% la droite est verticale
   {
      /xpt1 xA def
      /xpt2 xA def
      /quantite 
         2 xA mul x0 mul xA dup mul sub r dup mul add x0 dup mul sub sqrt
      def
      /ypt1
         y0 quantite add
      def
      /ypt2
         y0 quantite sub
      def
   }

   %% la droite n'est pas verticale
   {
      /a xA yA xB yB coeffdir def
      /b xA yA xB yB ordorig def

      0 a eq 
      %% la droite est horizontale
      {
         /quantite
            2 b mul y0 mul 
            b dup mul sub
            r dup mul add
            y0 dup mul sub
            sqrt
         def
         /xpt1 
            x0 quantite add
         def
         /xpt2 
            x0 quantite sub
         def
         /ypt1 b def
         /ypt2 b def
      } 

      %% la droite n'est pas horizontale
      {
         /quantite1 
            b 
            a x0 mul add
            a dup mul y0 mul add
         def
         /quantite2
            2 a dup mul mul b mul y0 mul 
            2 a 3 exp mul b mul x0 mul sub
            2 a 3 exp mul x0 mul y0 mul add
            a dup mul b dup mul mul sub
            a dup mul r dup mul mul add
            a 4 exp r dup mul mul add
            a dup mul y0 dup mul mul sub
            a 4 exp x0 dup mul mul sub 
            sqrt 
         def
         /quantite3 
            a dup mul 1 add 
         def
         /ypt1
            quantite1 quantite2 add quantite3 div
         def
         /xpt1 
            ypt1 b sub a div 
         def
         /ypt2
            quantite1 quantite2 sub quantite3 div
         def
         /xpt2 
            ypt2 b sub a div 
         def
      } 
      ifelse
   }
   ifelse
   
   xpt1 ypt1 
   xpt2 ypt2 
   ordonnepoints
end
} def

%%%%% ### intercercle ###
%% syntaxe : cerc1 cerc2 intercercle --> A B les points d'intersection
%% des 2 cercles, tries par 'ordonnepoints'
/intercercle {
12 dict begin
   /r2 exch def
   /y2 exch def
   /x2 exch def
   /r1 exch def
   /y1 exch def
   /x1 exch def

   %% on translate pour se ramener a (x1, y1) = (0, 0)
   x2 y2 x1 y1 subv
   /y2 exch def
   /x2 exch def

   %% on prepare l'equation du 2nd degre

%%                    2       2    2
%%   {y = RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ), x = 1/2 (-2 y2
%% 
%%                     2       2    2
%%         RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2       2     2     2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ) + r1~  + x2  + y2
%% 
%%               2
%%          - r2~ )/x2}

   %% coeff pour le degre 2
   /a 
      %%                    2       2    2
      %%   {y = RootOf((4 x2  + 4 y2 ) _Z
      4 x2 dup mul mul
      4 y2 dup mul mul add
   def

   %% coeff pour le degre 1
   %%
   /b 
      %%                    3        2              2       2        
      %%            + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z 
      -4 y2 3 exp mul
      4 r1 dup mul mul y2 mul sub
      4 r2 dup mul mul y2 mul add
      4 x2 dup mul mul y2 mul sub
   def

   %% coeff pour le degre 0
   %%
   /c {
      %%              4
      %%          + x2
      x2 4 exp
      %% 
      %%               4       2    2       2   2       2    2        2   2
      %%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
      r2 4 exp add
      2 y2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul y2 dup mul mul add
      2 x2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul r1 dup mul mul sub
      %% 
      %%               4     4        2   2        2    2
      %%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ )
      r1 4 exp add
      y2 4 exp add
      2 r1 dup mul mul y2 dup mul mul add
      2 r1 dup mul mul r2 dup mul mul sub
   } def

   a b c solve2nddegre
   /Y1 exch def
   /Y0 exch def
   
   /X0
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y0 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def
   
   /X1
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y1 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def

   %% on depose le resultat, en n'oubliant pas de retranslater en sens
   %% inverse

   X0 Y0 x1 y1 addv
   X1 Y1 x1 y1 addv
   ordonnepoints
end
} def

%%%%% ### ABcercle ###
%% syntaxe : A B C ABcercle --> le cercle passant par A, B, C
/ABcercle {
3 dict begin
   /@3 defpoint
   /@2 defpoint
   /@1 defpoint
   @1 @2 mediatrice
   @1 @3 mediatrice
   interdroite
   dupp
   @3 distance
end   
} def

%%%%% ### diamcercle ###
%% syntaxe : A B diamcercle --> le cercle de diametre [AB]
/diamcercle {
   4 copy
   distance 2 div
   5 1 roll 
   milieu
   3 -1 roll 
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  droites                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### horizontale ###
%% syntaxe : y horizontale 
/horizontale {
1 dict begin
   /y exch def
   xmin y xmax y
end
} def

%%%%% ### coeffdir ###
%% syntaxe~: A B coeffdir
/coeffdir {
   vecteur exch div
} def

%%%%% ### ordorig ###
%% syntaxe : A B ordorig
%% attention, la droite est supposee ne pas etre verticale
/ordorig {
   /dr@ite 4 array def
   dr@ite 3 3 -1 roll put
   dr@ite 2 3 -1 roll put
   dr@ite 1 3 -1 roll put
   dr@ite 0 3 -1 roll put
   dr@ite aload pop coeffdir /c@eff exch def
   dr@ite aload pop pop pop  %% xA yA
   exch                      %% yA xA 
   c@eff mul neg add
} def

%%%%% ### verticale ###
%% syntaxe~: A B verticale?
/verticale? {
   pop 2 1 roll pop
   eq
} def

%% syntaxe : x verticale
/verticale {
1 dict begin
   /x exch def
   x ymin x ymax
end
} def

%%%%% ### droite ###
%% %% syntaxe : A B droite
%% /droite {
%% gsave
%% 6 dict begin
%%    /yB exch def
%%    /xB exch def
%%    /yA exch def
%%    /xA exch def
%%    xA yA xB yB
%%    eqp
%%       {}
%%       { 
%%          xA yA xB yB
%%    	 verticale?
%%    	 {
%%    	 newpath
%%    	    xA ymin smoveto
%%    	    xA ymax slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 {
%%    	 newpath
%%    	    /alpha xA yA xB yB coeffdir def
%%    	    /beta xA yA xB yB ordorig def
%%    	    xmin dup alpha mul beta add smoveto
%%    	    xmax dup alpha mul beta add slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 ifelse
%%       }
%%    ifelse
%% end
%% grestore
%% } def

%% syntaxe : A B droite
/droite {
gsave
6 dict begin
   /B defpoint
   /A defpoint
   A pop B pop eq {
      %% droite verticale
      newpath
         A pop ymin smoveto
	 A pop ymax slineto
         stockcurrentcpath
      Stroke
   } {
      %% on cherche le point le + a gauche
      xmin A B xdpoint /C defpoint
      C exch pop ymin lt {
         %% trop a gauche
	 ymin A B ydpoint /C defpoint
      } if
      C exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /C defpoint
      } if
      %% on cherche le point le + a droite
      xmax A B xdpoint /D defpoint
      D exch pop ymin lt {
         %% trop a droite
	 ymin A B ydpoint /D defpoint
      } if
      D exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /D defpoint
      } if
      newpath
         C smoveto
         D slineto
         stockcurrentcpath
     Stroke
   } ifelse
end
grestore
} def

%%%%% ### defdroite ###
%% syntaxe : A B /d defdroite
/defdroite {
1 dict begin
   /t@mp@r@ire exch def
   [ 5 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### paral ###
%% syntaxe : D A paral --> droite parallele a D passant par A
/paral {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### interdroite ###
/interdroite {
                %% A B C D
   /dr@ite2 4 array def
   dr@ite2 3 3 -1 roll put
   dr@ite2 2 3 -1 roll put
   dr@ite2 1 3 -1 roll put
   dr@ite2 0 3 -1 roll put
   /dr@ite1 4 array def
   dr@ite1 3 3 -1 roll put
   dr@ite1 2 3 -1 roll put
   dr@ite1 1 3 -1 roll put
   dr@ite1 0 3 -1 roll put

%%%    %% trace pour deboguage
%%%    dr@ite1 aload pop droite
%%%    dr@ite2 aload pop droite

%%% Dans tous les cas, on suppose que l'intersection existe
%%% 
%%% * la 1ere droite est verticale. les equations reduites sont
%%%       x = a1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%       {{x = a1, y = b2 + a1 a2}}
%%% 
%%% * la 2eme droite est verticale. les equations reduites sont
%%%       x = a1 x+ b1     et       x = a2
%%% Le point d'intersection est :
%%%       {{x = a2, y = b1 + a1 a2}}
%%% 
%%% * aucune n'est verticale. Les equations reduites sont
%%%       y = a1 x + b1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%                 { {     b2 - b1      a1 b2 - a2 b1 } }
%%%                 { { x = -------, y = ------------- } }
%%%                 { {     a1 - a2         a1 - a2    } }

%%% remarque : pour le moment, je n'arrive pas a rendre mes variables
%%% locales : elle restent globales. Pour que cela ne soit pas trop
%%% genant, je les note respectivement @1, @@1, @2 et @@2 au lieu de a1,
%%% b1, a2 et b2.

   dr@ite1 aload pop verticale?
      {
         /@1 {dr@ite1 aload pop pop pop pop} def
         /@2 {dr@ite2 aload pop coeffdir} def
         /@@2 {dr@ite2 aload pop ordorig} def
         @1 
         @1 @2 mul @@2 add
      }
      {
      dr@ite2 aload pop verticale?
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop pop pop pop} def
            @2
            @1 @2 mul @@1 add
         }
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop coeffdir} def
            /@@2 {dr@ite2 aload pop ordorig} def
            @@2 @@1 sub @1 @2 sub div
            @1 @@2 mul @2 @@1 mul sub
            @1 @2 sub div
         }
      ifelse
      }
   ifelse
} def

%%%%% ### perp ###
%% syntaxe : D A perp --> droite perpendiculaire a D passant par A
/perp {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur orthovecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### mediatrice ###
%% synaxe : A B mediatrice --> droite
/mediatrice {
   4 copy 
   milieu
   perp
} def

%%%%% ### bissectrice ###
%% syntaxe : A B C bissectrice --> B E ou E est un point de la bissectrice
/bissectrice {
10 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /alpha {A B C tripointangle} def
   B
   A B alpha rotatepoint
   A milieu
end
} def

%%%%% ### angledroit  ###
 /widthangledroit 5 def

%% syntaxe : A B C angledroit --> dessine un angle droit en B
/angledroit {
10 dict begin
   dup xcheck {
      /widthangledroit exch def
   } if
   /C defpoint
   /B defpoint
   /A defpoint
   B C vecteur normalize widthangledroit 20 div mulv /u defpoint
   B A vecteur normalize widthangledroit 20 div mulv /v defpoint
   [B u addv dupp v addv B v addv] ligne
end
} def

%%%%% ### translatedroite ###
%% syntaxe : A B u translatedroite --> C D images resp de A et B par la translation de vecteur u
/translatedroite {         %% A B u
   2 copy          %% A B u u
   6 1 roll       
   6 1 roll        %% A u B u 
   addv      %% A u D
   6 1 roll        
   6 1 roll        %% D A u 
   addv
   4 1 roll
   4 1 roll
} def

%%%%% ### rotatedroite ###
%% syntaxe : A B O r rotatedroite --> C D images resp de A et B par la
%% rotation de centre O et d'angle r (en degre)
/rotatedroite {
   5 copy rotatepoint   %% A B O r D
   6 -1 roll pop        %% A xB O r D
   6 -1 roll pop        %% A O r D
   7 1 roll
   7 1 roll rotatepoint %% D C
   4 1 roll 4 1 roll 
} def

/rotatevecteur {
   rotatedroite
} def

/rotatesegment {
   rotatedroite
} def

%%%%% ### axesymdroite ###
%% syntaxe : d D axesymdroite --> droite d', symetrique de la droite d par rapport
%% a la droite D
/axesymdroite {
2 dict begin
   /D defdroite
   /B defpoint
   D axesympoint
   B D axesympoint
end   
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  polygones                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### poltransformfile ###
%% syntaxe : pol u translatepol --> pol'
/translatepol {
2 dict begin   
   /uy exch def
   /ux exch def
   {ux uy translatepoint} papply
end
} def

%% syntaxe : pol u rotatepol --> pol'
/rotatepol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha rotatepoint} papply
end
} def

%% syntaxe : pol I alpha hompol --> pol'
/hompol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha hompoint} papply
end
} def

%% syntaxe : pol I sympol --> pol'
/sympol {
1 dict begin   
   /I defpoint
   {I sympoint} papply
end
} def

%% syntaxe : pol D axesympol --> pol'
/axesympol {
1 dict begin   
   /D defdroite
   {D axesympoint} papply
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  les tests                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### isbool ###
%% syntaxe : any isbool --> booleen
/isbool {
   type (booleantype) cvn eq
} def

%%%%% ### isarray ###
%% syntaxe : any isarray --> booleen
/isarray {
   type (arraytype) cvn eq
} def

%%%%% ### isstring ###
%% syntaxe : any isstring --> booleen
/isstring {
   type (stringtype) cvn eq
} def

%%%%% ### isinteger ###
%% syntaxe : any isinteger --> booleen
/isinteger {
   type (integertype) cvn eq
} def

%%%%% ### isnum ###
%% syntaxe : any isnum --> booleen
/isnum {
   dup isreal 
   exch isinteger or
} def

%%%%% ### isreal ###
%% syntaxe : any isreal --> booleen
/isreal {
   type (realtype) cvn eq
} def

%%%%% ### eq ###
%% syntaxe : A B eqp3d --> booleen = true si les points A et B sont identiques
/eqp3d {
               %% x1 y1 z1 x2 y2 z2
   4 -1 roll   %% x1 y1 x2 y2 z2 z1 
   eq {        %% x1 y1 x2 y2 
      eqp
   } {
      pop pop pop pop false
   } ifelse
} def

%% syntaxe : A B eqp --> booleen = true si les points A et B sont identiques
/eqp {
   3 -1 roll
   eq 
      {
         eq 
            {true} 
            {false}
         ifelse
      }
      {pop pop false}
   ifelse
} def

%% syntaxe : z z' eqc --> true si z = z', false sinon
/eqc {
   eqp
} def

%%%%% ### eqstring ###
/eqstring {
3 dict begin
   /str2 exch def
   /str1 exch def
   str1 length str2 length eq {
      /i 0 def
      true
      str1 length {
         str1 i get str2 i get eq and
         /i i 1 add store
      } repeat
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                conversions de types                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### astr2str ###
%% syntaxe : array str astr2str --> str
%% convertit le contenu de array en chaines de caracteres puis les
%% concatene avec str, en inserant un caractere "space" apres chaque
%% element du tableau array
/astr2str {
5 dict begin
   /str exch def
   /table exch def
   /n table length def
   n 0 eq {
      str
   } {
      table 0 n 1 sub getinterval
      table n 1 sub get (                               ) cvs
      ( ) append
      str append
      astr2str
   } ifelse
end
} def

%%%%% ### numstr2array ###
%% syntaxe : str str2num --> num
/str2num {
5 dict begin
   /str exch def
   /n str length def
   /signnum 1 def
   /frct false def
   /k 0 def
   0 1 n 1 sub {
      /i exch def
      str i get
      dup 46 eq {
         %% il y a un point
         /frct true def
         pop
         i 0 eq {
            0
         } if
      } {
         dup 45 eq {
            /signnum -1 def
            pop
         } {
            frct not {
               i 1 ge signnum 0 ge and i 2 ge or {
                  exch 10 mul 48 sub add
               } {
                  48 sub
               } ifelse
            } {
               48 sub
               /k k 1 add store
               10 k exp div add
            } ifelse
         } ifelse
      } ifelse
   } for
   signnum mul
end
} def

/str2num {cvx exec} def

%% syntaxe : str numstr2array -> array
%% ou str est une chaine de nombres reels separes par des espaces
%% et array est constitue des elements numeriques de string.
%% exemple :
%% (0 -12 .234 54) --> [0 -12 0.234 54]
/numstr2array {
6 dict begin
   /str exch def
   /n str length def
   /separateurs [] def
   [
      0 1 n 1 sub {
         /i exch def
         str i get
         32 eq {
            /separateurs [separateurs aload pop i] def
         } if
      } for
      /j 0 def
      /oldsep 0 def
      0 1 separateurs length 1 sub {
         /i exch def
         str j separateurs i get oldsep sub getinterval str2num
         /j separateurs i get 1 add def
         /oldsep separateurs i get 1 add def
      } for
      str j n oldsep sub getinterval str2num
   ]
end
} def

%% syntaxe : array numstr2array -> array
/arraynumstr2arrayarray {
   {numstr2array} apply
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                macros de projection                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### projtext ###
%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str x0 y0 plantype ultextp3d --> -
%% syntaxe : str x0 y0 plantype bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
 /initpr@jtext {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /type_plan_proj true def
      /lepl@n exch def
      lepl@n plangetbase aload pop
      /@V defpoint3d
      /@U defpoint3d
      lepl@n plangetorigine
      /z0 exch def
      /y0 exch def
      /x0 exch def
      /table [@U @U @V vectprod3d] def
   } {
      dup isarray {
         %% c est un planprojpath
         /type_plan_proj true def
         /table exch def
         /z0 exch def
         /y0 exch def
         /x0 exch def
         0 0
      } {
         %% c est un solidprojpath
         /type_plan_proj false def
         %% y a-t-il un str2
         dup isstring {
            /str2 exch def
         } {
            /str2 {} def
         } ifelse
         %% y a-t-il un alpha
         2 copy pop issolid {
            /alpha 0 def
         } {
            /alpha exch def
         } ifelse
         /i exch def
         /solid exch def
         0 0
      } ifelse
   } ifelse
} def
 /closepr@jtext {
   type_plan_proj {
      x0 y0 z0 table mybool projpath
   } {
      solid i alpha str2 mybool projpath
   } ifelse
   Fill
   Stroke
end
} def

%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
/ultextp3d {initpr@jtext ultext_ closepr@jtext} def
/cltextp3d {initpr@jtext cltext_ closepr@jtext} def
/bltextp3d {initpr@jtext bltext_ closepr@jtext} def
/dltextp3d {initpr@jtext dltext_ closepr@jtext} def
/ubtextp3d {initpr@jtext ubtext_ closepr@jtext} def
/cbtextp3d {initpr@jtext cbtext_ closepr@jtext} def
/bbtextp3d {initpr@jtext bbtext_ closepr@jtext} def
/dbtextp3d {initpr@jtext dbtext_ closepr@jtext} def
/uctextp3d {initpr@jtext uctext_ closepr@jtext} def
/cctextp3d {initpr@jtext cctext_ closepr@jtext} def
/bctextp3d {initpr@jtext bctext_ closepr@jtext} def
/dctextp3d {initpr@jtext dctext_ closepr@jtext} def
/urtextp3d {initpr@jtext urtext_ closepr@jtext} def
/crtextp3d {initpr@jtext crtext_ closepr@jtext} def
/brtextp3d {initpr@jtext brtext_ closepr@jtext} def
/drtextp3d {initpr@jtext drtext_ closepr@jtext} def

%%%%% ### currentppathtransform ###
%% syntaxe : {f} currentppathtransform --> applique la transformation f
%% au chemin courant
/currentppathtransform {
6 dict begin
   /warp exch def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp moveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp lineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      curveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%% syntaxe : {f} currentpathtransform --> applique la transformation f
%% au chemin courant
/currentpathtransform {
7 dict begin
   /transform exch def
   /warp {ptojpoint transform} def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp smoveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp slineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      scurveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%%%%% ### normalvect_to_orthobase ###
%% syntaxe : [normal_vect] normalvect_to_orthobase
%%    --> imI imJ imK
/normalvect_to_orthobase {
4 dict begin
   dup length 3 eq {
      aload pop normalize3d /normal_vect defpoint3d
      normal_vect -1 0 0 eqp3d {
         /imageI {0 -1 0} def
         /imageK {-1 0 0} def
         /imageJ {0 0 1} def 
      } {
         %% on calcule l image de la base (I,J,K)
         /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
         /imageK {normal_vect} def
         /imageI {imageJ imageK vectprod3d} def
         1 0 0 imageK angle3d 0 eq {
            0 1 0 normal_vect vectprod3d /imageI defpoint3d
            /imageJ {0 1 0} def
            normal_vect /imageK defpoint3d
         } if
      } ifelse
   } {
      dup length 6 eq {
         aload pop
         normalize3d /imageK defpoint3d
         normalize3d /imageI defpoint3d
         imageK imageI vectprod3d /imageJ defpoint3d
      } {
         dup length 7 eq {
            aload pop 
            /alpha exch 2 div def
            normalize3d /imageK defpoint3d
            normalize3d /imageI defpoint3d
            imageK imageI vectprod3d /imageJ defpoint3d
            %% et ensuite, on fait tourner la base autour de imageK
            imageI alpha cos mulv3d
            imageJ alpha sin mulv3d
            addv3d
   
            imageI alpha sin neg mulv3d
            imageJ alpha cos mulv3d
            addv3d
   
            /imageJ defpoint3d
            /imageI defpoint3d
         } {
            %% length = 4
            aload pop
            /alpha exch def
            normalize3d /normal_vect defpoint3d
   
            normal_vect -1 0 0 eqp3d {
               /imageI {0 -1 0} def
               /imageK {-1 0 0} def
               /imageJ {0 0 1} def 
            } {
               %% on calcule l image de la base (I,J,K)
               /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
               /imageK {normal_vect} def
               /imageI {imageJ imageK vectprod3d} def
               1 0 0 imageK angle3d 0 eq {
                  0 1 0 normal_vect vectprod3d /imageI defpoint3d
                  /imageJ {0 1 0} def
                  normal_vect /imageK defpoint3d
               } if
            } ifelse
         } ifelse

         %% et ensuite, on fait tourner la base autour de imageK
         imageI alpha cos mulv3d
         imageJ alpha sin mulv3d
         addv3d

         imageI alpha sin neg mulv3d
         imageJ alpha cos mulv3d
         addv3d

         /imageJ defpoint3d
         /imageI defpoint3d
      } ifelse
   } ifelse
   imageI
   imageJ
   imageK
end
} def

%%%%% ### projpath ###
%% syntaxe : x y z [normal] projpath --> planprojpath
%% syntaxe : x y z [normal] bool projpath --> planprojpath
%% syntaxe : solid i projpath --> solidprojpath
%% syntaxe : solid i bool projpath --> solidprojpath
%% syntaxe : solid i str bool projpath --> solidprojpath
%% syntaxe : solid i alpha str bool projpath --> solidprojpath
/projpath {
2 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      3 dict begin
         /lepl@n exch def
         lepl@n plangetbase aload pop
         /@V defpoint3d
         /@U defpoint3d
         lepl@n plangetorigine
         [@U @U @V vectprod3d] mybool planprojpath
      end
   } {
      dup isarray {
         mybool planprojpath
      } {
         mybool solidprojpath
      } ifelse
   } ifelse
end
} def


%% %% syntaxe : x y z [normal] projpath --> planprojpath
%% %% syntaxe : x y z [normal] bool projpath --> planprojpath
%% %% syntaxe : solid i projpath --> solidprojpath
%% %% syntaxe : solid i bool projpath --> solidprojpath
%% %% syntaxe : solid i str bool projpath --> solidprojpath
%% %% syntaxe : solid i alpha str bool projpath --> solidprojpath
%% /projpath {
%% 2 dict begin
%%    dup isbool {
%%       /mybool exch def
%%    } {
%%       /mybool true def
%%    } ifelse
%%    dup isarray {
%%       mybool planprojpath
%%    } {
%%       mybool solidprojpath
%%    } ifelse
%% end
%% } def
%% 
%% syntaxe : solid i str bool solidprojpath --> -
%% ou
%% syntaxe : solid i alpha str bool solidprojpath --> -
%% projette le chemin courant sur la face i du solide, apres
%% eventuellement une rotation d angle alpha autour de la normale
%% bool : pour savoir si on tient compte de la visibilite
/solidprojpath {
5 dict begin
   /visibility exch def
   dup isstring {
      /option exch def
   } if
   2 copy pop
   issolid {
      /alpha 0 def
   } {
      /alpha exch def
   } ifelse
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidprojpath) ==
   } if
   /n solid solidnombrefaces def
   i n 1 sub le {
      visibility not solid i solidfacevisible? or {
         currentdict /option known {
            option cvx exec
         } {
            solid i solidcentreface 
         } ifelse
         [
            solid 0 i solidgetsommetface 
            solid 1 i solidgetsommetface 
            vecteur3d normalize3d
            solid i solidnormaleface alpha 
         ] false planprojpath 
      } {
         newpath 0 0 smoveto
      } ifelse
   } {
      (Error : indice trop grand dans solidprojpath) ==
      quit
   } ifelse
end
} def

%% syntaxe : x y z [normal] bool planprojpath
/planprojpath {
6 dict begin
   /visibility exch def
   %% on calcule l image de la base (I,J,K)
   normalvect_to_orthobase
   /imageK defpoint3d
   /imageJ defpoint3d
   /imageI defpoint3d
   /z exch def
   /y exch def
   /x exch def

   visibility not x y z imageK planvisible? or {
      {ptojpoint 0
      imageI
      imageJ
      imageK
      transformpoint3d
      x y z addv3d
      3dto2d jtoppoint} currentppathtransform
   } {
      newpath
   } ifelse
end
} def

%%%%% ### projscene ###
%% syntaxe : plantype bool bprojscene ... eprojscene
/bprojscene {
10 dict begin
gsave
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /l@pl@n exch def
   /saveStroke {SolidesDict /Stroke get exec} def
   /Stroke {l@pl@n mybool projpath saveStroke} def
   /savefill {SolidesDict /Fill get exec} def
   /Fill {l@pl@n mybool projpath savefill} def
   /masque {} def
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
%%       xmin ymin l@pl@n pointplan smoveto
%%       xmin ymax l@pl@n pointplan slineto
%%       xmax ymax l@pl@n pointplan slineto
%%       xmax ymin l@pl@n pointplan slineto
%%       xmin ymin l@pl@n pointplan smoveto
%%  %   closepath
%% %gsave orange Fill grestore
%%    clip
} def
/eprojscene {
grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          fonctions numeriques                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### courbeparam ###
/setresolution {
   /resolution exch def
} def
/resolution 200 def

/courbe_dic 2 dict def
courbe_dic /X {} put
courbe_dic /Y {} put

%% syntaxe : tmin tmax C@urbeparam_
 /C@urbeparam_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR
   tmin@ courbe_dic /Y get exec
   pstrickactionR
   smoveto
   resolution 1 sub
   {
      t courbe_dic /X get exec
      pstrickactionR
      t courbe_dic /Y get exec
      pstrickactionR
      slineto

      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR
   tmax@ courbe_dic /Y get exec
   pstrickactionR
   slineto
end
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam_
/Courbeparam_ {
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   C@urbeparam_
} def

%% syntaxe : {X} {Y} courbeparam_
/courbeparam_ {
   tmin tmax
   4 -1 roll
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam
/Courbeparam {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin courbe_dic /X get exec
      pstrickactionR
      tmin courbe_dic /Y get exec
      pstrickactionR
      smoveto                        %% on commence le chemin
      tmin tmax C@urbeparam_
      starfill

   stockcurrentcpath
   newarrowpath
   currentdict /option known
      {
         /dt tmax tmin sub resolution 1 sub div def
         tmin dt add courbe_dic /X get exec
         tmin dt add courbe_dic /Y get exec
         tmin courbe_dic /X get exec
         tmin courbe_dic /Y get exec
         arrowpath0
         tmax dt sub courbe_dic /X get exec
         tmax dt sub courbe_dic /Y get exec
         tmax courbe_dic /X get exec
         tmax courbe_dic /Y get exec
         currentdict /dt undef
         arrowpath1
         option
         gere_arrowhead
      }
   if

   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} {Y} courbeparam
/courbeparam {
   dup isstring
      {
         tmin tmax
         5 -1 roll
         5 -1 roll
         5 -1 roll
      }
      {
         tmin tmax
         4 -1 roll
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam*
/Courbeparam* {
1 dict begin
   /startest {true} def
   Courbeparam
end
} def

%% syntaxe : {X} {Y} courbeparam*
/courbeparam* {
1 dict begin
   /startest {true} def
   courbeparam
end
} def

%%%%% ### courbe ###
%% syntaxe : {f} courbe
/courbe {
   dup isstring   %% y a-t-il une option de fin de ligne ?
      {
         xmin xmax 
         {} 
         5 -1 roll
         5 -1 roll
      }
      {
         xmin xmax 
         {} 
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : mini maxi {f} Courbe
/Courbe {
   dup isstring {
      {}
      3 -1 roll
      3 -1 roll
   } {
      {}
      2 -1 roll
   } ifelse
   Courbeparam
} def

%% syntaxe : {f} courbe_
/courbe_ {
   xmin xmax 
   {} 
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe_
/Courbe_ {
   {}
   2 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe*
/Courbe* {
1 dict begin
   /startest {true} def
   Courbe
end
} def

%% syntaxe : {f} courbe*
/courbe* {
1 dict begin
   /startest {true} def
   courbe
end
} def

%%%%% ### courbeR2 ###
%% syntaxe : tmin tmax C@urbeR2_
 /C@urbeR2_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR2
   smoveto
   /t t dt add store
   resolution 2 sub
   {
      t courbe_dic /X get exec
      pstrickactionR2
      slineto
      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR2
   slineto
end
} def

%% syntaxe : tmin tmax {X} CourbeR2_
/CourbeR2_ {
   courbe_dic exch /X exch put
   C@urbeR2_
} def

%% syntaxe : {X} courbeR2_
/courbeR2_ {
   tmin tmax
   3 -1 roll
   3 -1 roll
   CourbeR2_
} def

%% syntaxe : tmin tmax {X} CourbeR2
/CourbeR2+ {
2 dict begin
   /slineto {} def
   /smoveto {} def
   CourbeR2
end
} bind def

/CourbeR2 {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin tmax C@urbeR2_
      starfill
   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} courbeR2
/courbeR2 {
   tmin tmax
   3 -1 roll
   CourbeR2
} def

%% syntaxe : tmin tmax {X} CourbeR2*
/CourbeR2* {
1 dict begin
   /startest {true} def
   CourbeR2
end
} def

%% syntaxe : {X} {Y} courbeR2*
/courbeR2* {
1 dict begin
   /startest {true} def
   courbeR2
end
} def

%%%%% ### courbeR3 ###
%% syntaxe : t1 t2 {f} (option) CourbeR3
/CourbeR3 {
2 dict begin
   dup isstring {
      /option exch def
   } if
   /lafonction exch def
   {lafonction 3dto2d}
   currentdict /option known
      {option}
   if
  CourbeR2
end
} def

%% syntaxe : {f} (option) CourbeR3
/courbeR3 {
   tmin tmax 3 -1 roll CourbeR3
} def

%%%%% ### cercle ###
%% syntaxe : x0 y0 r cercle
/cercle {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam
end
} def

%% syntaxe : x0 y0 r cercle_
/cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle-_
/cercle-_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   360 0 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle*
/cercle* {
1 dict begin
   /startest true def
   cercle
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle {
4 dict begin
   dup isstring
      {/option exch def}
   if
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} 
   currentdict /option known
      {option}
   if
   Courbeparam
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle_
/Cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle* {
1 dict begin
   /startest {true} def
   Cercle
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%      fonctions et constantes mathematiques         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### math ###
%%%%%%%%%%% constantes mathematiques %%%%%%%%%%%%%%

/pi 3.14159 def
/e 2.71828 def

%%%%%%%%%%% fonctions mathematiques %%%%%%%%%%%%%%%

/rd {180 pi div mul} def        %% transforme des rd en degres
/deg {pi mul 180 div} def       %% transforme des degres en rd
/log {ln 10 ln div} def
/Exp {e exch exp} def
/Cos {rd cos} def
/Sin {rd sin} def
/tan {dup sin exch cos div} def
/cotan {dup cos exch sin div} def
/Tan {dup Sin exch Cos div} def
/Cotan {dup Cos exch Sin div} def
/coTan {Cotan} def
/arctan {
dup 0 ge
   {1 atan}
   {neg 1 atan neg}
ifelse
} def
/Arctan {arctan deg} def
/arccos {
   dup
   dup mul neg 1 add sqrt
   exch
   atan
} def
/Arccos {arccos deg} def
/arcsin {
   dup 1 eq {
      90
   } {
      dup
      dup mul neg 1 add sqrt
      atan
      dup 90 lt
         {}
         {360 sub}
      ifelse
   } ifelse
} def
/Arcsin {arcsin deg} def
/cosh {dup Exp exch neg Exp add 2 div} def
/sinh {dup Exp exch neg Exp sub 2 div} def
/tanh {dup sinh exch cosh div} def
/cotanh {dup cosh exch sinh div} def
/argcosh {dup dup mul 1 sub sqrt add ln} def
/argsinh {dup dup mul 1 add sqrt add ln} def
/argtanh {
   setxvar
   x 1 add
   1 x sub
   div
   ln
   2 div
} def
/factorielle {
      dup 0 eq
         {pop 1}
         {dup 1 sub factorielle mul}
      ifelse
} def
/Gauss {
3 dict begin
   /sigma exch def
   /m exch def
   /x exch def
   x m sub dup mul sigma dup mul 2 mul div neg Exp
   2 pi mul sigma dup mul mul sqrt div
end
} def
%% syntaxe : a n modulo
/modulo {
2 dict begin
   /n exch def
   /a exch def
   {
      a 0 lt {
         /a a n add store
      } {
         exit
      } ifelse
   } loop
   a n mod
end
} def

%%%%% ### max ###
/max {
   2 copy
   lt {exch} if
   pop
} def

%%%%% ### min ###
/min {
2 dict begin
   dup isarray {
      duparray /table exch def pop
      table 0 get
      1 1 table length 1 sub {
         /i exch def
         table i get
         min
      } for
   } {
      2 copy
      gt {exch} if
      pop
   } ifelse
end
} def

%%%%% ### setcolor ###
%% syntaxe : tableau setcolor
/setcolor {
   dup length 4 eq
      {aload pop setcmykcolor}
      {aload pop setrgbcolor}
   ifelse
} def

%%%%% ### in ###
%% cherche si un elt donne appartient au tableau donne
%% rque : utilise 3 variables locales
%% syntaxe : elt array in --> index boolean
/in {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         i true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%% cherche si un elt donne appartient au tableau donne
%% syntaxe : elt array in --> boolean
/In {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%%%%% ### starfill ###
%% la procedure pour les objets "star"
%% si c est "star" on fait le fillstyle, sinon non
/starfill {
   startest {
      gsave
         clip
         fillstyle
      grestore
      /startest false def
   } if
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### continu ### 
/continu {
   [] 0 setdash 
} def

%%%%% ### trigospherique ### 
%% passage spherique --> cartesiennes
%% les formules de passage ont t rcupres ici :
%%    http://fr.wikipedia.org/wiki/Coordonn%C3%A9es_polaires
%% syntaxe : r theta phi rtp2xyz -> x y z
/rtp2xyz {
6 dict begin
   /phi exch def
   /theta exch def
   /r exch def
   /x phi cos theta cos mul r mul def 
   /y phi cos theta sin mul r mul def
   /z phi sin r mul def
   x y z
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique {
9 dict begin
   dup isstring {
      /option exch def
   } if
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] 
      currentdict /option known {
         option
      } if
      ligne3d
   grestore
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique_ {
8 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   /t pas neg def
   [
      n 1 add {
         /t  t pas add store
         u t cos r mul mulv3d
         w t sin r mul mulv3d
         addv3d
      } repeat
   ] ligne3d_
end
} def

%% trace d'une geodesique sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 geodesique_sphere
/geodesique_sphere {
13 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 360 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /pas 360 n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] ligne3d
   grestore
end
} def


%% syntaxe : A B C trianglespherique --> trace le rtiangle ABC
%% (coordonnees spheriques)
/trianglespherique* {
1 dict begin
   /startest {true} def
   trianglespherique
end
} def

/trianglespherique {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   gsave
   newpath
      A rtp2xyz 3dto2d smoveto
      A B arcspherique_
      B C arcspherique_
      C A arcspherique_
   closepath
   starfill
   currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         operations sur les tableaux                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### duparray ###
/duparray {
1 dict begin
   /table exch def
   table
   [ table aload pop ]
end
} def

%%%%% ### append ###
%% syntaxe : string1 string2 append --> concatene les 2 chaines ou fusionne 2 tableaux
/append {
3 dict begin
   dup isarray {
      /tab2 exch def
      /tab1 exch def
      [ tab1 aload pop tab2 aload pop ]
   } {
      /str2 exch def
      /str1 exch def
      /result str1 length str2 length add string def
      str1 result copy pop
      result str1 length str2 putinterval
      result
   } ifelse
end
} def

%%%%% ### rollparray ###
%% syntaxe : array n rollparray -> array
%% opere une rotation de n sur les couplets du tableau array
/rollparray {
4 dict begin
   /k exch def
   /table exch def
   /n table length def
   k 0 eq {
       table
   } {
       k 0 ge {
          [ table aload pop 2 {n 1 roll} repeat ]
           k 1 sub
       } {
          [ table aload pop 2 {n -1 roll} repeat ]
           k 1 add
       } ifelse
       rollparray
   } ifelse
end
} def

%%%%% ### bubblesort ###
%% syntaxe : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 15/08/2006
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublebubblesort {
5 dict begin
   /table exch def
   /n table length 1 sub def
   /indices [ 0 1 n {} for ] def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            table i get table i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               table i 1 add
               table i get
               table i table i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put

               indices i 1 add
               indices i get
               indices i indices i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   indices table
end
} def

%%%%% ### quicksort ###
%% src : http://www.math.ubc.ca/~cass/graphics/text/www/code/sort.inc
%% code de Bill Casselman, modifie par jpv, 18/10/2007

/qsortdict 8 dict def

qsortdict begin

% args: /comp a L R x
% effect: effects a partition into two pieces [L j] [i R]
%     leaves i j on stack

/partition { 8 dict begin
/x exch def
/j exch def
/i exch def
/a exch def
load /comp exch def
{
  {
    a i get x comp exec not {
      exit
    } if
    /i i 1 add def
  } loop
  {
    x a j get comp exec not {
      exit
    } if
    /j j 1 sub def
  } loop

  i j le {
    % swap a[i] a[j]
    a j a i get
    a i a j get
    put put
    indices j indices i get
    indices i indices j get
    put put
    /i i 1 add def
    /j j 1 sub def
  } if
  i j gt {
    exit
  } if
} loop
i j
end } def

% args: /comp a L R
% effect: sorts a[L .. R] according to comp

/subsort {
% /c a L R
[ 3 1 roll ] 3 copy
% /c a [L R] /c a [L R]
aload aload pop
% /c a [L R] /c a L R L R
add 2 idiv
% /c a [L R] /c a L R (L+R)/2
3 index exch get
% /c a [L R] /c a L R x
partition
% /c a [L R] i j
% if j > L subsort(a, L, j)
dup
% /c a [L R] i j j
3 index 0 get gt {
  % /c a [L R] i j
  5 copy
  % /c a [L R] i j /c a [L R] i j
  exch pop
  % /c a [L R] i j /c a [L R] j
  exch 0 get exch
  % ... /c a L j
  subsort
} if
% /c a [L R] i j
pop dup
% /c a [L R] i i
% if i < R subsort(a, i, R)
2 index 1 get lt {
  % /c a [L R] i
  exch 1 get
  % /c a i R
  subsort
}{
  4 { pop } repeat
} ifelse
} def

end

% args: /comp a
% effect: sorts the array a
% comp returns truth of x < y for entries in a

/quicksort { qsortdict begin
dup length 1 gt {
% /comp a
dup
% /comp a a
length 1 sub
% /comp a n-1
0 exch subsort
} {
pop pop
} ifelse
end } def

% ----------------------------------------

%% fin du code de Bill Casselman

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 18/10/2007
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublequicksort {
qsortdict begin
   /comp exch
   /a exch def
   a dup length /n exch def
   /indices [0 1 n 1 sub {} for ] def
   dup length 1 gt {
      % /comp a
      dup
      % /comp a a
      length 1 sub
      % /comp a n-1
      0 exch subsort
   } {
      pop pop
   } ifelse
   indices a
end
} def

/comp {lt} def

%%%%% ### apply ###
%% syntaxe : [x1 ... xn] (f) apply --> [f(x1) ... f(xn)]
/apply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length {
      liste @i get fonction
      /@i @i 1 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) papply
/papply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length 2 idiv {
      liste @i get
      liste @i 1 add get
      fonction
      /@i @i 2 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) capply 
/capply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse   
   /liste exch def
   /@i 0 def
   [
   liste length 3 idiv {
      liste @i get 
      liste @i 1 add get 
      liste @i 2 add get 
      fonction
      /@i @i 3 add store
   } repeat
   counttomark 
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### reverse ###
%% syntaxe : array reverse --> inverse l ordre des items dans
%% le tableau
/reverse {
3 dict begin
   /le_tableau exch def
   /n le_tableau length def
   /i n 1 sub def
   [
      n {
         le_tableau i get
         /i i 1 sub store
      } repeat
   ]
end
} def

%% syntaxe : array_points reversep --> inverse l ordre des points dans
%% le tableau
/reversep {
3 dict begin
   /le_tableau exch def
   /n le_tableau length 2 idiv def
   /i n 1 sub def
   [
      n {
         le_tableau i getp
         /i i 1 sub store
      } repeat
   ]
end
} def

%%%%% ### get ###
%% syntaxe : array_points n getp --> le n-ieme point du tableau de
%% points array_points
/getp {
   2 copy
   2 mul get
   3 1 roll
   2 mul 1 add get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             matrices                               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### linear ###
%% syntaxe : M i j any --> depose any dans M en a_ij
/put_ij {
5 dict begin
   /a exch def
   /j exch def
   /i exch def
   /M exch def
   /L M i get_Li def
   L j a put
   M i L put_Li
end
} def

%% syntaxe : M i j get_ij --> le coeff c_ij
/get_ij {
   3 1 roll   %% j M i
   get_Li     %% j L_i
   exch get
} def

%% syntaxe : M i L put_Li --> remplace dans M la ligne Li par L
/put_Li {
   put
} def

%% syntaxe : M i get_Li --> la ligne Li de M
/get_Li {
   get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (calculs)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### p3dtoplane ###
%% syntaxe : x y z P p3dtoplane --> X Y
/p3dtoplane {
5 dict begin
   /leplan exch def
   /M defpoint3d
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   I M vecteur3d U scalprod3d
   I M vecteur3d V scalprod3d
end
} def

%%%%% ### pplaneto3d ###
%% syntaxe : x y P pplaneto3d --> X Y Z
/pplaneto3d {
6 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   U x mulv3d
   V y mulv3d addv3d
   I addv3d
end
} def

%%%%% ### orthoprojplane3d ### 
%% Projection orthogonale d'un point 3d sur un plan
%% Mx My Mz (=le point a projeter) 
%% Ax Ay Az (=un point du plan) 
%% Vx Vy Vz (un vecteur normal au plan)
/orthoprojplane3d { 
4 dict begin
   dup isplan {
      /monplan exch def
      monplan plangetorigine
      monplan plangetbase aload pop vectprod3d
   } if
   /V defpoint3d
   /A defpoint3d
   /M defpoint3d
   /VN {V unitaire3d} def
   VN M A vecteur3d VN scalprod3d mulv3d
   M addv3d
end
} def

%%%%% ### sortp3d ### 
/sortp3d {
6 dict begin
   /M1 defpoint3d
   /M0 defpoint3d
   M1
   /z1 exch def
   /y1 exch def
   /x1 exch def
   M0
   /z0 exch def
   /y0 exch def
   /x0 exch def
   x0 x1 lt {
      M0 M1
   } {
      x0 x1 gt {
         M1 M0
      } {
         y0 y1 lt {
            M0 M1
         } {
            y0 y1 gt {
               M1 M0
            } {
               z0 z1 lt {
                  M0 M1
               } {
                  M1 M0
               } ifelse
            } ifelse
         } ifelse
      } ifelse
   } ifelse
end
} def

%%%%% ### dupp3d ### 
%% duplique le vecteur 3d
/dupp3d { %% x y z
        3 copy
} def
/dupv3d {dupp3d} def

%%%%% ### angle3d ###
%% syntaxe : vect1 vect2 angle3d
/angle3d {
4 dict begin
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d norme3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### transformpoint3d ###
%% syntaxe : x y z a11 a21 a31 a12 a22 a32 a13 a23 a33
%%    transformpoint3d -> X Y Z
/transformpoint3d {
12 dict begin
   /a33 exch def
   /a23 exch def
   /a13 exch def
   /a32 exch def
   /a22 exch def
   /a12 exch def
   /a31 exch def
   /a21 exch def
   /a11 exch def
   /z   exch def
   /y   exch def
   /x   exch def
   a11 x mul a12 y mul add a13 z mul add
   a21 x mul a22 y mul add a23 z mul add
   a31 x mul a32 y mul add a33 z mul add
end
} def

%%%%% ### normalize3d ###
%% rend le vecteur 3d unitaire. Ne fait rien si u=0
/unitaire3d { %% x y z
2 dict begin
   /u defpoint3d
   /norme u norme3d def
   norme 0 eq {
      u
   } {
      u 1 norme div mulv3d
   } ifelse
end
} def
/normalize3d {unitaire3d} def

%%%%% ### geom3d ###
%% syntaxe : A k1 B k2 barycentre3d -> G, barycentre du systeme
%% [(A, k1) (B, k2)]
/barycentre3d {
4 dict begin
   /k2 exch def
   /B defpoint3d
   /k1 exch def
   /A defpoint3d
   A k1 mulv3d
   B k2 mulv3d
   addv3d
   1 k1 k2 add div mulv3d
end
} def

%% syntaxe : array isobarycentre3d --> G
/isobarycentre3d {
2 dict begin
   /table exch def
   /n table length 3 idiv def
   table 0 getp3d
   1 1 n 1 sub {
       table exch getp3d
       addv3d
   } for
   1 n div mulv3d
end
} def

%% syntaxe : M A alpha hompoint3d -> le point M' tel que AM' = alpha AM 
/hompoint3d {
3 dict begin
   /alpha exch def
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d alpha mulv3d A addv3d
end
} def

%% syntaxe : M A sympoint3d -> le point M' tel que AM' = -AM
/sympoint3d {
2 dict begin
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d -1 mulv3d A addv3d
end
} def

%% syntaxe : A u translatepoint3d --> B image de A par la translation de vecteur u
/translatepoint3d {
   addv3d
} def

/scaleOpoint3d {
6 dict begin
   /k3 exch def
   /k2 exch def
   /k1 exch def
   /z exch def
   /y exch def
   /x exch def
   k1 x mul
   k2 y mul
   k3 z mul
end
} def

% syntaxe : M alpha_x alpha_y alpha_z rotateOpoint3d --> M'
/rotateOpoint3d {
21 dict begin
   /RotZ exch def
   /RotY exch def
   /RotX exch def
   /Zpoint exch def
   /Ypoint exch def
   /Xpoint exch def
   /c1 {RotX cos} bind def
   /c2 {RotY cos} bind def
   /c3 {RotZ cos} bind def
   /s1 {RotX sin} bind def
   /s2 {RotY sin} bind def
   /s3 {RotZ sin} bind def
   /M11 {c2 c3 mul} bind def
   /M12 {c3 s1 mul s2 mul c1 s3 mul sub} bind def
   /M13 {c1 c3 mul s2 mul s1 s3 mul add} bind def
   /M21 {c2 s3 mul} bind def
   /M22 {s1 s2 mul s3 mul c1 c3 mul add} bind def
   /M23 {s3 s2 mul c1 mul c3 s1 mul sub} bind def
   /M31 {s2 neg} bind def
   /M32 {s1 c2 mul} bind def
   /M33 {c1 c2 mul} bind def
   M11 Xpoint mul M12 Ypoint mul add M13 Zpoint mul add
   M21 Xpoint mul M22 Ypoint mul add M23 Zpoint mul add
   M31 Xpoint mul M32 Ypoint mul add M33 Zpoint mul add
end
} def

%%%%% ### symplan3d ###
%% syntaxe : M eqplan/plantype symplan3d --> M'
%% ou M' symetrique de M par rapport au plan P defini par eqplan/plantype
/symplan3d {
13 dict begin
   dup isplan {
      plan2eq /args exch def
   } {
      /args exch def
   } ifelse
   /z exch def
   /y exch def
   /x exch def
   args aload pop
   /d1 exch def
   /c1 exch def
   /b1 exch def
   /a1 exch def
   /n_U a1 dup mul b1 dup mul add c1 dup mul add sqrt def
   /a a1 n_U div def
   /b b1 n_U div def
   /c c1 n_U div def
   /d d1 n_U div def
   /u a x mul b y mul add c z mul add d add def
   x 2 a mul u mul sub
   y 2 b mul u mul sub
   z 2 c mul u mul sub
end
} def

%%%%% ### vecteur3d ###
%% creation du vecteur AB a partir de A et B
/vecteur3d { %% xA yA zA xB yB zB
6 dict begin
   /zB exch def
   /yB exch def
   /xB exch def
   /zA exch def
   /yA exch def
   /xA exch def
   xB xA sub
   yB yA sub
   zB zA sub
end
}def

%%%%% ### vectprod3d ###
%% produit vectoriel de deux vecteurs 3d
/vectprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub
end
} def

%%%%% ### scalprod3d ###
%% produit scalaire de deux vecteurs 3d
/scalprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp mul y yp mul add z zp mul add
end
} def

%%%%% ### papply3d ###
%% syntaxe : [A1 ... An] (f) papply3d --> [f(A1) ... f(An)]
/papply3d {
3 dict begin
   /fonction exch def
   /liste exch def
   /i 0 def
   [
   liste length 3 idiv {
      liste i get
      liste i 1 add get
      liste i 2 add get
      fonction
      /i i 3 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### defpoint3d ###
%% creation du point A a partir de xA yA yB et du nom /A
/defpoint3d { %% xA yA zA /nom
1 dict begin
   /memo exch def
   [ 4 1 roll ] cvx memo exch
end def
}def

%%%%% ### distance3d ###
/distance3d { %% A B
   vecteur3d norme3d
} def

%%%%% ### get3d ###
/getp3d { %% [tableau de points 3d] i --> donne le ieme point du tableau
   2 copy 2 copy
   3 mul get
   5 1 roll
   3 mul 1 add get
   3 1 roll
   3 mul 2 add get
} def

%%%%% ### norme3d ###
%% norme d un vecteur 3d
/norme3d { %% x y z
3 dict begin
   /z exch def
   /y exch def
   /x exch def
   x dup mul y dup mul add z dup mul add sqrt
end
} def

%%%%% ### mulv3d ###
%% (scalaire)*(vecteur 3d) Attention : dans l autre sens !
/mulv3d { %% x y z lambda
4 dict begin
   /lambda exch def
   /z exch def
   /y exch def
   /x exch def
   x lambda mul
   y lambda mul
   z lambda mul
end
} def

%%%%% ### addv3d ###
%% addition de deux vecteurs 3d
/addv3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp add
   y yp add
   z zp add
end
} def

%%%%% ### milieu3d ###
/milieu3d { %% A B --> I le milieu de [AB]
   addv3d 0.5 mulv3d
} def

%%%%% ### exch ###
/exchp {
   4 -1 roll
   4 -1 roll
} def
/exchc {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def
/exchd {
   4 {8 -1 roll} repeat
} def
/exchp3d {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def

%%%%% ### ABpoint3d ###
%% syntaxe : A B k ABpoint3d --> M
%% M tel que vect(AM) = k vect (AB)
/ABpoint3d {
3 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   k mulv3d
   A addv3d 
end
} def

%%%%% ### angle3doriente ###
%% syntaxe : vect1 vect2 vect3 angle3d
%% vect3 est la normale au plan (vect1, vect2)
/angle3doriente {
4 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d vect3 scalprod3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### points3dalignes ###
%% syntaxe : A B C points3dalignes -> bool
/points3dalignes {
3 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d /u defpoint3d
   A C vecteur3d /v defpoint3d
   u v vectprod3d norme3d 1E-7 lt
end
} def

%% syntaxe : M A B point3dsursegment --> true si M in [AB], false sinon
/point3dsursegment {
3 dict begin
   /B defpoint3d
   /A defpoint3d
   /M defpoint3d
   M A B points3dalignes {
      M A vecteur3d
      M B vecteur3d
      scalprod3d 0 lt {
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (dessins)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### point3d ###
/point3d { %% A
   3dto2d point
} def

/points3d { %% tableau de points3d
   tab3dto2d points
} def

%%%%% ### ligne3d ###
%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne
end
} def

%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d_ { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne_
end
} def

%%%%% ### tab3dto2d ###
%% transforme un tableau de points 3d en tableau de points 2d
/tab3dto2d {
2 dict begin
   /T exch def
   /n T length def
   [ T aload pop
   n 1 sub -1 n 3 idiv 2 mul
   { 1 dict begin
   /i exch def
   3dto2d i 2 roll
   end } for ]
end
} def

%%%%% ### polygone3d ###
/polygone3d { %% tableau de points3d
   tab3dto2d polygone
} def

/polygone3d* { %% tableau de points3d
   tab3dto2d polygone*
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 gestion du texte                   %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### marks ###
/xmkstep 1 def          % les marques sur Ox
/xmarkstyle {dctext} def
/ymarkstyle {(-1 0) bltext} def
/setxmkstep {
   /xmkstep exch def
} def
/xmark {
   dup xtick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup dup truncate eq {
      cvi dup chaine cvs exch 
   } {
      dup chaine cvs exch 
   } ifelse
   Oy xmarkstyle
} def
/xmarks {
2 dict begin
   /n xmax xmax xmin sub 1000 div sub xmkstep div truncate cvi 
      xmkstep mul def                   % mark max
   /i xmin xmkstep div truncate cvi 
      xmkstep mul def                   % la 1ere
   i xmin lt {/i i xmkstep add store} if
   {
      i 0 ne {i xmark} if
      /i i xmkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/ymkstep 1 def          % les marques sur Oy
/setymkstep {
   /ymkstep exch def
} def
/ymark {
   dup ytick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup chaine cvs exch 
   Ox exch ymarkstyle
} def
/ymarks {
2 dict begin
   /n ymax ymax ymin sub 1000 div sub ymkstep div truncate cvi 
      ymkstep mul def                   % mark max
   /i ymin ymkstep div truncate cvi 
      ymkstep mul def                   % la 1ere
   {
      i 0 ne {i ymark} if
      /i i ymkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/setmkstep {
   setymkstep
   setxmkstep
} def
/marks {
   xmarks
   ymarks
} def

%%%%% ### setfontsize ###
/setfontsize {
   /fontsize exch def
} def

%%%%% ### setCourrier ###
/Courier findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end

/Courier-ISOLatin1 exch definefont pop

/setCourier {
   /Courier-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

%%%%% ### pathtext ###
%% syntaxe : string x y initp@thtext
 /initp@thtext {
7 dict begin
   /y exch def
   /x exch def
   /str exch def
   str 0 0 show_dim
   /wy exch def
   /wx exch def
   /lly exch def
   /llx exch def
   pop pop pop
   newpath 
      x y  smoveto
} def
 /closep@thtext {
      str true charpath
end
} def

%% syntaxe : string x y cctext_
/cctext_ {
   initp@thtext
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

/brtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg 0 rmoveto
   closep@thtext
} def

/bbtext_ {
   initp@thtext
   0 0 rmoveto
   0 0 rmoveto
   closep@thtext
} def

/bltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg 0 rmoveto
   closep@thtext
} def

/bctext_ {
   initp@thtext
   0 0 rmoveto
   wx llx add -.5 mul 0 rmoveto
   closep@thtext
} def

/ubtext_ {
   initp@thtext
   0 vadjust rmoveto
   0 lly neg rmoveto
   closep@thtext
} def

/urtext_ {
   initp@thtext
   hadjust vadjust rmoveto
   llx neg lly neg rmoveto
   closep@thtext
} def

/ultext_ {
   initp@thtext
   hadjust neg vadjust rmoveto
   wx neg lly neg rmoveto
   closep@thtext
} def

/uctext_ {
   initp@thtext
   0 vadjust rmoveto
   llx wx add -.5 mul lly neg rmoveto
   closep@thtext
} def

/drtext_ {
   initp@thtext
   hadjust vadjust neg rmoveto
   llx neg wy neg rmoveto
   closep@thtext
} def

/dbtext_ {
   initp@thtext
   0 vadjust neg rmoveto
   0 wy neg rmoveto
   closep@thtext
} def

/dltext_ {
   initp@thtext
   hadjust neg vadjust neg rmoveto
   wx neg wy neg rmoveto
   closep@thtext
} def

/dctext_ {
   initp@thtext
   0 vadjust neg rmoveto
   llx wx add -2 div wy neg rmoveto
   closep@thtext
} def

/crtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cbtext_ {
   initp@thtext
   0 0 rmoveto
   0 lly wy add -2 div rmoveto
   closep@thtext
} def

/cltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cctext_ {
   initp@thtext
   0 0 rmoveto
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

%%%%% ### text3d ###
%%%% Version 3d des commandes jps TEXTE
 /pr@p@re3d {
2 dict begin
%   /vect_echelle [1 1] def
%   /angle_de_rot {0} def
%   dup xcheck
%      {/angle_de_rot exch def}
%   if
%   dup isarray
%      {/vect_echelle exch def}
%   if%   CamView vect_echelle {angle_de_rot}
   3dto2d
} def

/bbtext3d {
   pr@p@re3d
   bbtext
end
} def

/bbtexlabel3d {
   pr@p@re3d
   bbtexlabel
end
} def

/bctext3d {
   pr@p@re3d
   bctext
end
} def

/bctexlabel3d {
   pr@p@re3d
   bctexlabel
end
} def

/bltext3d {
   pr@p@re3d
   bltext
end
} def

/bltexlabel3d {
   pr@p@re3d
   bltexlabel
end
} def

/brtext3d {
   pr@p@re3d
   brtext
end
} def

/brtexlabel3d {
   pr@p@re3d
   brtexlabel
end
} def

/cbtext3d {
   pr@p@re3d
   cbtext
end
} def

/cbtexlabel3d {
   pr@p@re3d
   cbtexlabel
end
} def

/cctext3d {
   pr@p@re3d
   cctext
end
} def

/cctexlabel3d {
   pr@p@re3d
   cctexlabel
end
} def

/cltext3d {
   pr@p@re3d
   cltext
end
} def

/cltexlabel3d {
   pr@p@re3d
   cltexlabel
end
} def

/crtext3d {
   pr@p@re3d
   crtext
end
} def

/crtexlabel3d {
   pr@p@re3d
   crtexlabel
end
} def

/dbtext3d {
   pr@p@re3d
   dbtext
end
} def

/dbtexlabel3d {
   pr@p@re3d
   dbtexlabel
end
} def

/dctext3d {
   pr@p@re3d
   dctext
end
} def

/dctexlabel3d {
   pr@p@re3d
   dctexlabel
end
} def

/dltext3d {
   pr@p@re3d
   dltext
end
} def

/dltexlabel3d {
   pr@p@re3d
   dltexlabel
end
} def

/drtext3d {
   pr@p@re3d
   drtext
end
} def

/drtexlabel3d {
   pr@p@re3d
   drtexlabel
end
} def

/ubtext3d {
   pr@p@re3d
   ubtext
end
} def

/ubtexlabel3d {
   pr@p@re3d
   ubtexlabel
end
} def

/uctext3d {
   pr@p@re3d
   uctext
end
} def

/uctexlabel3d {
   pr@p@re3d
   uctexlabel
end
} def

/ultext3d {
   pr@p@re3d
   ultext
end
} def

/ultexlabel3d {
   pr@p@re3d
   ultexlabel
end
} def

/urtext3d {
   pr@p@re3d
   urtext
end
} def

/urtexlabel3d {
   pr@p@re3d
   urtexlabel
end
} def

%%%%% ### fin insertion ###

%% La macro provisoire de developpement (27/01/2009)
%% syntaxe : solid table tablez --> -
/solidcolorz {
10 dict begin
   %% les hauteurs
   /tablez exch def
   %% les couleurs
   /usertable exch def
   /solid exch def
   %% a-t-on des couleurs nommees ?
   usertable 0 get isstring {
      %% oui, et autant que d etages
      usertable length 1 sub tablez length eq {
         /table usertable def
      } {
         %% oui, mais moins que d etages
	 %% ==> on definit les 2 premieres en RGB
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         /lacouleurdepart {
            gsave
               [a0 cvx exec] length 0 eq {
                  a0 cvx exec currentrgbcolor
               } {
                  a0 cvx exec
               } ifelse 
            grestore
         } def
         /lacouleurarrivee {
            gsave
               [a1 cvx exec] length 0 eq {
                  a1 cvx exec currentrgbcolor
               } {
                  a1 cvx exec
               } ifelse 
            grestore
         } def
         /usertable [lacouleurdepart lacouleurarrivee] def
      } ifelse
   } if
   usertable 0 get isnum {
      %% c est un degrade : nb de couleurs a definir
      /n tablez length 1 add def
%      
      usertable length 4 eq {
          /a0 usertable 0 get def
          /a1 usertable 1 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B usertable 2 get def
          /C usertable 3 get def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%      
      usertable length 6 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (setrgbcolor) def
      } if
%
      usertable length 7 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%   
      usertable length 8 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /d0 usertable 3 get def
          /a1 usertable 4 get def
          /b1 usertable 5 get def
          /c1 usertable 6 get def
          /d1 usertable 7 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {d0 i d1 d0 sub mul n 1 sub div add} def
          /espacedecouleurs (setcmykcolor) def
      } if
%
      usertable length 2 eq {
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         0 1 n 1 sub {
            /i exch def
            /A {a0 i a1 a0 sub mul n 1 sub div add} def
            /B {1} def
            /C {1} def
            /D {} def
            /espacedecouleurs (sethsbcolor) def
         } for
      } if
%
      %% on affecte la table des couleurs
      /table [
         0 1 n 1 sub {
            /i exch def
            [A B C D] espacedecouleurs astr2str
         } for
      ] def
   } if
%
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /z exch def pop pop
      /resultat 0 def
      0 1 tablez length 1 sub {
         /j exch def
         /ztest tablez j get def
         z ztest le {
	    /resultat j store
            exit
         } {
	    /resultat j 1 add store
	 } ifelse
      } for
      solid i table resultat get solidputfcolor
   } for
end
} def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             bibliotheque sur les solides           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solide ###
%% solid = [Sommets Faces Colors_Faces InOut_Table]
/solidgetsommets {
   0 get
} def
/solidgetpointstable {solidgetsommets} def

/solidgetfaces {
   1 get
} def

/solidgetface {
1 dict begin
   /i exch def
   solidgetfaces i get
end
} def

/solidgetfcolors {
   2 get
} def

%% syntaxe : solid i solidgetfcolor --> str
/solidgetfcolor {
1 dict begin
   /i exch def
   solidgetfcolors i get
end
} def

%% syntaxe : solid i str solidputfcolor --> -
/solidputfcolor {
2 dict begin
   /str exch def
   /i exch def
   solidgetfcolors i str put
end
} def

/solidgetinouttable {
   3 get
} def

/solidputsommets {
   0 exch put
} def
/solidputpointstable {solidputsommets} def

/solidputfaces {
   1 exch put
} def

%% syntaxe : solid solidfacesreverse -> -
/solidfacesreverse {
5 dict begin
   /solid exch def
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      /F solid i solidgetface reverse def
      /m F length def
      solid i [F aload pop m 0 roll ] solidputface
   } for
end
} def

/solidputfcolors {
   2 exch put
} def

/solidputinouttable {
   3 exch put
} def

%% syntaxe : any issolid --> booleen, vrai si any est de type solid
/issolid {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 4 eq {
         candidat 0 get isarray
         candidat 1 get isarray and
         candidat 2 get isarray and
         candidat 3 get isarray and {
            /IO candidat 3 get def
            IO length 4 eq 
            IO 0 get isnum and
            IO 1 get isnum and
            IO 2 get isnum and
            IO 3 get isnum and
	 } {
	    false
	 } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/dupsolid {
5 dict begin
   /solid exch def
   /S solid solidgetsommets def
   /F solid solidgetfaces def
   /FC solid solidgetfcolors def
   /IO solid solidgetinouttable def
   solid
   [
      S duparray exch pop
      F duparray exch pop
      FC duparray exch pop
      IO duparray exch pop
   ]
end
} def

%% syntaxe : solid array solidputinfaces --> -
/solidputinfaces {
4 dict begin
   /facesinternes exch def
   /solid exch def
   /n2 facesinternes length def
   /IO solid solidgetinouttable def
   /facesexternes solid solidgetoutfaces def
   /n1 facesexternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

%% syntaxe : solid array solidputoutfaces --> -
/solidputoutfaces {
4 dict begin
   /facesexternes exch def
   /solid exch def
   /n1 facesexternes length def
   /IO solid solidgetinouttable def
   /facesinternes solid solidgetinfaces def
   /n2 facesinternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

/solidnombreinfaces {
1 dict begin
   /solid exch def
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get IO 2 get sub 1 add
   } {
      0
   } ifelse
end
} def

/solidnombreoutfaces {
1 dict begin
   /solid exch def
   /IO solid solidgetinouttable def
   IO 1 get IO 0 get sub 1 add
end
} def

%% syntaxe : solid solidgetinfaces --> array
/solidgetinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      /F solid solidgetfaces def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      F n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutfaces --> array
/solidgetoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutfaces) ==
      quit
   } if
   /IO solid solidgetinouttable def
   /F solid solidgetfaces def
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   F n1 n getinterval
end
} def

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def

/solidgridOn {
   /solidgrid true def
} def
/solidgridOff {
   /solidgrid false def
} def

%% syntaxe : solid i string solidputfcolor
%% syntaxe : solid str outputcolors
%% syntaxe : solid str1 str2 inoutputcolors
%% syntaxe : solid string n solidputncolors
%% syntaxe : solid array solidputincolors --> -
%% syntaxe : solid array solidputoutcolors --> -
%% syntaxe : solid solidgetincolors --> array
%% syntaxe : solid solidgetoutcolors --> array

%% syntaxe : solid array solidputinfaces --> -
%% syntaxe : solid array solidputoutfaces --> -
%% syntaxe : solid solidgetinfaces --> array
%% syntaxe : solid solidgetoutfaces --> array

%% syntaxe : solid1 solid2 solidfuz -> solid

%% syntaxe : solid i solidgetsommetsface -> array
%% array = tableau de points 3d
/solidgetsommetsface {
1 dict begin
   /i exch def
   /solid exch def
   /F solid i solidgetface def
   [
      0 1 F length 1 sub {
         /k exch def
         solid F k get solidgetsommet
      } for
   ]
end
} def

%% syntaxe : solid index table solidputface -> -
/solidputface {
1 dict begin
   /table exch def
   /i exch def
   solidgetfaces i table put
end
} def

%% syntaxe : solid table solidaddface -> -
%% syntaxe : solid table (couleur) solidaddface -> -
%% on ne se preoccupe pas des faces internes
/solidaddface {
6 dict begin
   dup isstring {
      /lac@uleur exch def
   } {
      /lac@uleur () def
   } ifelse
   /table exch def
   /solid exch def
   /IO solid solidgetinouttable def
   /n2 IO 1 get def
   /FC solid solidgetoutcolors def
   IO 1 n2 1 add put
   solid [ solid solidgetfaces aload pop table ] solidputfaces
   solid IO solidputinouttable
%   solid solidnombrefaces
    solid [
      FC aload pop lac@uleur
    ] solidputoutcolors
end
} def

/solidnombrefaces {
1 dict begin
   /solid exch def
   solid solidnombreinfaces
   solid solidnombreoutfaces
   add 
end
} def

%% syntaxe : solid M solidaddsommetexterne -> -
%% on ajoute le sommet sans se preoccuper de rien
/solidaddsommetexterne {
2 dict begin
   /M defpoint3d
   /solid exch def
   solid
   [ solid solidgetsommets aload pop M ]
   solidputsommets
end
} def

%% syntaxe : solid array solidaddsommets -> -
/solidaddsommets {
2 dict begin
   /table exch def
   /solid exch def
   /n table length 3 idiv def
   0 1 0 {
      /i exch def
      solid table i getp3d solidaddsommet pop
   } for
end
} def

%% syntaxe : solid M solidaddsommet -> k
%% on ajoute le sommet M. Si il est deja sur une arete,
%% on l incorpore a la face concernee 
%% s il est deja present, on ne le rajoute pas.
%% Renvoie l indice du sommet rajoute.
/solidaddsommet {
10 dict begin
   /M defpoint3d
   /solid exch def
   /nbf solid solidnombrefaces def
   /N solid solidnombresommets def
   /sortie -1 def
   %% le sommet est-il deja dans la structure
   0 1 N 1 sub {
      /i exch def
%%       (addsommet) ==
%%       solid i solidgetsommet == == == 
%%       M == == ==
%%       solid i solidgetsommet M eqp3d ==
   
%      solid i solidgetsommet M eqp3d {
      solid i solidgetsommet M distance3d 1e-5 le {
         %% oui => c est fini
         /sortie i store
      } if
   } for
   sortie 0 lt {
      %% non => on le rajoute
      /sortie N def
      solid M solidaddsommetexterne
      %% est il sur une arete deja codee
      0 1 nbf 1 sub {
         %% face d indice i
         /i exch def
         solid i solidgetface /F exch def
         /nbsf F length def
         0 1 nbsf 1 sub {
            /j exch def
            M
            solid j i solidgetsommetface 
            solid j 1 add nbsf mod i solidgetsommetface 
            point3dsursegment {
               %% il est sur l arete concernee
               solid i [
                  0 1 j {
                     /k exch def
                     F k get
                  } for
                  N
                  j 1 add nbsf mod dup 0 eq {
                     pop
                  } {
                     1 nbsf 1 sub {
                        /k exch def
                        F k get
                     } for
                  } ifelse
               ]  solidputface
               exit
            } if
         } for 
      } for
   } if
   sortie
end
} def

%%%%% ### solidrmsommet ###
%% syntaxe : solid i solidrmsommet -> -
/solidrmsommet {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidrmsommet) ==
      quit 
   } if
   solid i solidsommetsadjsommet length 0 gt {
      (Erreur : sommet non isole dans solidrmsommet) ==
      quit 
   } if

   %% on s occupe des sommets
   /n solid solidnombresommets def
   /S [
      0 1 n 1 sub {
         /j exch def
         j i ne {
            solid j solidgetsommet
         } if
      } for
   ] def
   solid S solidputsommets
   %% on s occupe des faces
   /n solid solidnombrefaces def
   /F [
      0 1 n 1 sub {
         %% face d indice j
         /j exch def
         /Fj solid j solidgetface def
         [0 1 Fj length 1 sub {
            %% sommet d indice k de la face Fj
            /k exch def
            Fj k get dup i gt {
               1 sub
            } if
         } for]
      } for
   ] def
   solid F solidputfaces
end
} def

%%%%% ### solidsommetsadjsommet ###
%% syntaxe : solid i solidsommetsadjsommet --> array
%% array est le tableau des indices des sommets adjacents au
%% sommet d indice i
/solidsommetsadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   solid no solidfacesadjsommet /facesadj exch def
   /sommetsadj [] def
   /nbadj facesadj length def
   0 1 nbadj 1 sub {
      /j exch def
      %% examen de la jieme face
      %/j 0 def
      /F solid facesadj j get solidgetface def
      /nbsommetsface F length def
      no F in {
         /index exch def
         /i1 F index 1 sub nbsommetsface modulo get def
         /i2 F index 1 add nbsommetsface mod get def
         %% si i1 n est pas deja note, on le rajoute
         i1 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i1 ] store
         } ifelse
         %% si i2 n est pas deja note, on le rajoute
         i2 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i2 ] store
         } ifelse
      } {
         (Error : bug dans solidsommetsadjsommet) ==
         quit
      } ifelse
   } for
   sommetsadj
end
} def

%%%%% ### solidfacesadjsommet ###
%% syntaxe : solid i solidfacesadjsommet --> array
%% array est le tableau des indices des faces adjacentes au
%% sommet d indice i
/solidfacesadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   /n solid solidnombrefaces def
   /indicesfacesadj [] def
   0 1 n 1 sub {
      /j exch def
      /F solid j solidgetface def
      no F in {
         pop
         /indicesfacesadj [ indicesfacesadj aload pop j ] store
      } if
   } for
   indicesfacesadj
end
} def

%%%%% ### ordonnepoints3d ###
%% syntaxe : array1 M ordonnepoints3d --> array2
%% array1 = tableau de points 3d coplanaires (plan P)
%% M = point3d indiquant la direction de la normale a P
%% array2 = les indices des points de depart, ranges dans le 
%% sens trigo par rapport a la normale
/ordonnepoints3d {
5 dict begin
   /M defpoint3d
   /table exch def
   table isobarycentre3d /G defpoint3d
   %% calcul de la normale
   table 0 getp3d /ptref defpoint3d
   table 1 getp3d /A defpoint3d
   G ptref vecteur3d
   G A vecteur3d
   vectprod3d /vecteurnormal defpoint3d
   vecteurnormal G M vecteur3d scalprod3d 0 lt {
      vecteurnormal -1 mulv3d /vecteurnormal defpoint3d
   } if
   %% la table des angles
   table duparray exch pop
   {1 dict begin
      /M defpoint3d
      G ptref vecteur3d
      G M vecteur3d
      vecteurnormal angle3doriente
   end} papply3d
%   [0 1 table length 3 idiv 1 sub {} for]
%   exch
    doublebubblesort pop
end
} def

%%%%% ### fin insertion ###

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% 
%% /solidgrid true def
%% /aretescachees true def
%% /defaultsolidmode 2 def

%% syntaxe : alpha beta r h newpie --> solid
/newpie {
6 dict begin
   [[/resolution /nbetages] [8 1] [10 1] [12 1] [18 3] [36 5]] gestionsolidmode
   /h exch def
   /r exch def
   /beta exch def
   /alpha exch def
   [
      0 0
%      alpha cos r mul alpha sin r mul
      alpha beta {1 dict begin /t exch def t cos r mul t sin r mul end} CourbeR2+
   ] 0 h [nbetages] newprismedroit
end
} def

%%%%% ### newsolid ###
%% syntaxe : newsolid --> depose le solide nul sur la pile
/newsolid {
   [] [] generesolid
} def

%%%%% ### generesolid ###
/generesolid {
2 dict begin
   /F exch def
   /S exch def
   [S F [F length {()} repeat] [0 F length 1 sub -1 -1]]
end
} def

%%%%% ### nullsolid ###
%% syntaxe : solide nullsolid -> booleen, vrai si le solide est nul
/nullsolid {
1 dict begin
   /candidat exch def
   candidat issolid not {
      (Error type argument dans "nullsolid") ==
      quit
   } if
   candidat solidgetsommets length 0 eq {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidnombreoutfaces ###
/solidnombreoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreoutfaces) ==
      quit
   } if
   solid nullsolid {
      0
   } {
      /IO solid solidgetinouttable def
      IO 1 get
      IO 0 get sub
      1 add
   } ifelse
end
} def

%%%%% ### solidnombreinfaces ###
/solidnombreinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get
      IO 2 get sub
      1 add
   } {
      0
   } ifelse
end
} def

%%%%% ### solidtests ###
%% syntaxe : solid solidwithinfaces --> bool, true si le solide est vide
/solidwithinfaces {
2 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidwithinfaces) ==
      quit
   } if
   /table solid solidgetinouttable def
   table 2 get -1 ne {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidgetsommet ###
%% syntaxe : solid i j solidgetsommetface --> sommet i de la face j
/solidgetsommetface {
6 dict begin
   /j exch def
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /k table_faces j get i get def
   table_sommets k getp3d
end
} def

%% syntaxe : solid i solidgetsommetsface --> array, tableau des
%% sommets de la face i du solide
/solidgetsommetsface {
6 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetsface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /table_indices table_faces i get def
   [
      0 1 table_indices length 1 sub {
         /j exch def
         table_sommets table_indices j get getp3d
      } for
   ]
end
} def

%% syntaxe : solid i solidgetsommet --> sommet i du solide
/solidgetsommet {
3 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommet) ==
      quit
   } if
   /table_sommets solid solidgetsommets def
   table_sommets i getp3d
end
} def

%%%%% ### solidcentreface ###
%% syntaxe : solid i solidcentreface --> M
/solidcentreface {
   solidgetsommetsface isobarycentre3d
} def

%%%%% ### solidnombre ###
/solidnombresommets {
   solidgetsommets length 3 idiv
} def

/solidfacenombresommets {
   solidgetface length
} def

/solidnombrefaces {
   solidgetfaces length
} def

%%%%% ### solidshowsommets ###
/solidshowsommets {
8 dict begin
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      sol i solidgetsommet point3d
   } for
end
} def

%%%%% ### solidnumsommets ###
/solidnumsommets {
8 dict begin
%   Font findfont 10 scalefont setfont
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   /result [
      n {false} repeat
   ] def
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      0 1 m 1 sub {
         /j exch def %% indice de la face examinee
         i sol j solidgetface in {
            %% le sommet i est dans la face j
            pop
            exit
         } if
      } for
      sol i solidgetsommet /S defpoint3d
      i (   ) cvs
      m 0 ne {
         %% le sommet i est dans la face j
         sol j solidcentreface /G defpoint3d
         G S vecteur3d normalize3d
         15 dup ptojpoint pop
         mulv3d
         S addv3d
         3dto2d cctext 
      } {
         S 3dto2d uctext
      } ifelse
   } for
end
} def

%%%%% ### gestionsolidmode ###
%% table = [ [vars] [mode0] [mode1] [mode2] [mode3] [mode4] ]
/gestionsolidmode {
5 dict begin
   /table exch def
   dup xcheck {
      /mode exch def
   } {
      dup isarray {
         /tableaffectation exch def
         /mode -1 def
      } {
         /mode defaultsolidmode def
      } ifelse
   } ifelse
   /vars table 0 get def
   /nbvars vars length def
   mode 0 ge {
      /tableaffectation table mode 1 add 5 min get def
   } if
   0 1 nbvars 1 sub {
      /i exch def
      vars i get
      tableaffectation i get
   } for
   nbvars 
end
   {def} repeat
} def

%%%%% ### solidfuz ###
%% syntaxe : solid1 solid2 solidfuz -> solid
/solidfuz {
5 dict begin
   /solid2 exch def
   /solid1 exch def
   /S1 solid1 solidgetsommets def
   /S2 solid2 solidgetsommets def
   /n S1 length 3 idiv def

   %% les sommets
   /S S1 S2 append def

   %% les faces internes et leurs couleurs
   /FI1 solid1 solidgetinfaces def
   /FIC1 solid1 solidgetincolors def
   solid2 solidnombreinfaces 0 eq {
      /FI2 [] def
      /FIC2 [] def
   } {
      /FI2 solid2 solidgetinfaces {{n add} apply} apply def
      /FIC2 solid2 solidgetincolors def
   } ifelse
   /FI [FI1 aload pop FI2 aload pop] def
   /FIC [FIC1 aload pop FIC2 aload pop] def

   %% les faces externes et leurs couleurs
   /FO1 solid1 solidgetoutfaces def
   /FOC1 solid1 solidgetoutcolors def
   /FO2 solid2 solidgetoutfaces {{n add} apply} apply def
   /FOC2 solid2 solidgetoutcolors def
   /FO [FO1 aload pop FO2 aload pop] def
   /FOC [FOC1 aload pop FOC2 aload pop] def

   /F [FO aload pop FI aload pop] def
   /FC [FOC aload pop FIC aload pop] def
   /IO [
      0 FO length 1 sub
      FI length 0 gt {
         dup 1 add dup FI length add 1 sub
      } {
         -1 -1
      } ifelse
   ] def

   S F generesolid
   dup FC solidputfcolors
   dup IO solidputinouttable
end
} def

%%%%% ### solidnormaleface ###
%% syntaxe : solid i solidnormaleface --> u, vecteur normale a la
%% face d indice i du solide
/solidnormaleface {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
%%    solid 0 i solidgetsommetface /G defpoint3d
%%    G
%%    solid 1 i solidgetsommetface
%%    vecteur3d
%%    G
%%    solid 2 i solidgetsommetface
%%    vecteur3d

   /n solid i solidfacenombresommets def
   solid i solidcentreface /G defpoint3d
  %% debug %%   G 3dto2d point
   G
   solid 0 i solidgetsommetface
   /A defpoint3d
  %   gsave bleu A point3d grestore
   A
   vecteur3d normalize3d
   G
   solid 1 i solidgetsommetface
   /A defpoint3d
  %   gsave orange A point3d grestore
   A
   vecteur3d normalize3d
   vectprod3d
   /resultat defpoint3d
   resultat normalize3d
end
} def

%%%%% ### solidtransform ###
%% syntaxe : solid1 {f} solidtransform --> solid2, solid2 est le
%% transforme de solid1 par la transformation f : R^3 -> R^3
/solidtransform {
3 dict begin
   /@f exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidtransform) ==
      quit
   } if
   /les_sommets
      solid solidgetsommets {@f} papply3d
   def
   solid les_sommets solidputsommets
   solid
end
} def

%%%%% ### solidputcolor ###
%% syntaxe : solid i string solidputfcolor
/solidputfcolor {
3 dict begin
   /str exch def
   /i exch def
   /solid exch def
   /FC solid solidgetfcolors def
   i FC length lt {
      FC i str put
   } if
end
} def

%% syntaxe : solid solidgetincolors --> array
/solidgetincolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetincolors) ==
      quit
   } if
   solid solidwithinfaces {
      /fcol solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      fcol n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutcolors --> array
/solidgetoutcolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutcolors) ==
      quit
   } if
   /fcol solid solidgetfcolors def
   /IO solid solidgetinouttable def 
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   fcol n1 n getinterval 
end
} def
 
%% syntaxe : solid array solidputincolors --> -
/solidputincolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputincolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreinfaces ne {
      (Error : mauvaise longueur de tableau dans solidputincolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid str outputcolors
/outputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreoutfaces def
   solid [ n {color} repeat ] solidputoutcolors
end
} def

%% syntaxe : solid str inputcolors
/inputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreinfaces def
   solid [ n {color} repeat ] solidputincolors
end
} def

%% syntaxe : solid str1 str2 inoutputcolors
/inoutputcolors {
5 dict begin
   /colout exch def
   /colin exch def
   /solid exch def
   solid colin inputcolors
   solid colout outputcolors
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC length n n1 add lt {
         solid newcolorstable solidputfcolors
      } {
         FC n1 newcolorstable putinterval
      } ifelse
   } if
end
} def

/solidputcolors {
3 dict begin
   2 copy pop
   isstring {
      inoutputcolors
   } {
      outputcolors
   } ifelse
end
} def

%%%%% ### solidputhuecolors ###
%% syntaxe : solid table solidputhuecolors --> -
/solidputhuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 1 get
   s@lidputhuec@l@rs
end
} def

/solidputinhuecolors {
2 dict begin
   /table exch def
   /solid exch def
   solid solidgetinouttable /IO exch def
   solid solidwithinfaces {
      solid table
      IO 2 get
      IO 3 get
      s@lidputhuec@l@rs
   } if
end
} def

/solidputinouthuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 3 get IO 1 get max
   s@lidputhuec@l@rs
end
} def

%% syntaxe : solid table n1 n2 s@lidputhuec@l@rs --> -
%% affecte les couleurs des faces d indice n1 a n2 du solid solid, par
%% un degrade defini par la table.
 /s@lidputhuec@l@rs {
9 dict begin
   /n2 exch def
   /n1 exch def
   /table exch def
   /solid exch def
   /n n2 n1 sub def

   table length 2 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       a1 isstring {
          /lacouleurdepart {
             gsave
                [a0 cvx exec] length 0 eq {
                   a0 cvx exec currentrgbcolor
                } {
                   a0 cvx exec
                } ifelse 
             grestore
          } def
          /lacouleurarrivee {
             gsave
                [a1 cvx exec] length 0 eq {
                   a1 cvx exec currentrgbcolor
                } {
                   a1 cvx exec
                } ifelse 
             grestore
          } def
          /table [lacouleurdepart lacouleurarrivee] def
       } {
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {1} def
          /C {1} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
       } ifelse
   } if

   table length 4 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B table 2 get def
       /C table 3 get def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 6 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (setrgbcolor) def
   } if

   table length 7 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 8 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /d0 table 3 get def
       /a1 table 4 get def
       /b1 table 5 get def
       /c1 table 6 get def
       /d1 table 7 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {d0 i d1 d0 sub mul n 1 sub div add} def
       /espacedecouleurs (setcmykcolor) def
   } if

   n1 1 n2 {
      /i exch def
      solid i
      [A B C D] espacedecouleurs astr2str
      solidputfcolor
   } for
   
end
} def

%%%%% ### solidrmface ###
%% syntaxe : solid i solidrmface -> -
/solidrmface {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidrmface) ==
      quit
   } if
   %% on enleve la face
   /F solid solidgetfaces def
   F length 1 sub i lt {
      (Error : indice trop grand dans solidrmface) ==
      quit
   } if
   [
      0 1 F length 1 sub {
         /j exch def
         i j ne {
            F j get
         } if
      } for
   ]
   /NF exch def
   solid NF solidputfaces
   %% on enleve la couleur correspondante
   /FC solid solidgetfcolors def
   [
      0 1 FC length 1 sub {
         /j exch def
         i j ne {
            FC j get
         } if
      } for
   ]
   /NFC exch def
   solid NFC solidputfcolors
   %% on ajuste la table inout
   /IO solid solidgetinouttable def
   solid i solidisoutface {
      IO 1 IO 1 get 1 sub put 
      solid solidwithinfaces {
         IO 2 IO 2 get 1 sub put
         IO 3 IO 3 get 1 sub put
      } if
   } if
   solid i solidisinface {
      IO 1 IO 1 get 1 sub put
      IO 2 IO 2 get 1 sub put
      IO 3 IO 3 get 1 sub put
   } if
   solid IO solidputinouttable
end
} def

%% syntaxe : solid table solidrmfaces --> -
/solidrmfaces {
2 dict begin
   /table exch bubblesort reverse def
   /solid exch def
   table {solid exch solidrmface} apply
end
} def

%%%%% ### videsolid ###
%% syntaxe : solid videsolid -> -
/videsolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans videsolid) ==
      quit
   } if
   solid solidwithinfaces not {
      /IO solid solidgetinouttable def
      /FE solid solidgetfaces def
      /n FE length def
      IO 2 n put
      IO 3 2 n mul 1 sub put
      solid IO solidputinouttable
      %% on inverse chaque face
      /FI FE {reverse} apply def
      solid FE FI append solidputfaces
      %% et on rajoute autant de couleurs vides que de faces
      /FEC solid solidgetfcolors def
%      /FIC [FI length {()} repeat] def
%      solid FEC FIC append solidputfcolors
      solid FEC duparray append solidputfcolors
   } if 
end
} def

%%%%% ### solidnumfaces ###
%% syntaxe : solid array solidnumfaces
%% syntaxe : solid array bool solidnumfaces
%% array, le tableau des indices des faces a numeroter, est optionnel
%% si bool=true, on ne numerote que les faces visibles
/solidnumfaces {
5 dict begin
   dup isbool {
      /bool exch def
   } {
      /bool true def
   } ifelse
%   setTimes
   dup issolid not {
      %% on a un argument
      /option exch def 
   } if
   /sol exch def
   /n sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if

   0 1 option length 1 sub {
      /i exch def
      /j option i get def
      j (     ) cvs sol j bool cctextp3d
   } for
end
} def

%%%%% ### creusesolid ###
%% syntaxe : solid creusesolid -> -
/creusesolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans creusesolid) ==
      quit
   } if
   %% on enleve le fond et le chapeau
   solid 1 solidrmface
   solid 0 solidrmface
   %% on inverse chaque face
   solid videsolid
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 dessin des solides                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solidisinface ###
%% syntaxe : solid i solidisinface --> bool
%% true si i est l indice d une face interne, false sinon
/solidisinface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 2 get def
   /n2 IO 3 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### solidisoutface ###
%% syntaxe : solid i solidisoutface --> bool
%% true si i est l indice d une face externe, false sinon
/solidisoutface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 0 get def
   /n2 IO 1 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### planvisible ###
%% syntaxe : A k planvisible? --> true si le plan est visible
/planvisible? {
4 dict begin
   /normale_plan defpoint3d
   /origine defpoint3d
   /ligne_de_vue {
      origine
      GetCamPos
      vecteur3d
   } def
   ligne_de_vue normale_plan scalprod3d 0 gt
end
} def

%%%%% ### solidlight ###
/setlightintensity {
   /lightintensity exch def
} def

/setlightsrc {
   /lightsrc defpoint3d
} def

/setlight {
1 dict begin
gsave
   exec
   [ currentrgbcolor ] /lightcolor exch 
grestore
end
def
} def

%%%%% ### drawsolid ###
/solidlightOn {
   /s@lidlight true def
} def
/solidlightOff {
   /s@lidlight false def
} def
solidlightOff

%% syntaxe : solid i solidfacevisible? --> true si la face est visible
/solidfacevisible? {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   solid i solidgetface length 2 le {
      true
   } {
      /ligne_de_vue {
         solid i solidcentreface
         GetCamPos
         vecteur3d
      } def
   
      /normale_face {
         solid i solidnormaleface
      } def
      ligne_de_vue normale_face scalprod3d 0 gt
   } ifelse
end
} def

%% syntaxe : solid i affectecouleursolid_facei --> si la couleur de
%% la face i est definie, affecte fillstyle a cette couleur
/affectecouleursolid_facei {
3 dict begin
   /i exch def
   /solid exch def
   solid solidgetfcolors /FC exch def
   FC length 1 sub i ge {
      FC i get length 1 ge {
         /fillstyle FC i get ( Fill) append cvx
         solidgrid not {
            FC i get cvx exec
         } if
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
{def} if
} def

%% syntaxe : solid i dessinefacecachee
/dessinefacecachee {
11 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacecachee) ==
      quit
   } if

   /F solid solidgetfaces def
   /S solid solidgetsommets def

   %% face cachee => on prend chacune des aretes de la face et on
   %% la dessine
   4 dict begin
      /n F i get length def %% nb de sommets de la face
      0 1 n 1 sub {
         /k exch def
         /k1 F i k get_ij def              %% indice sommet1
         /k2 F i k 1 add n mod get_ij def  %% indice sommet2
         gsave
            currentlinewidth .5 mul setlinewidth
            pointilles
            [S k1 getp3d
            S k2 getp3d sortp3d] ligne3d
         grestore
      } for

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      /face_a_dessiner [  %% face visible : F [i]
         0 1 n 1 sub {
            /j exch def
            solid j i solidgetsommetface
         } for
      ] def 
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
	    solidintersectiontype 0 eq {
	       pointilles
	    } {
	       continu
	    } ifelse
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  table length 6 eq {
                     /lignedeniveau table store
                     exit
                  } {
                     /lignedeniveau [ 
                        lignedeniveau aload pop 
                        table 0 getp3d
                     ] store
                  } ifelse
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               [lignedeniveau aload pop sortp3d] ligne3d
            } if
         grestore
      } for         
   } if
   
   end
end
} def

%% syntaxe : solid i dessinefacevisible
/dessinefacevisible {
8 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacevisible) ==
      quit
   } if
   /F solid solidgetfaces def
   /S solid solidgetsommets def

   /n F i get length def %% nb de sommets de la face

   startest {
      s@lidlight {
         /coeff
            lightintensity
            solid i solidnormaleface normalize3d
            solid i solidcentreface lightsrc vecteur3d normalize3d
            scalprod3d mul
            0 max 1 min
         def
         /lightcolor where {
            pop
            /lacouleur lightcolor def
         } {
            /lacouleur [
               gsave
                  solid solidgetfcolors i get cvx exec currentrgbcolor
               grestore
            ] def
         } ifelse
         /fillstyle {
             lacouleur {coeff mul} apply setcolor Fill
         } def
         solidgrid not {
            lacouleur {coeff mul} apply setcolor
         } if
      } {
         n 2 eq {
            1 dict begin
               solidgridOff
               solid i affectecouleursolid_facei
            end
         } {
            solid i affectecouleursolid_facei
         } ifelse
      } ifelse
   } if

   /face_a_dessiner [  %% face visible : F [i]
      0 1 n 1 sub {
         /j exch def
         solid j i solidgetsommetface
      } for
   ] def 
   face_a_dessiner polygone3d

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  /lignedeniveau [ 
                     lignedeniveau aload pop 
                     table 0 getp3d
                     table length 4 ge {
                        table 1 getp3d
                     } if
                  ] store
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               solid i solidisinface solidintersectiontype 0 eq and {
                  pointilles 
               } if
               lignedeniveau ligne3d
            } if
         grestore
      } for         
   } if
      
end
} def

/drawsolid* {
1 dict begin
   /startest {true} def
   drawsolid
end
} def

/peintrealgorithme false def

/drawsolid** {
2 dict begin
   /aretescachees false def
   /peintrealgorithme true def
   drawsolid*
end
} def

%% syntaxe : solid array drawsolid
%% array est en option, il indique les faces triees
/drawsolid {
8 dict begin
   dup issolid not {
      /ordre exch def
   } if
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans drawsolid) ==
      quit
   } if
   solid nullsolid not {
      solid solidgetfaces
      /F exch def
      solid solidgetsommets
      /S exch def
      /n S length 3 idiv def

      currentdict /ordre known not {
         peintrealgorithme {
            %% tri des indices des faces par distance decroissante
            [
               0 1 F length 1 sub {
                  /i exch def
                  solid i solidcentreface
                  GetCamPos
                  distance3d
               } for
            ] doublequicksort pop reverse
         } {
            [
               0 1 F length 1 sub {
               } for
            ]
         } ifelse
         /ordre exch def
      } if

      0 1 F length 1 sub {
         /k exch def
         /i ordre k get def
         gsave
            solid i solidfacevisible? {
               solid i dessinefacevisible
            } if
         grestore
      } for
      aretescachees {
         0 1 F length 1 sub {
            /k exch def
            /i ordre k get def
            gsave
               solid i solidfacevisible? not {
                  solid i dessinefacecachee
               } if 
            grestore
         } for
      } if

%%       %% si on veut repasser les traits des faces visibles
%%       0 1 F length 1 sub {
%%          /k exch def
%%          /i ordre k get def
%%          gsave
%%          1 dict begin
%%             /startest false def
%%             solid i solidfacevisible? {
%%             solid i dessinefacevisible
%%             } if
%%          end
%%          grestore
%%       } for
   } if
end
} def

%%%%% ### segment_inter_planz ###
%% syntaxe : A B k segment_inter_planz --> array true ou false
/segment_inter_planz {
4 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A /zA exch def pop pop
   B /zB exch def pop pop
   zA k sub zB k sub mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            zA k eq {A} if
            zB k eq {B} if
         ] true
      } {
         %% intersection entre A et B
         [
            A B vecteur3d
            k zA sub zB zA sub div mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  plans affines                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### planaffine ###
%% plan : origine, base, range, ngrid
%% [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1. 1.] ]

/explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.] ] def

%% syntaxe : any isplan --> bool
/isplan {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 6 eq {
         candidat 3 get isarray {
            candidat 4 get isarray {
               candidat 5 get isarray              
            } {
               false
            } ifelse
         } {
            false
         } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/newplanaffine {
   [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1 1]] 
} def

/dupplan {
4 dict begin
   /leplan exch def
   /result newplanaffine def
   result leplan plangetorigine planputorigine
   result leplan plangetbase planputbase
   result leplan plangetrange planputrange
   result leplan plangetngrid planputngrid
   result
end
} def

%% syntaxe : plantype getorigine --> x y z
/plangetorigine {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetorigine) ==
      Error
   } if
   plan 0 get 
   plan 1 get 
   plan 2 get 
end
} def

%% syntaxe : plantype getbase --> [u v]
%% ou u, v et w vecteurs de R^3
/plangetbase {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetbase) ==
      Error
   } if
   plan 3 get 
end
} def

%% syntaxe : plantype getrange --> array
%% ou array = [xmin xmax ymin ymax]
/plangetrange {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetrange) ==
      Error
   } if
   plan 4 get 
end
} def

%% syntaxe : plantype getngrid --> array
%% ou array = [n1 n2]
/plangetngrid {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetngrid) ==
      Error
   } if
   plan 5 get 
end
} def

%% ===================

%% syntaxe : plantype x y z putorigine --> -
/planputorigine {
4 dict begin
   /z exch def
   /y exch def
   /x exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputorigine) ==
      Error
   } if
   plan 0 x put 
   plan 1 y put 
   plan 2 z put 
end
} def

%% syntaxe : plantype [u v w] putbase --> -
%% ou u, v et w vecteurs de R^3
/planputbase {
2 dict begin
   /base exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputbase) ==
      Error
   } if
   plan 3 base put 
end
} def

%% syntaxe : plantype array putrange --> -
%% ou array = [xmin xmax ymin ymax]
/planputrange {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputrange) ==
      Error
   } if
   plan 4 table put 
end
} def

%% syntaxe : plantype array putngrid --> -
%% ou array = [n1 n2]
/planputngrid {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputngrid) ==
      quit
   } if
   plan 5 table put 
end
} def

%% -3 3 -2 2 1. 1. newgrille
%% drawsolid

%orange

%% plan : origine, base, range, ngrid

%% syntaxe : plantype drawplanaffine --> -
/drawplanaffine {
5 dict begin
   /plan exch def
   plan plangetbase 
   aload pop
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   newpath
      plan plangetrange plan plangetngrid aload pop  quadrillagexOy_
      plan plangetorigine [imI imK] false planprojpath
   Stroke
end
} def


%% %% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% %% plan defini par l equation ax+by+cz+d=0, 
%% %% rotation de alpha autour de la normale (alpha est optionnel)
%% %% origine (x0, y0, z0). l origine est optionnelle
%% /defeqplanaffine {
%% 5 dict begin
%%    dup isarray {
%%       /alpha 0 def
%%    } {
%%       dup isstring {
%%          /alpha 0 def
%%       } {
%%          /alpha exch def
%%       } ifelse
%%    } ifelse
%%    dup isstring {
%%       cvx /origine exch def
%%    } if
%%    /table exch def
%%    table length 4 ne {
%%       (Erreur : mauvais type d argument dans defeqplanaffine) ==
%%       Error
%%    } if
%%    table 0 get /a exch def
%%    table 1 get /b exch def
%%    table 2 get /c exch def
%%    table 3 get /d exch def
%%    /resultat newplanaffine def
%%    [a b c alpha] normalvect_to_orthobase
%%    /imK defpoint3d
%%    /imJ defpoint3d
%%    /imI defpoint3d
%%    resultat [imI imJ imK] planputbase
%%    currentdict /origine known {
%%       origine /z exch def /y exch def /x exch def
%%       a x mul b y mul add c z mul add d add 0 ne {
%%          (Erreur : mauvaise origine dans defeqplanaffine) ==
%%          Error
%%       } if
%%       resultat origine planputorigine
%%    } {
%%       c 0 ne {
%%          resultat 0 0 d neg c div planputorigine
%%       } {
%%          a 0 ne {
%%             resultat d neg a div 0 0 planputorigine
%%          } {
%%             resultat 0 d neg b div 0 planputorigine
%%          } ifelse
%%       } ifelse
%%    } ifelse
%%    resultat
%% end
%% } def

%% /explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 1] ] def
%% explan drawplanaffine
%% noir
%% /explan [0 0 2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 .5] ] def
%% explan drawplanaffine

%% orange
%% [0 0 1 -2] defeqplanaffine
%% drawplanaffine
%% noir
%% [0 0 1 0] defeqplanaffine
%% drawplanaffine
%% bleu
%% [1 1 1 0] (1 -1 0) defeqplanaffine
%% drawplanaffine
%% 

/dessinebase {
4 dict begin
gsave
   /V3 defpoint3d
   /V2 defpoint3d
   /V1 defpoint3d
   /M0 defpoint3d
   rouge
   V3 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   bleu
   V2 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   orange
   V1 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
grestore
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def


%% syntaxe : plantype newplan --> solid
/newplan {
5 dict begin
   /lepl@n exch def
   lepl@n plangetbase /@base exch def
   @base 0 getp3d /@U defpoint3d
   @base 1 getp3d /@V defpoint3d
   lepl@n plangetorigine /@M defpoint3d
   lepl@n plangetrange /@range exch def
   lepl@n plangetngrid /@ngrid exch def
   /@F {
   2 dict begin
      /@y exch def
      /@x exch def
      @U @x mulv3d
      @V @y mulv3d
      addv3d
      @M addv3d
   end
   } def
   @range aload pop @ngrid {@F} newsurfaceparametree
end
} def

%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /eqplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a eqplan 0 get def
   /@b eqplan 1 get def
   /@c eqplan 2 get def
   /@d eqplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add
end
} def

/plan2eq {
6 dict begin
   /leplan exch def
   leplan plangetbase aload pop vectprod3d
   /c exch def
   /b exch def
   /a exch def
   leplan plangetorigine
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg]
end
} def

%% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% plan defini par l equation ax+by+cz+d=0, 
%% rotation de alpha autour de la normale (alpha est optionnel)
%% origine (x0, y0, z0). l origine est optionnelle
/eq2plan {
5 dict begin
   dup isarray {
      /alpha 0 def
   } {
      dup isstring {
         /alpha 0 def
      } {
         /alpha exch def
      } ifelse
   } ifelse
   dup isstring {
      cvx /origine exch def
   } if
   /table exch def
   table length 4 ne {
      (Erreur : mauvais type d argument dans eq2plan) ==
      quit
   } if
   table 0 get /a exch def
   table 1 get /b exch def
   table 2 get /c exch def
   table 3 get /d exch def
   /resultat newplanaffine def
   [a b c alpha] normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   resultat [imI imJ] planputbase
   currentdict /origine known {
      origine /z exch def /y exch def /x exch def
      a x mul b y mul add c z mul add d add 0 ne {
         (Erreur : mauvaise origine dans eq2plan) ==
         quit
      } if
      resultat origine planputorigine
   } {
      c 0 ne {
         resultat 0 0 d neg c div planputorigine
      } {
         a 0 ne {
            resultat d neg a div 0 0 planputorigine
         } {
            b 0 ne {
               resultat 0 d neg b div 0 planputorigine
            } {
               (Error dans eq2plan : (a,b,c) = (0,0,0)) ==
            } ifelse
         } ifelse
      } ifelse
   } ifelse
   resultat
end
} def

/points2eqplan {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   A C vecteur3d
   vectprod3d
   normalize3d
   /c exch def
   /b exch def
   /a exch def
   A
   /zA exch def
   /yA exch def
   /xA exch def
   [a b c a xA mul b yA mul add c zA mul add neg]
end
} def

%% /monplan 
%% %[0 0 -2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.]]
%% [0 0 1 1] 30 eq2plan
%% def
%% 
%% [0 0 1 -2] eq2plan newplan
%% dup (blanc) outputcolors
%% monplan newplan
%% dup (blanc) outputcolors
%% solidfuz
%% drawsolid**
%% monplan plangetorigine
%% monplan plangetbase aload pop dessinebase

%% syntaxe : x0 y0 z0 [normalvect] norm2plan
/norm2plan {
9 dict begin
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   imK
   /c exch def
   /b exch def
   /a exch def
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg] eq2plan
   dup x0 y0 z0 planputorigine
   dup [imI imJ] planputbase
end
} def

%% syntaxe : plantype planxmarks
/planxmarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      xmin truncate cvi 0 smoveto
      xmax truncate cvi 0 slineto
      leplan mybool projpath
   Stroke
   xmin truncate cvi xmkstep xmax truncate cvi {
      dup 0 ne {
         /x exch def
         x
         x x truncate eq {
            cvi
         } if
         dup chaine cvs exch 0 leplan mybool dctextp3d
         newpath
            x 0 smoveto
            0 2.5 rmoveto
            0 -5 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planymarks
/planymarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      0 ymin truncate cvi smoveto
      0 ymax truncate cvi slineto
      leplan mybool projpath
   Stroke
   ymin truncate cvi ymkstep ymax truncate cvi {
      dup 0 ne {
         /y exch def
         y
         y y truncate eq {
             cvi
         } if
         dup chaine cvs exch 0 exch leplan mybool cltextp3d
         newpath
            0 y smoveto
            2.5 0 rmoveto
            -5 0 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planmarks
/planmarks {
1 dict begin
    dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup mybool planxmarks mybool planymarks
end
} def

%% bleu
%% [-3 3 -2 2] quadrillagexOy_
%% Stroke
%% noir

%% syntaxe : [xmin xmax ymin ymax] dx dy quadrillagexOy_
/quadrillagexOy_ {
4 dict begin
   dup isarray {
      /dx 1 def
      /dy 1 def
   } {
      /dy exch def
      dup isarray {
         /dx dy def
      } {
         /dx exch def
      } ifelse
   } ifelse
   /table exch def
   table 0 get /xmin exch def
   table 1 get /xmax exch def
   table 2 get /ymin exch def
   table 3 get /ymax exch def
   ymin dy ymax {
      /y exch def
      xmin y smoveto
      xmax y slineto
   } for
   xmin dx xmax {
      /x exch def
      x ymin smoveto
      x ymax slineto
   } for
end
} def

%% syntaxe : plan [ngrid] planquadrillage
/planquadrillage {
4 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /ngrid [1 1] def
   } {
      /ngrid exch def
   } ifelse
   /leplan exch def
   /dx ngrid 0 get def
   /dy ngrid 1 get def
   /table leplan plangetrange def
   table 0 get cvi truncate /xmin exch def
   table 1 get cvi truncate /xmax exch def
   table 2 get cvi truncate /ymin exch def
   table 3 get cvi truncate /ymax exch def
   newpath
      ymin dy ymax {
         /y exch def
         xmin y smoveto
         xmax y slineto
      } for
      xmin dx xmax {
         /x exch def
         x ymin smoveto
         x ymax slineto
      } for
      leplan mybool projpath
   Stroke
end
} def

%% syntaxe : plantype str1 str2 planshowbase -> - 
%% syntaxe : plantype str2 planshowbase -> - 
%% syntaxe : plantype planshowbase -> - 
/planshowbase {
3 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isstring {
      /couleur2 exch def
      dup isstring {
         /couleur1 exch def
      } {
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
   } ifelse
   mybool bprojscene
      couleur1 cvx exec
      newpath
         0 0 smoveto
         1 0 slineto
      Stroke
      0 0 1 0 oldarrow
      couleur2 cvx exec
      newpath
         0 0 smoveto
         0 1 slineto
      Stroke
      0 0 0 1 oldarrow
   eprojscene
end
} def

%% syntaxe : plantype str1 str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str3 planshowbase3d -> - 
%% syntaxe : plantype planshowbase3d -> - 
%% syntaxe : plantype str1 str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str3 array planshowbase3d -> - 
%% syntaxe : plantype array planshowbase3d -> - 
/planshowbase3d {
7 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup dup isarray exch isplan not and {
      /table exch def
   } {
      /table {} def
   } ifelse
   dup isstring {
      /couleur3 exch def
      dup isstring {
         /couleur2 exch def
         dup isstring {
            /couleur1 exch def
         } {
            /couleur1 (rouge) def
         } ifelse
      } {
         /couleur2 (vert) def
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
      /couleur3 (bleu) def
   } ifelse
   /plan exch def
   plan couleur1 couleur2 mybool planshowbase
   plan plangetorigine /I defpoint3d
   plan plangetbase
   dup 0 getp3d /u defpoint3d
   1 getp3d /v defpoint3d
   u v vectprod3d table newvecteur
   {I addv3d} solidtransform
   dup couleur3 solidputcolors
   solidgridOff
   drawsolid**
end
} def

%% syntaxe : plantype x y z plantranslate --> -
/plantranslate {
4 dict begin
   /M defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plantranslate) ==
      quit
   } if
   plan plan plangetorigine M addv3d planputorigine
end
} def

% syntaxe : alpha_x alpha_y alpha_z rotateOpplan --> -
/rotateOplan {
4 dict begin
   /Rxyz defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans rotateOplan) ==
      quit
   } if
   plan plan plangetorigine Rxyz rotateOpoint3d planputorigine

   plan plangetbase 0 getp3d /U defpoint3d
   plan plangetbase 1 getp3d /V defpoint3d
   plan [
      U Rxyz rotateOpoint3d
      V Rxyz rotateOpoint3d
   ] planputbase
end
} def

%% syntaxe : plantype phi rotateplan --> -
/rotateplan {
5 dict begin
   /phi exch def
   /leplan exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U phi cos mulv3d
   V phi sin mulv3d addv3d /U0 defpoint3d
   U phi sin neg mulv3d
   V phi cos mulv3d addv3d /V0 defpoint3d
   leplan [U0 V0] planputbase
end
} def

%% syntaxe : solid i solidface2plan --> plantype
%% syntaxe : solid i I solidface2plan --> plantype
/solidface2plan {
5 dict begin
   2 copy pop issolid {
      /i exch def
      /solid exch def
      solid i solidcentreface /I defpoint3d
   } {
      /I defpoint3d
      /i exch def
      /solid exch def
   } ifelse
   /result newplanaffine def
   solid i solidcentreface /G defpoint3d
   solid i solidnormaleface /K defpoint3d
   solid 0 i solidgetsommetface
   solid 1 i solidgetsommetface
   milieu3d /A defpoint3d
   G A vecteur3d normalize3d /U defpoint3d
   K U vectprod3d /V defpoint3d
   result [U V] planputbase
   result I planputorigine
   result
end
} def

%%%%% ### fin insertion ###
%% syntaxe : x y plantype pointplan --> X Y Z
/pointplan {
5 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U x mulv3d V y mulv3d addv3d
end
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     operations sur des solides particuliers        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/piedist {
4 dict begin
   /mypie exch def
   mypie 0 solidgetface length /n exch def
   mypie n 2 idiv solidgetsommet /A defpoint3d
   mypie n 2 idiv 1 add solidgetsommet /B defpoint3d
   A B milieu3d GetCamPos distance3d
end
} def

/sortpieset {
5 dict begin
   dup issolid {
      ]
   } if
   /table exch def
   [
      0 1 table length 1 sub {
         /i exch def
         table i get piedist
      } for
   ]
   doublequicksort pop reverse
   /result exch def
   [
      0 1 result length 1 sub {
         /i exch def
         table result i get get 
      } for
   ]
end
} def

/drawpieset {
1 dict begin
   /startest true def
   sortpieset dup {drawsolid**} apply {0 dessinefacevisible} apply
end
} def

%%%%% ### solidchanfreine ###
%% syntaxe : solid coeff solidchanfreine --> solid
/solidchanfreine {
10 dict begin
   /coeff exch def
   /solid exch def
   /result newsolid def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidchanfreine) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def

   %% ajout des faces reduites
   0 1 nf 1 sub {
      /i exch def
      /Fsommets solid i solidgetsommetsface def
      /Findex solid i solidgetface def
      /ns Fsommets length 3 idiv def
      /couleurfaceorigine solid i solidgetfcolor def
      Fsommets isobarycentre3d /G defpoint3d
      %% on ajoute les nouveaux sommets
      /Sindex [] def
      0 1 ns 1 sub {
         /j exch def
         /Sindex [ Sindex aload pop
            Fsommets j getp3d /M defpoint3d
            result M G coeff hompoint3d solidaddsommet
         ] store
      } for
      %% Sindex contient les indices des nouveaux sommets
      result Sindex couleurfaceorigine solidaddface
   } for

   %% ajout des faces rectangulaires entre faces d'origines adjacentes
   %% pour chaque face de depart
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      /Fres result i solidgetface def
      %% pour chaque arete de la face
      0 1 F length 1 sub {
         /j exch def
         /trouve false def
         /indice1 F j get def
         /indice2 F j 1 add F length mod get def
         /a1 j def
         /a2 j 1  add F length mod def
         %% on regarde toutes les autres faces
         i 1 add 1 nf 1 sub {
            /k exch def
            /Ftest solid k solidgetface def
            indice1 Ftest in {pop true} {false} ifelse
            indice2 Ftest in {pop true} {false} ifelse
            and {
               /indiceFadj k def
               indice1 Ftest in pop /k1 exch def
               indice2 Ftest in pop /k2 exch def
               /trouve true def
            exit
            } if
         } for
         trouve {
            /Fadj solid indiceFadj solidgetface def
            result [
               Fres a1 get
               result indiceFadj solidgetface k1 get
               result indiceFadj solidgetface k2 get
               Fres a2 get
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   %% pour chaque face
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      %% et pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /k F j get def
         solid k solidfacesadjsommet /adj exch def
         %% adj est le tableau des indices des faces adjacentes
         %% au sommet d'indice k
         %% rque : toutes les faces d'indice strict inferieur a i
         %% sont deja traitees
         %% Pour chaque face adjacente, on repere l'indice du sommet concerne dans
         %% la face
         adj min i lt not {
            /indadj [] def
            0 1 adj length 1 sub {
               /m exch def
               k solid adj m get solidgetface in {
                  /ok exch def
                  /indadj [indadj aload pop ok] store
               } if
            } for
         
            /aajouter [
               0 1 adj length 1 sub {
                  /m exch def
                  result adj m get solidgetface indadj m get get
               } for
            ] def

            %% la table des sommets
            [0 1 aajouter length 1 sub {
               /m exch def
               result aajouter m get solidgetsommet
            } for]
            solid k solidgetsommet %% le point indiquant la direction de la normale
            ordonnepoints3d
            /indicestries exch def

            result [
               0 1 indicestries length 1 sub {
                  /m exch def
                  aajouter indicestries m get get
               } for
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   result
end
} def

%%%%% ### solidplansection ###
%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /@qplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a @qplan 0 get def
   /@b @qplan 1 get def
   /@c @qplan 2 get def
   /@d @qplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add 
end
} def

%% syntaxe : A B eqplan segment_inter_plan --> array true ou false
%% array contient 1 point M si [AB] inter plan = {M}
%% array contient les 2 points A et B si [AB] inter plan = [AB]
/segment_inter_plan {
4 dict begin
   dup isplan {plan2eq} if
   /plan exch def
   plan aload pop
   /d exch def
   /c exch def
   /b exch def
   /a exch def
   /B defpoint3d
   /A defpoint3d
   A 
   /zA exch def
   /yA exch def
   /xA exch def
   B 
   /zB exch def
   /yB exch def
   /xB exch def
   /imA a xA mul b yA mul add c zA mul add d add def
   /imB a xB mul b yB mul add c zB mul add d add def
   imA imB mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            imA 0 eq {A} if 
            imB 0 eq {B} if 
         ] true
      } {
         %% intersection entre A et B
         /k 
            imA neg
            xB xA sub a mul
            yB yA sub b mul add
            zB zA sub c mul add
            dup 0 eq {
               (Error dans segment_inter_plan) ==
               quit
            } if
            div
         def
         [
            A B vecteur3d
            k mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def

%% syntaxe : array1 arrayrmdouble --> array2
%% remplace 2 elts identiques consecutifs par 1 elt
/arrayrmdouble {
5 dict begin
   /table exch def
   /result [table 0 get] def
   /j 0 def
   1 1 table length 1 sub {
      /i exch def
      table i get
      result j get
      eq not {
         /result [result aload pop table i get] store
         /j j 1 add store
      } if
   } for
   result
end
} def

%% syntaxe : solid eqplan/plantype solidplansection --> solid2
/solidplansection {
10 dict begin
   dup isbool {
      /tr@nsmit exch def
   } {
      /tr@nsmit false def
   } ifelse
   dup isplan {
      plan2eqplan
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   dupsolid /result exch def
   /solid exch def
   /aenlever [] def
   /indnouveauxsommets [] def
   /nouvellesaretes [] def

   %% pour chaque face d'indice i
   0 1 solid solidnombrefaces 1 sub {
      /i exch def
      /lacouleur solid i solidgetfcolor def
      /F solid i solidgetface def %% table des indices des sommets
      /n F length def %% nb d'aretes
      /k1 -1 def
      /k2 -1 def
      /k3 -1 def
      /k4 -1 def
      /k3a -3 def
      /k4a -3 def
      %% pour chaque arete [AB]
      0 1 n 1 sub {
         /j exch def
         %% arete testee : [j, j+1 mod n] (indices relatifs a la face i)
         solid j i solidgetsommetface /A defpoint3d
         solid j 1 add n mod i solidgetsommetface /B defpoint3d
         %% y a-t-il intersection
         A B eqplan segment_inter_plan {
            %% il y a intersection
            dup length 6 eq {
               %% l'intersection, c'est [AB]
               /k1 -1 def
               /k2 -1 def
               /k3 -1 def
               /k4 -1 def
               /k3a -1 def
               /k4a -1 def
               dup 0 getp3d /A defpoint3d
               1 getp3d /B defpoint3d
               result A solidaddsommet /a1 exch def
               result B solidaddsommet /a2 exch def
               /indnouveauxsommets [
                  indnouveauxsommets aload pop a1 a2
               ] store
               /nouvellesaretes [
                  [a1 a2]
                  nouvellesaretes aload pop
               ] store
               exit %% c est deja scinde
            } if
            %% il y a intersection <> [AB]
            k1 0 lt {
            %% 1ere intersection de la face
               /k1 j def %% sommet precedent intersection 1
               result exch aload pop solidaddsommet
               /k1a exch def %% sommet intersection 1
            } {
               k2 0 lt {
               %% 2eme intersection de la face
                  /k2 j def %% sommet precedent intersection 2
                  result exch aload pop solidaddsommet
                  /k2a exch def %% sommet intersection 2
               } {
                  k3 0 lt {
                  %% 3eme intersection de la face
                     /k3 j def %% sommet precedent intersection 3
                     result exch aload pop solidaddsommet
                     /k3a exch def %% sommet intersection 3
                  } {
                  %% 4eme intersection de la face
                     /k4 j def %% sommet precedent intersection 4
                     result exch aload pop solidaddsommet
                     /k4a exch def %% sommet intersection 4
                  } ifelse
               } ifelse
            } ifelse
         } if
      } for
      
      %% y a-t-il eu une coupe ?
      %% si oui, il faut scinder la face d'indice i en cours 
      k1 0 ge {
%% (coupe) ==
%% (n) == n ==
%% k1 == k2 == k3 == k4 ==
%% (a) ==
%% k1a == k2a == k3a == k4a ==
         k1a k2a eq k3 0 lt and {
            %% 1 pt d'intersection
         } {
            %% il y a coupe, on cherche a eliminer les
            %% doublons dans {k1a, k2a, k3a, k4a}
            k1a k2a eq k3 0 ge and {
               %% 2 pts d'intersection
               /k2a k3a def
               /k2 k3 def
            } if
            k1a k3a eq k4 0 ge and {
               %% 2 pts d'intersection
               /k2a k4a def
               /k2 k4 def
            } if
            /nouvellesaretes [
               [k1a k2a]
               nouvellesaretes aload pop
            ] store
            [
               k1a F k1 1 add n mod get ne {
                  k1a
               } if
               k1 1 add n mod 1 k2 {F exch get} for
               k2a F k2 get ne {
                  k2a
               } if
            ]
            result exch lacouleur solidaddface
            /indnouveauxsommets [indnouveauxsommets aload pop k1a k2a] store
            [
               k2a F k2 1 add n mod get ne {
                  k2a
               } if
               k2 1 add n ne {
                  k2 1 add n mod 1 n 1 sub {F exch get} for
               } if
               0 1 k1 {F exch get} for
               k1a F k1 get ne {
                  k1a
               } if
            ]
            result exch lacouleur solidaddface
            /aenlever [aenlever aload pop i] store
         } ifelse
      } if
   } for
   result aenlever solidrmfaces

   nouvellesaretes separe_composantes
   /composantes exch def

   %% pour chacune des composantes
   0 1 composantes length 1 sub {
      %% on oriente et on ajoute la face
      /icomp exch def
      %indnouveauxsommets bubblesort arrayrmdouble
      /indnouveauxsommets composantes icomp get def
      %% maintenant, on ajoute la face de plan de coupe
      /nouveauxsommets [
         0 1 indnouveauxsommets length 1 sub {
            /i exch def
            result indnouveauxsommets i get solidgetsommet
         } for
      ] def
   
      0 0 0 eqplan pointeqplan 0 eq {
         /ptref {0 1 1} def
      } {
         /ptref {0 0 0} def
      } ifelse
   
      %% restera a traiter le cas limite ou la nouvelle face existe deja
      %% tester si max(indicestries) < nb sommets avant section
      nouveauxsommets ptref ordonnepoints3d
      /indicestries exch def
      /nvelleface [
         0 1 indicestries length 1 sub {
            /m exch def
            indnouveauxsommets indicestries m get get
         } for
      ] def
      /F result solidgetfaces def
      /FC result solidgetfcolors def
      /IO result solidgetinouttable def
      /n1 IO 1 get def
      IO 1 n1 1 add put
      result IO solidputinouttable
      result [nvelleface F aload pop] solidputfaces
      result [lacouleur FC aload pop] solidputfcolors
   } for
   result
   tr@nsmit {
      composantes length 
   } if
end    
} def

%% syntaxe : elt array compteoccurences
%% ou array est un tableau du type [ [a1 a2] [b1 b2] [c1 c2] ... ]
/compteoccurences {
5 dict begin
   /table exch def
   /elt exch def
   /n 0 def
   0 1 table length 1 sub {
      /i exch def
      elt table i get in {
         pop
         /n n 1 add store
      } if
   } for
   n
end
} def

/separe_composantes {
10 dict begin
   /result [] def %% les composantes deja faites
   /table exch def %% ce qui reste a faire

%   (recu) == table {==} apply
   {
      /ext1 table 0 get 1 get def
      /ext0 table 0 get 0 get def
      /composante [] def
   
      { %% maintenant on suit les extremites et on epluche une composante
         /change false def
         /aenlever [] def
         0 1 table length 1 sub {
            /i exch def
            ext1 table i get In
            ext0 table i get In or {
               /aenlever [aenlever aload pop i] store
               /change true store
               %% l'arete i contient l'extremite ext0 ou ext1
               ext0 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext0 exch store
                  ext0 composante In not {
                     /composante [composante aload pop ext0] store
                  } if
                  %% on verifie que ext0 est legitime
                  ext0 table compteoccurences 2 gt {
                     /ext0 -1 store
                  } if
               } if
               ext1 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext1 exch store
                  ext1 composante In not {
                     /composante [composante aload pop ext1] store
                  } if
                  %% on verifie que ext1 est legitime
                  ext1 table compteoccurences 2 gt {
                     /ext1 -1 store
                  } if
               } if
            } if
         } for
         %% il faut reconstruire table
         /table [
            0 1 table length 1 sub {
               /i exch def
               i aenlever in {
                  pop
               } {
                  table i get
               } ifelse
            } for
         ] store
         change not {exit} if
      } loop
      %% on vient de finir une composante
      /result [result aload pop composante] store
      %% (nouvelle comp) == composante {==} apply
      table length 0 eq {exit} if
   } loop
   result
%   (renvoie) == result {==} apply
end
} def

/solideqplansepare {solidplansepare} def
    
%% syntaxe : solid eqplan/plantype solidplansepare --> solid1 solid2
/solidplansepare {
10 dict begin
   dup isplan {
      plan2eq
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   eqplan true solidplansection
   /nbcomposantes exch def
   /solid exch def
   /n solid solidnombrefaces def

   /F [] def
   /FC [] def
   %% on retire les faces de coupe
   0 1 nbcomposantes 1 sub {
      /i exch def
      /F [F aload pop solid i solidgetface] store
      /FC [FC aload pop solid i solidgetfcolor] store
   } for
   solid [0 1 nbcomposantes 1 sub {} for] solidrmfaces
   /n n nbcomposantes sub store

   %% on separe les autres faces en 2 parties
   /lesneg [] def %% indices des faces "positives"
   /lespos [] def %% indices des faces negatives"
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /G defpoint3d
      G eqplan pointeqplan dup 0 gt {
         pop
         /lespos [lespos aload pop i] store
      } {
         0 lt {
            /lesneg [lesneg aload pop i] store
         } {
%           /lesneg [lesneg aload pop i] store
%           /lespos [lespos aload pop i] store
         } ifelse
      } ifelse
   } for
   solid
   dupsolid dup lesneg solidrmfaces
   /result1 exch def
   dupsolid dup lespos solidrmfaces
   /result2 exch def
   pop

   0 1 nbcomposantes 1 sub {
      /i exch def
      /facecoupe F i get def
      /couleurfacecoupe FC i get def
      /lesfaces1 result1 solidgetfaces def
      /lescouleurs1 result1 solidgetfcolors def
      /IO1 result1 solidgetinouttable def
      /lesfaces2 result2 solidgetfaces def
      /lescouleurs2 result2 solidgetfcolors def
      /IO2 result2 solidgetinouttable def
      %% on rajoute maintenant la face du plan de coupe
%      result1 facecoupe couleurfacecoupe solidaddface
      result1 [facecoupe lesfaces1 aload pop] solidputfaces
      result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
      result1 IO1 dup dup 1 get 1 add 1 exch put solidputinouttable
      %% et on verifie l'orientation
%      result1 dup solidnombrefaces 1 sub solidnormaleface 
%      result1 dup solidnombrefaces 1 sub solidcentreface addv3d
      result1 0 solidnormaleface 
      result1 0 solidcentreface addv3d
      eqplan pointeqplan 0 gt {
         %% l'orientation est mauvaise
         result1 0 solidrmface 
         result2 [facecoupe lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result1 [facecoupe reverse lesfaces1 aload pop] solidputfaces
         result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
         result1 dup solidgetinouttable dup dup 1 get 1 add 1 exch put solidputinouttable
      } {
         %% l'orientation est ok
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result2 [facecoupe reverse lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
      } ifelse
   } for
   
   %% maintenant on enleve les sommets isoles
   /sommetspos [] def
   /sommetsneg [] def
   %% pour chaque face du cote negatif
   0 1 lesneg length 1 sub {
      lesneg exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetsneg in not {
            %% et s'il est isole, on peut l'enlever
            result1 sommet solidsommetsadjsommet length 0 eq {
               /sommetsneg [sommetsneg aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetsneg bubblesort reverse {result1 exch solidrmsommet} apply

   %% pour chaque face du cote positif
   0 1 lespos length 1 sub {
      lespos exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetspos in not {
            %% et s'il est isole, on peut l'enlever
            result2 sommet solidsommetsadjsommet length 0 eq {
               /sommetspos [sommetspos aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetspos bubblesort reverse {result2 exch solidrmsommet} apply

   result1 result2
end
} def

%%%%% ### solidaffine ###
%% syntaxe : solid coeff i solidaffine -> -
%% syntaxe : solid coeff array solidaffine -> -
%% syntaxe : solid coeff solidaffine -> -
%% syntaxe : solid coeff str solidaffine -> -
%% syntaxe : solid coeff bool solidaffine -> -
/solidaffine {
10 dict begin
   dup isbool {
      /rmfacecentrale exch def
   } {
      /rmfacecentrale true def
   } ifelse
   dup isstring {
      /couleurface exch def
   } if
   2 copy pop issolid {
      %% 2 arguments --> on affine tout
      2 copy pop solidnombrefaces /n exch def
      /table [n 1 sub -1 0 {} for] def 
   } {
      %% 1 tableau --> il donne les faces a enlever
      dup isarray {
         /table exch bubblesort reverse def
      } {
      %% 1 seule face a enlever
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /coeff exch def
   /solid exch def
   0 1 table length 1 sub {
      /i exch def
      solid coeff table i get 
      currentdict /couleurface known {
         couleurface 
      } if
      rmfacecentrale s@lidaffineface
   } for
end
} def

%% syntaxe : solid coeff i s@lidaffineface
 /s@lidaffineface {
10 dict begin
   /rmfacecentrale exch def
   dup isstring {
      /couleurface exch def
   } if
   /indice_a_chamfreiner exch def
   /i indice_a_chamfreiner def
   /coeff exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans affine) ==
      quit
   } if
   /n solid solidnombresommets def
   /F solid i solidgetsommetsface def
   /Findex solid i solidgetface def
   /ni F length 3 idiv def
   /couleurfaceorigine solid i solidgetfcolor def
   F isobarycentre3d /G defpoint3d
   %% on ajoute les nouveaux sommets
   /Sindex [] def
   0 1 ni 1 sub {
      /j exch def
      /Sindex [ Sindex aload pop
         solid G F j getp3d vecteur3d coeff mulv3d G addv3d solidaddsommet
      ] store
   } for
   %% Sindex contient les indices des nouveaux sommets
   %% on prepare les faces a ajouter
   /facestoadd [] def
   /facestoadd [facestoadd aload pop
   0 1 ni 1 sub {
      /j exch def
      [Findex j get
      Findex j 1 add ni mod get
      Sindex j 1 add ni mod get
      Sindex j get]
   } for
   ] store
   0 1 ni 1 sub {
      /i exch def
      solid facestoadd i get solidaddface
   } for
   %% on enleve la face d origine
   solid indice_a_chamfreiner solidrmface
   %% on ajuste les couleurs des nouvelles faces
   /N solid solidnombrefaces def
   0 1 ni 1 sub {
      /i exch def
      solid N 1 sub i sub couleurfaceorigine solidputfcolor
   } for
   %% puis on ajoute eventuellement la face centrale
   rmfacecentrale not {
      solid
      [0 1 ni 1 sub {
         /j exch def
         Sindex j get
      } for]
      solidaddface
      %% en ajustant la couleur de cette derniere
      solid N
      currentdict /couleurface known {
            couleurface 
      } {
         couleurfaceorigine
      } ifelse
      solidputfcolor
   } if
end
} def

%%%%% ### solidtronque ###
%% syntaxe : solid indicesommet k solidtronque --> solid
%% syntaxe : solid array k solidtronque --> solid
%% syntaxe : solid k solidtronque --> solid
%% k entier > 0, array = tableau des indices des sommets
/solidtronque {
10 dict begin
   /coeff exch def
   dup issolid {
      dup solidnombresommets /N exch def
      /table [0 1 N 1 sub {} for] def
   } {
      dup isarray {
         /table exch def
      } {
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   0 1 table length 1 sub {
      table exch get /no exch def
      result no solidgetsommet /sommetvise defpoint3d
      %% on recup les sommets adjacents au sommet vise
      /sommetsadj solid no solidsommetsadjsommet def
      %% on calcule les nouveaux sommets
      /nouveauxsommets [
         0 1 sommetsadj length 1 sub {
            /i exch def
            solid sommetsadj i get solidgetsommet
         } for
      ] {sommetvise exchp3d coeff ABpoint3d} papply3d def 
      %% on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G result no solidgetsommet vecteur3d /vecteurnormal defpoint3d
      %% on construit le tableau des angles ordonnes par rapport
      %% a la normale
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      %% on rajoute les sommets au solide, et on note les nouveaux indices
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% on ajoute la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      result no solidfacesadjsommet /lesfaces exch def
      %% on examine la face d indice i, et on elimine le
      %% sommet vise
      0 1 lesfaces length 1 sub {
         /i exch def
         /j lesfaces i get def
         /F result j solidgetface def 
         result [
            0 1 F length 1 sub {
               /k exch def 
               F k get dup no eq {pop} if
            } for
         ] j exch solidputface 
      } for
   } for
   table bubblesort reverse {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### dualpolyedre ###
%% syntaxe : solid dualpolyedreregulier --> solid
%% syntaxe : solid r dualpolyedreregulier --> solid
%% si le nombre r est present, projette les nouveaux sommets sur la sphere de centre O , de rayon r
/dualpolyedreregulier {
20 dict begin
   dup isnum {
      /r exch def
      /projection true def
   } {
      /projection false def
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   /N solid solidnombresommets def
   /facesaenlever [] def
   %% pour chacun des sommets
   0 1 N 1 sub {
      %% sommet d indice i
      /i exch def
      %% indicesfacesadj = liste des indices des faces ou on trouve le sommet i
      /indicesfacesadj solid i solidfacesadjsommet def
      %% on recupere les centres des faces concernees
      /nouveauxsommets [
         0 1 indicesfacesadj length 1 sub {
            /k exch def 
            solid indicesfacesadj k get solidgetsommetsface isobarycentre3d
         } for
      ] def
      %% et on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G solid i solidgetsommet vecteur3d /vecteurnormal defpoint3d
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      projection {
         %% on projette les sommets sur la sphere
         /nouveauxsommets [ nouveauxsommets {normalize3d r mulv3d} papply3d aload pop ] store
      } if
      %% puis on les rajoute au solide
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% ainsi que la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      /facesaenlever [ facesaenlever aload pop indicesfacesadj aload pop ] store
   } for
   result [0 1 n 1 sub {} for] solidrmfaces
   [N 1 sub -1 0 {} for] {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### newgeode ###
%% syntaxe : solid r newgeode --> solid
%% syntaxe : N r newgeode --> solid
%% N in {3,4,5} -> polyhedre de depart, r = niveau de recursion
/newgeode {
2 dict begin
   /r exch def
   dup issolid not {
      /N exch def
      N 3 eq {
         1 newtetraedre
      } {
         N 4 eq {
            1 newoctaedre
         } {
            1 newicosaedre
         } ifelse
      } ifelse
   } if

   r {
      15 dict begin   
         /solid exch def
         solid dupsolid /result exch def pop
         /n solid solidnombrefaces def
         n 1 sub -1 0 {
            /i exch def
            %% la face d indice i
            solid i solidgetface /F exch def
            /i0 F 0 get def
            /i1 F 1 get def
            /i2 F 2 get def
            solid i0 solidgetsommet /A0 defpoint3d
            solid i1 solidgetsommet /A1 defpoint3d
            solid i2 solidgetsommet /A2 defpoint3d
            A0 A1 milieu3d normalize3d /A01 defpoint3d
            A1 A2 milieu3d normalize3d /A12 defpoint3d
            A2 A0 milieu3d normalize3d /A20 defpoint3d
            result A01 solidaddsommet /i01 exch def
            result A12 solidaddsommet /i12 exch def
            result A20 solidaddsommet /i20 exch def
            result i solidrmface
            result [i0 i01 i20] solidaddface
            result [i01 i1 i12] solidaddface
            result [i01 i12 i20] solidaddface
            result [i20 i12 i2] solidaddface
         } for
         result
      end
   } repeat
end
} def

%% syntaxe : N r newdualgeode --> solid
/newdualgeode {
   newgeode 1
   dualpolyedreregulier
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             quelques solides precalcules           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### newface ### 
%% syntaxe : array newmonoface -> solid
%% ou array = tableau de points 2d
/newmonoface {
4 dict begin
   /table exch def
   /n table length 2 idiv def
   /S table {0} papply def

   /F [
       [0 1 n 1 sub {} for]
   ] def
   S F generesolid
end
} def

%% syntaxe : array newbiface -> solid
%% ou array = tableau de points 2d
/newbiface {
   newmonoface
   dup videsolid
} def

%%%%% ### newpolreg ### 
%% syntaxe : r n newpolreg --> solid
/newpolreg {
5 dict begin
   /n exch def
   /r exch def
   /S [
       0 360 n div 360 360 n div sub {
           /theta exch def
           theta cos r mul
           theta sin r mul
           0
       } for
   ] def
   /F [
       [0 1 n 1 sub {} for]
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newgrille ### 
%% syntaxe : xmin xmax ymin ymax [dx dy] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax [nx ny] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax {mode} newgrille -> solid
%% syntaxe : xmin xmax ymin ymax newgrille -> solid
/newgrille {
10 dict begin
   [[/nx /ny] [1 1] [1. 1.] [1. 1.] [1. 1.] [.5 .5]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /biface false def
   [nx ny] {0} newsurfaceparametree
end
} def

%% %% syntaxe : xmin xmax ymin ymax [dx dy] {f} newsurface -> solid
%% %% f : R^2 -> R
/newsurface {
   true newsurfaceparametree
} def

/biface true def

/newsurfaceparametree {
10 dict begin
   dup isbool {
      pop /surfz true def
   } {
      /surfz false def
   } ifelse
   /f_surface exch def
   [[/nx /ny] [2 2] [4 4] [1. 1.] [1. 1.] [.25 .25]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def

   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x

   /S [
       0 1 nx {
           /i exch def
           0 1 ny {
               /j exch def
               /u xmin i dx mul add def
               /v ymin j dy mul add def
               u v
               surfz {2 copy} if
               f_surface
               pstrickactionR3
           } for
       } for
   ] def

   /F [
       0 1 nx 1 sub {
          /i exch def
          0 1 ny 1 sub {
             /j exch def
             [
                j 1 add        i ny 1 add mul add
                j              i ny 1 add mul add
                j ny 1 add add i ny 1 add mul add
                j ny 2 add add i ny 1 add mul add
             ]
          } for
       } for
%%       0 1 0 {%nx 1 sub {
%%          /i exch def
%%          0 1 0 {%ny 2 sub {
%%             /j exch def
%%             [
%%             j 1 add        %% i ny mul add
%%             j              %% i ny mul add
%%             ny 1 add j add       %% i ny mul add
%%             ny 2 add j add     %% i ny mul add
%%             ]
%%          } for
%%       } for
   ] def
   S F generesolid
   biface pl@n-en-cours not and {dup videsolid} if
end
} def

%%%%% ### newgrillecirculaire ### 
%% syntaxe : r option newgrillecirculaire -> solid
/newgrillecirculaire {
6 dict begin
   [[/K /N] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode

   %% N = nb de meridiens (diviseur de 360 = 2^4 * 3^2 * 5)
   %% K = nb d horizontales (diviseur de 160 = 2^5 * 5)

   /r exch def
   /F [
       %% 1er etage
       1 1 N {
           /i exch def
           [0 i i N mod 1 add]
       } for
       %% etages suivants
       0 1 K 2 sub {
           /j exch def
           1 1 N {
               /i exch def
               [i      j N mul add
               i N add j N mul add
               i N mod N add 1 add j N mul add
               i N mod 1 add j N mul add]
           } for
      } for
   ] def

   %% tableau des sommets
   /S [
       0 0 0
       1 1 K {
           /j exch def
           1 1 N {
             /i exch def
             /theta i 360 mul N div def
             theta cos r j mul K div mul
             theta sin r j mul K div mul
             0 %2 copy f %exch atan 90 div
          } for
       } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r [dx dy] {f} newsurface* -> solid
/newsurface* {
7 dict begin
   /f_surface exch def
   [[/nx /ny] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode

   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x

   %% ny = nb de meridiens
   %% nx = nb d horizontales

   /r exch def
   /F [
       %% 1er etage
       1 1 ny {
           /i exch def
           [0 i i ny mod 1 add]
       } for
       %% etages suivants
       0 1 nx 2 sub {
           /j exch def
           1 1 ny {
               /i exch def
               [i      j ny mul add
               i ny add j ny mul add
               i ny mod ny add 1 add j ny mul add
               i ny mod 1 add j ny mul add]
           } for
      } for
   ] def

   %% tableau des sommets
   /S [
       0 0 0
       1 1 nx {
           /j exch def
           1 1 ny {
             /i exch def
             /theta i 360 mul ny div def
             theta cos r j mul nx div mul
             theta sin r j mul nx div mul
             2 copy f_surface
          } for
       } for
   ] def

   S F generesolid
end
} def

%%%%% ### newruban ### 
%% syntaxe : array h u [n] newruban -> solid d axe (O, u), de maillage vertical n
%% syntaxe : array h u newruban -> solid d axe (O, u),
%% syntaxe : array h newruban -> solid d axe (O, k),
%% ou array tableau de points 2d
/newruban {
7 dict begin
   %% N = nb d etages
   [[/N] [1] [1] [1] [3] [4]] gestionsolidmode
   2 copy pop isarray {
      /u {0 0 1} def
   } {
      /u defpoint3d
   } ifelse
   u 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newruban) ==
      quit
   } if
   pop pop
   /h exch def
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   h u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
     } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newicosaedre ### 
/newicosaedre {
3 dict begin
   /a exch def
   /S [
      0.8944271  0              0.4472137
      0.2763932  0.8506507      0.4472137
      -0.7236067 0.5257311      0.4472137
      -0.7236067 -0.5257311     0.4472137
      0.2763932  -0.8506507     0.4472137
      0          0              1
      0          0              -1
      -0.8944271 0              -0.4472137
      -0.2763932 -0.8506507     -0.4472137
      0.7236067  -0.5257311     -0.4472137
      0.7236067  0.5257311      -0.4472137
      -0.2763932 0.8506507      -0.4472137
   ] {a mulv3d} papply3d def

   /F [
      [0 1 5]   %% 1  2 6  ]
      [1 2 5]   %% 2  3 6  ]
      [2 3 5]   %% 3  4 6  ]
      [3 4 5]   %% 4  5 6  ]
      [4 0 5]   %% 5  1 6  ]
      [9 0 4]   %% 10 1 5  ]
      [0 9 10]  %% 1  10 11]
      [10 1 0]  %% 11 2 1  ]
      [1 10 11] %% 2  11 12]
      [11 2 1]  %% 12 3 2  ]
      [2 11 7]  %% 3  12 8 ]
      [2 7 3]   %% 3  8 4  ]
      [3 7 8]   %% 4  8 9  ]
      [3 8 4]   %% 4  9 5  ]
      [4 8 9]   %% 5  9 10 ]
      [6 7 11]  %% 7  8 12 ]
      [6 8 7]   %% 7  9 8  ]
      [6 9 8]   %% 7  10 9 ]
      [6 10 9]  %% 7  11 10]
      [6 11 10] %% 7  12 11]
   ] def

   S F generesolid
end
} def

%%%%% ### newdodecaedre ### 
/newdodecaedre {
3 dict begin
   /a exch def
   /S [
      0          0.607062   0.7946545
      -0.5773503 0.1875925  0.7946545
      -0.3568221 -0.4911235 0.7946545
      0.3568221  -0.4911235 0.7946545
      0.5773503  0.1875925  0.7946545
      0          0.982247   0.1875925
      -0.9341724 0.303531   0.1875925
      -0.5773503 -0.7946645 0.1875925
      0.5773503  -0.7946645 0.1875925
      0.9341724  0.303531   0.1875925
      0          -0.982247  -0.1875925
      0.9341724  -0.303531  -0.1875925
      0.5773503  0.7946545  -0.1875925
      -0.5773503 0.7946545  -0.1875925
      -0.9341724 -0.303531  -0.1875925
      -0.5773503 -0.1875925 -0.7946545
      -0.3568221 0.4911235  -0.7946545
      0.3568221  0.4911235  -0.7946545
      0.5773503  -0.1875925 -0.7946545
      0          -0.607062  -0.7946545
   ] {a mulv3d} papply3d def

   /F [
      [0 1 2 3 4]
      [4 3 8 11 9]
      [4 9 12 5 0]
      [0 5 13 6 1]
      [1 6 14 7 2]
      [2 7 10 8 3]
      [10 19 18 11 8]
      [11 18 17 12 9]
      [12 17 16 13 5]
      [13 16 15 14 6]
      [14 15 19 10 7]
      [15 16 17 18 19]
   ] def
   S F generesolid
end
} def

%%%%% ### newoctaedre ### 
/newoctaedre {
3 dict begin
   /a exch def
   %%Sommets
   /S [
      0  0  1
      1  0  0
      0  1  0
      -1 0  0
      0  -1 0
      0  0  -1
   ] {a mulv3d} papply3d def

   /F [
      [0 4 1]
      [1 2 0]
      [0 2 3]
      [3 4 0]
      [1 5 2]
      [2 5 3]
      [3 5 4]
      [4 5 1]
   ] def

   S F generesolid
end
} def

%%%%% ### newtetraedre ### 
/newtetraedre {
3 dict begin
   /r exch def
   %%Tetraedre
   /S [
      0          0          1
      -0.4714045 -0.8164965 -1 3 div
      0.942809   0          -1 3 div
      -0.4714045 0.8164965  -1 3 div
   ] {r mulv3d} papply3d def

   /F [
      [0 1 2]
      [0 2 3]
      [0 3 1]
      [1 3 2]
   ] def

   S F generesolid
end
} def

%%%%% ### newcube ### 
/newcube {
3 dict begin
   [[/n] [1] [1] [1] [3] [4]] gestionsolidmode
   /a exch 2 div def

   n 1 le {
      /F [
     [0 1 2 3]
     [0 4 5 1]
     [1 5 6 2]
     [2 6 7 3]
     [0 3 7 4]
     [4 7 6 5]
      ] def

      %% tableau des sommets
      /S [
      1  1  1 %% 0
     -1  1  1 %% 1
     -1 -1  1 %% 2
      1 -1  1 %% 3
      1  1 -1 %% 4
     -1  1 -1 %% 5
     -1 -1 -1 %% 6
      1 -1 -1 %% 7
      ] {a mulv3d} papply3d def
      S F generesolid
   } {
      /dl 2 n div def
      /N n dup mul n add 4 mul def
      /n1 n 1 sub dup mul def %% nb sommets centre d une face

      %% tableau des sommets
      /S1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n {
           /i exch def
           -1 i dl mul add
           -1 j dl mul add
        1
        } for
     } for
      ] def

      /S2 S1 {-90 0 0 rotateOpoint3d} papply3d def
      /S3 S2 {-90 0 0 rotateOpoint3d} papply3d def
      /S4 S3 {-90 0 0 rotateOpoint3d} papply3d def

      /S5 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
        1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      /S6 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
           -1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      %% tableau des faces
      /F1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n 1 sub {
           /i exch def
           [
          i n 1 add j mul add
          dup 1 add
          dup n 1 add add
          dup 1 sub
           ]
        } for
     } for
      ] def

      %% syntaxe : i sommettourgauche --> l indice du i-eme sommet du tour
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourgauche {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourgauche) ==
        exit
     } if
     n n 1 add i mul add
      end
      } def

      %% syntaxe : i sommetcentregauche --> l indice du i-eme sommet du centre
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentregauche {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentregauche) ==
        exit
     } if
     N i add
      end
      } def

      /F5 [
     %%%%% la face gauche %%%%%
     %% le coin superieur gauche
     [
        1 sommettourgauche
        0 sommettourgauche
        n 4 mul 1 sub sommettourgauche
        n1 n 1 sub sub sommetcentregauche
     ]

     %% la bande superieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i 1 add sommettourgauche
           i sommettourgauche
           n1 n sub i add sommetcentregauche
           n1 n sub i 1 add add sommetcentregauche
        ]
     } for

     %% le coin superieur droit
     [
        n sommettourgauche
        n 1 sub sommettourgauche
        n1 1 sub sommetcentregauche
        n 1 add sommettourgauche
     ]

     %% la descente gauche
     %% j from 1 to n-2
     1 1 n 2 sub {
        /j exch def
        [
           n1 n 1 sub j mul sub sommetcentregauche
           n 4 mul j sub sommettourgauche
           n 4 mul j 1 add sub sommettourgauche
           n1 n 1 sub j 1 add mul sub sommetcentregauche
        ]
     } for

     %% les bandes centrales (j from 1 to n-2 et i from 1 to n-2)
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n1 i n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j mul add sub sommetcentregauche
          n1 i n 1 sub j mul add sub sommetcentregauche
           ]
        } for
     } for

     %% la descente droite
     1 1 n 2 sub {
        /j exch def
        [
           n j add sommettourgauche
           n1 1 sub j 1 sub n 1 sub mul sub sommetcentregauche
           n1 1 sub j n 1 sub mul sub sommetcentregauche
           n j 1 add add sommettourgauche
        ]
     } for

     %% le coin inferieur gauche
     [
        0 sommetcentregauche
        n 3 mul 1 add sommettourgauche
        n 3 mul sommettourgauche
        n 3 mul 1 sub sommettourgauche
     ]

     %% la bande inferieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i sommetcentregauche
           i 1 sub sommetcentregauche
           n 3 mul i sub sommettourgauche
           n 3 mul i sub 1 sub sommettourgauche
        ]
     } for

     %% le coin inferieur droit
     [
        n 2 mul 1 sub sommettourgauche
        n 2 sub sommetcentregauche
        n 2 mul 1 add sommettourgauche
        n 2 mul sommettourgauche
     ]
      ] def

      %% syntaxe : i sommettourdroit --> l indice du i-eme sommet du tour
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourdroit {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourdroit) ==
        exit
     } if
     n 1 add i mul
      end
      } def

      %% syntaxe : i sommetcentredroit --> l indice du i-eme sommet du centre
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentredroit {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentredroit) ==
        exit
     } if
     N n1 add i add
      end
      } def

      /F6 [
     %% coin superieur droit
     [
        0 sommettourdroit
        1 sommettourdroit
        n1 n 1 sub sub sommetcentredroit
        4 n mul 1 sub sommettourdroit
     ]
     %% coin superieur gauche
     [
        n 1 sub sommettourdroit
        n sommettourdroit
        n 1 add sommettourdroit
        n1 1 sub sommetcentredroit
     ]
     %% coin inferieur gauche
     [
        n 2 sub sommetcentredroit
        2 n mul 1 sub sommettourdroit
        2 n mul sommettourdroit
        2 n mul 1 add sommettourdroit
     ]
     %% coin inferieur droit
     [
        3 n mul 1 add sommettourdroit
        0 sommetcentredroit
        3 n mul 1 sub sommettourdroit
        3 n mul sommettourdroit
     ]
     %% bande superieure
     1 1 n 2 sub {
        /i exch def
        [
           i sommettourdroit
           i 1 add sommettourdroit
           n 1 sub n 2 sub mul i add sommetcentredroit
           n 1 sub n 2 sub mul i 1 sub add sommetcentredroit
        ]
     } for
     %% bande inferieure
     1 1 n 2 sub {
        /i exch def
        [
           i 1 sub sommetcentredroit
           i sommetcentredroit
           3 n mul 1 sub i sub sommettourdroit
           3 n mul i sub sommettourdroit
        ]
     } for
     %% descente gauche
     1 1 n 2 sub {
        /i exch def
        [
           n1 1 sub i 1 sub n 1 sub mul sub sommetcentredroit
           n i add sommettourdroit
           n i 1 add add sommettourdroit
           n1 1 sub i n 1 sub mul sub sommetcentredroit
        ]
     } for
     %% descente droite
     1 1 n 2 sub {
        /i exch def
        [
           4 n mul i sub sommettourdroit
           n 1 sub n 1 sub i sub mul sommetcentredroit
           n 1 sub n 2 sub i sub mul sommetcentredroit
           4 n mul i sub 1 sub sommettourdroit
        ]
     } for
     %% bandes interieures
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n 1 sub j mul i 1 sub add sommetcentredroit
          n 1 sub j mul i add sommetcentredroit
          n 1 sub j 1 sub mul i add sommetcentredroit
          n 1 sub j 1 sub mul i 1 sub add sommetcentredroit
           ]
        } for
     } for

      ] def

      /F2 F1 {{n dup mul n add add} apply} apply def
      /F3 F2 {{n dup mul n add add} apply} apply def
      /F4 F3 {{n dup mul n add add} apply} apply def


      S1 S2 append S3 append S4 append S5 append S6 append {a mulv3d} papply3d
      F1 F2 append F3 append F4 append {{N mod} apply} apply F5 append F6 append
      generesolid
   } ifelse
end
} def

%%%%% ### newparallelepiped ### 
% 14 octobre 2006
/newparallelepiped {
2 dict begin
   /c exch 2 div def
   /b exch 2 div def
   /a exch 2 div def
   /F [
      [0 1 2 3]
      [0 4 5 1]
      [1 5 6 2]
      [2 6 7 3]
      [0 3 7 4]
      [4 7 6 5]
    ] def

    %% tableau des sommets
    /S [
       a     b     c %% 0
       a neg b     c %% 1
       a neg b neg c %% 2
       a     b neg c %% 3
       a     b     c neg %% 4
       a neg b     c neg %% 5
       a neg b neg c neg %% 6
       a     b neg c neg %% 7
    ] def
    S F generesolid
end
} def

%%%%% ### newcylindre ### 
%% syntaxe : z0 r0 z1 newcylindre -> solide
%% syntaxe : z0 r0 z1 {mode} newcylindre -> solide
%% syntaxe : z0 r0 z1 [n1 n2] newcylindre -> solide
%% syntaxe : a b {f} {u} h [n1 n2] newcylindre
/newcylindre {
2 dict begin
   [[/n2 /n1] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode
   2 copy pop xcheck {
      %% cylindre cas general
      /h exch def
      /U exch def
      U normalize3d /u defpoint3d
      /lafonction exch def
      /b exch def
      /a exch def
      /pas b a sub n1 div def
      /vpas h n2 div def
      /S [
         0 1 n2 {
            /j exch def
            0 1 n1 {
               /i exch def
               a i pas mul add lafonction
               u j vpas mul mulv3d addv3d
            } for
         } for
      ] def
      /F [
         0 1 n2 1 sub {
            /j exch def
            0 1 n1 1 sub {
               /i exch def
               [
                  i n1 1 add j mul add 
                  dup 1 add
                  dup n1 1 add add
                  dup 1 sub
               ]
            } for
         } for
      ] def
      
      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      2 copy pop [n2 n1] newtronccone
   } ifelse
end
} def

%% syntaxe : z0 r0 z1 newcylindrecreux -> solide
/newcylindrecreux {
   newcylindre
   dup creusesolid
} def

%%%%% ### newtronccone ### 
%% syntaxe : z0 r0 z1 r1 newtronccone -> solid
/newtronccone {
11 dict begin
   [[/n /N] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode

   /r1 exch def
   /z1 exch def
   /r0 exch def
   /z0 exch def
   /dz z1 z0 sub n div def
   /dr r1 r0 sub n div def

   /FE [
      [0 1 N 1 sub {} for]
      [n 1 add N mul 1 sub -1 n N mul {} for]

      0 1 n 1 sub {
      /k exch def
         k N mul 1 add 1 k 1 add N mul 1 sub {
             /i exch def
             [i i 1 sub N i add 1 sub N i add]
         } for
         [k N mul k 1 add N mul 1 sub k 2 add N mul 1 sub k 1 add N mul]
      } for

   ] def

   %% tableau des sommets
   /S [
      n -1 0 {
         /k exch def
         0 1 N 1 sub {
             /i exch def
             360 N idiv i mul cos r0 dr k mul add mul
             360 N idiv i mul sin r0 dr k mul add mul
             z0 dz k mul add
         } for
      } for
   ] def
   S FE generesolid
end
} def

%% syntaxe : z0 r0 z1 r1 newtroncconecreux -> solid
/newtroncconecreux {
   newtronccone
   dup creusesolid
} def

%%%%% ### newcone ### 
%% syntaxe : z0 r0 z1 newcone -> solid
%% syntaxe : z0 r0 z1 {mode} newcone -> solid
%% syntaxe : z0 r0 z1 [n1 n2] newcone -> solid
%% syntaxe : a b {f} {sommet} [n1 n2] newcone -> solid
/newcone {
11 dict begin
   [ [/n /N] [1 6] [1 8] [1 10] [3 12] [5 18] ] gestionsolidmode
   dup xcheck {
      %% cas general
      /sommet exch def
      /lafonction exch def
      /b exch def
      /a exch def

      /pas b a sub N div def
      /S [
         sommet
         0 1 n 1 sub {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               dupp3d sommet vecteur3d j n div mulv3d addv3d
            } for
         } for
         1 1 n {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               sommet vecteur3d j n div mulv3d sommet addv3d
            } for
         } for
      ] def

      /F [
         %% les etages inferieurs
         0 1 n 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
         %% dernier etage inferieur
         1 1 N {
            /i exch def
            [
               i N 1 add n 1 sub mul add
               dup 1 add
               0
            ]
         } for
         %% premier etage superieur
         1 1 N {
            /i exch def
            [
               i N 1 add n mul add
               dup 1 add
               0
               exch
            ]
         } for
         %% les etages superieurs
         n 1 n 2 mul 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
      ] def

      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      /z1 exch def
      /r0 exch def
      /z0 exch def
      /dz z1 z0 sub n div def
      /dr r0 n div def
   
      /F [
         %% la base
         [N 1 sub -1 0 {} for]
         %% le dernier etage
         n 1 sub N mul 1 add 1 n N mul 1 sub {
              /i exch def
              [i 1 sub i n N mul]
         } for
         [n N mul 1 sub n 1 sub N mul n N mul]
         %% les autres etages
         0 1 n 2 sub {
            /j exch def
            0 N j mul add 1 N N j mul add 2 sub {
               /i exch def
               [i i 1 add dup N add dup 1 sub]
            } for
            [N N j mul add 1 sub N j mul dup N add dup N add 1 sub]
         } for
      ] def
   
      %% tableau des sommets
      /S [
         %% etage no j (in [1; n])
         0 1 n 1 sub {
            /j exch def
            0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r0 dr j mul sub mul
                360 N idiv i mul sin r0 dr j mul sub mul
                z0 dz j mul add
            } for
         } for
         0 0 z1
      ] def
      S F generesolid
   } ifelse
end
} def

%% %% syntaxe : z0 r0 z1 newconecreux -> solid
 /newconecreux {
    newcone
    dup 0 solidrmface
    dup videsolid
 } def

%%%%% ### newtore ### 
%% syntaxe : r R newtore -> solid
/newtore {
10 dict begin
   [[/n1 /n2] [4 5] [6 10] [8 12] [9 18] [18 36]] gestionsolidmode
   /n2 n2 3 max store
   /n1 n1 2 max store
   /R exch def
   /r exch def
   /S [
         0 1 n1 1 sub {
            /i exch def
            360 n1 div i mul cos r mul R add
            360 n1 div i mul sin r mul
         } for
      ]
   def
   S [n2] newanneau
end
} def

%%%%% ### newprisme ### 
%% syntaxe : array z0 z1 newprisme -> solid d axe (O, u),
/newprismedroit {
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   0 0 1 [N] newprisme
} def

%% syntaxe : array z0 z1 u newprisme -> solid d axe (O, u),
%% ou array tableau de points 2d
/newprisme {
7 dict begin
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   dup 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newprisme) ==
      quit
   } if
   /u defpoint3d
   /z1 exch def
   /z0 exch def
   %% N = nb d etages
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   z1 z0 sub u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             z0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [ 
      %% face superieure
      [0 1 n {} for]
      %% base
      [N 1 add n 1 add mul 1 sub -1 N n 1 add mul {} for]
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
         [0            j 1 sub n 1 add mul add
         n             j 1 sub n 1 add mul add
         2 n mul 1 add j 1 sub n 1 add mul add
         n 1 add       j 1 sub n 1 add mul add]
     } for
   ] def

   S F generesolid
end
} def

%%%%% ### newsphere ### 
%% syntaxe : r option newsphere -> solid
/newsphere {
2 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode
   -90 90 [K N] newcalottesphere
end
} def

%% syntaxe : r phi theta option newcalottesphere -> solid
/newcalottesphere {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r phi theta option newcalottespherecreuse -> solid
/newcalottespherecreuse {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
%        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
%         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newanneau ### 
%% syntaxe : array n newanneau --> solid
%% syntaxe : array {mode} newanneau --> solid
%% ou array est un tableau de points de R^2 et n un nombre entier positif
/newanneau {
10 dict begin
   dup isnum {
      /n exch def
      [n]
   } if
   [[/n2] [6] [12] [24] [32] [36]] gestionsolidmode
   /n2 n2 3 max store
   %% on plonge la section dans R^3 par projection sur yOz
   /S1 exch {0 3 1 roll} papply def
   %% nombre de sommets
   /n1 S1 length 3 idiv def

   /S S1
      n2 {
         duparray
         {0 0 360 n2 div rotateOpoint3d} papply3d
      } repeat
      n2 {append} repeat
   def

   /F [
      0 1 n2 1 sub {
         /j exch def
         n1 j mul 1 j 1 add n1 mul 2 sub {
            /i exch def
            [i 1 add i dup n1 add i n1 1 add add]
         } for
         [n1 j mul j 1 add n1 mul 1 sub j 2 add n1 mul 1 sub j 1 add n1 mul]
      } for
   ] def

   S F generesolid
end
} def

%%%%% ### newvecteur ### 
%% syntaxe : x y z newvecteur
%% syntaxe : x y z array newvecteur
/newvecteur {
4 dict begin
   dup isarray {
      /table exch def
      /h@uteur table 1 get def
      /r@y@n table 0 get def
   } {
      /h@uteur .3 def
      /r@y@n .1 def
   } ifelse
   /A defpoint3d
   %%Sommets
   /S [0 0 0 A] def
   /F [
      [0 1]
   ] def
   S F generesolid
   [ A ]
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d

   A norme3d /z exch h@uteur sub def 
   0 r@y@n h@uteur [1 8] newcone
   dup (noir) outputcolors
   {0 0 z translatepoint3d} solidtransform
   {imI imJ imK transformpoint3d} solidtransform
   solidfuz
end
} def

%%%%% ### readsolidfile ###
%% syntaxe : str readsolidfile -> solid
/readsolidfile {
1 dict begin
   /str exch def
   [str (-sommets.dat) append run] 
   [str (-faces.dat) append run]
   generesolid
   dup [str (-couleurs.dat) append run] solidputfcolors
   dup [str (-io.dat) append run] solidputinouttable
end
} def

%%%%% ### writesolidfile ###
%% syntaxe : solid str writesolidfile -> -
/writesolidfile {
10 dict begin
   /str exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans writesolidfile) ==
      quit
   } if
   str (-sommets.dat) append (w) file /lefichiersommets exch def
   str (-faces.dat) append (w) file /lefichierfaces exch def
   str (-couleurs.dat) append (w) file /lefichiercouleurs exch def
   str (-io.dat) append (w) file /lefichierio exch def

   /S solid solidgetsommets def
   0 1 S length 3 idiv 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichiersommets x chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets y chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets z chaine cvs writestring
      lefichiersommets 10 write %% CR
   } for
   lefichiersommets closefile

   /F solid solidgetfaces def
   0 1 F length 1 sub {
      /i exch def
      /Fi solid i solidgetface def
      lefichierfaces 91 write %% [
      0 1 Fi length 1 sub {
         /j exch def
         lefichierfaces Fi j get chaine cvs writestring
         lefichierfaces 32 write %% espace
      } for
      lefichierfaces 93 write %% ]
      lefichierfaces 10 write %% CR
   } for
   lefichierfaces closefile

   /C solid solidgetfcolors def
   0 1 C length 1 sub {
      /i exch def
      lefichiercouleurs 40 write %% (
      lefichiercouleurs C i get writestring
      lefichiercouleurs 41 write %% )
      lefichiercouleurs 10 write %% CR
   } for
   lefichiercouleurs closefile

   /IO solid solidgetinouttable def
   0 1 3 {
      /i exch def
      lefichierio IO i get chaine cvs writestring
      lefichierio 32 write %% space
   } for
   lefichierio closefile
end
} def

%%%%% ### writeobjfile ###
%% syntaxe : solid str writeobjfile -> -
/writeobjfile {
10 dict begin
   /str exch (.obj) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeobjfile) ==
      quit
   } if
   /n solid solidnombresommets def
   str (w) file /lefichier exch def
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier (v ) writestring
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      lefichier (f ) writestring
      /F solid i solidgetface {1 add} apply def
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### writeofffile ###
%% syntaxe : solid str writeobjfile -> -
/writeofffile {
12 dict begin
   /str exch (.off) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeofffile) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def
   str (w) file /lefichier exch def
   lefichier (OFF) writestring
   lefichier 10 write %% CR
   lefichier n chaine cvs writestring
   lefichier 32 write %% espace
   lefichier nf chaine cvs writestring
   lefichier 32 write %% espace
   lefichier 0 chaine cvs writestring
   lefichier 10 write %% CR
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   0 1 nf 1 sub {
      /i exch def
      /F solid i solidgetface def
      lefichier F length chaine cvs writestring
      lefichier 32 write %% espace
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### newobjfile ###
/newobjfile {
3 dict begin
   /objfilename exch (.obj) append def
   /v {} def
   /ok true def
   /f {
       ok {
        %% 1ere fois
           ] %% ferme les sommets
        [ [ %% ouvre les faces
        /ok false store
       } {
        %% les autres fois
           ] %% ferme la face
        [ %% ouvre la nouvelle
       } ifelse
   } def
   [ 0 0 0 %% sommet fantome pour respecter l'indexation (a partir de l'indice 1)
   objfilename run
   ]]
   /F exch def
   /S exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newofffile ###
/newofffile {
3 dict begin
   /str 35 string def
   /offfilename exch (.off) append def
   offfilename (r) file
   /offfile exch def
   offfile str readline pop pop
   offfile str readline pop
   numstr2array
   dup 0 get /ns exch def
   1 get /nf exch def
   [ns {
      offfile str readline pop numstr2array aload pop
%      3 1 roll
   } repeat]
   /S exch def
   [nf {
      [
      offfile str readline pop numstr2array
      /table exch def
      1 1 table length 1 sub {
         /i exch def
         table i get
      } for
      ]
   } repeat]
   /F exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newtube ###
 /tub@dernierk1 [1 0 0] def
 /tub@dernierk2 [0 1 0] def
 /tub@dernierk3 [0 0 1] def

/inittube {
2 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   vect1 norme3d 0 eq {
      vect2 vect3 vectprod3d /vect1 defpoint3d
   } if
   vect2 norme3d 0 eq {
      vect3 vect1 vectprod3d /vect2 defpoint3d
   } if
   vect3 norme3d 0 eq {
      vect1 vect2 vectprod3d /vect3 defpoint3d
   } if
   /tub@dernierk1 [vect1] store
   /tub@dernierk2 [vect2] store
   /tub@dernierk3 [vect3] store
end
} def
 
%% syntaxe : tmin tmax (f) array r newtube -> solid
%% array = [K N]
/newtube {
10 dict begin
   /table exch def
   /K table 0 get def %% nb d etages
   /N table 1 get def %% nb de points sur le perimetre
   /@r exch def       %% le rayon du tube
   /str exch def
   /lafonction str cvx def
   /laderivee str (') append cvx def
%%   /laderivee2nd str ('') append cvx def
   /tmax exch def
   /tmin exch def
   /pas tmax tmin sub K 1 sub div def

   %% definition des sommets
   [
   /@k 0 def
   K {
      /a0 tmin @k pas mul add def
   
      %% definition du repere de Frenet (k1, k2, k3) au point f(a)
      a0 lafonction /M defpoint3d

      str (') append cvlit where {
         pop 
         a0 laderivee normalize3d /k1 defpoint3d
%         pop /avecderiv true def
      } {
         M a0 pas 100 div add lafonction vecteur3d normalize3d /k1 defpoint3d
%         /avecderiv false
      } ifelse

      k1 baseplannormal /K3 defpoint3d /K2 defpoint3d
%      a0 laderivee2nd normalize3d /k2 defpoint3d

      %% projete orthogonal du dernier rayon sur le plan actuel
      %% (normal a la vitesse)
      K2 tub@dernierk2 aload pop K2 scalprod3d mulv3d 
      K3 tub@dernierk2 aload pop K3 scalprod3d mulv3d addv3d /k2 defpoint3d
%      M k1 K2 K3 dessinebase
      k1 norme3d 0 eq {
         tub@dernierk1 aload pop /k1 defpoint3d
      } {
         /tub@dernierk1 [k1] store
      } ifelse
      k2 norme3d 0 eq {
         tub@dernierk2 aload pop /k2 defpoint3d
      } {
         /tub@dernierk2 [k2] store
      } ifelse
      k1 k2 vectprod3d normalize3d /k3 defpoint3d
      k3 norme3d 0 eq {
          tub@dernierk3 aload pop /k3 defpoint3d
      } {
         /tub@dernierk3 [k3] store
      } ifelse
      k3 k1 vectprod3d normalize3d /k2 defpoint3d
%%      M k1 k2 k3 dessinebase
      /tub@dernierk2 [k2] store
      /@n 360 N div def %% le pas angulaire
      0 @n 360 @n sub {
         /@i exch def
         M
         k2 @i cos @r mul mulv3d addv3d
         k3 @i sin @r mul mulv3d addv3d
      } for
      /@k @k 1 add store
   } repeat
   ]

   dup length 3 idiv /nb exch def
   %% definition des faces
   [
      %% face de depart
      [N 1 sub -1 0 {} for]
      %% face d arrivee
      [nb 1 sub N 1 sub {dup 1 sub} repeat] reverse
   
      %% les etages
      /j 0 def
      K 1 sub {
         0 1 N 1 sub {
            /i exch def
            [
               i                   N j mul add
               i 1 add N mod       N j mul add
               i 1 add N mod N add N j mul add
               i N add             N j mul add
            ]
         } for
         /j j 1 add store
      } repeat
   ]
   generesolid
end
} def

%%%%% ### newcourbe ###
%% syntaxe : a b {f} array newcourbe --> solid
/newcourbe {
10 dict begin
   dup xcheck not {
      0 get /n exch def
   } {
      /n 80 def
   } ifelse
   /l@f@nct exch def
   /b exch def
   /a exch def
   /pas b a sub n 1 sub div def
   /S [
   0 1 n 1 sub {
      /@i exch def
      a @i pas mul add
      l@f@nct
      pstrickactionR3
   } for
   ] def
   /@F [
      0 1 n 2 sub {
         /@i exch def
         [@i @i 1 add]
      } for
   ] def
   S @F generesolid
end
} def

%%%%% ### baseplannormal ###
%% syntaxe : x y z baseplannormal -> x1 y1 z1 x2 y2 z2
/baseplannormal {
5 dict begin
   /K defpoint3d
   1 0 0 K vectprod3d normalize3d /U defpoint3d
   U norme3d 0 eq {
      0 1 0 K vectprod3d normalize3d /U defpoint3d
   } if
   K U vectprod3d normalize3d /V defpoint3d
   U V
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%      fin insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          gestion de chaine de caracteres           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/Times-Roman findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end
/Times-Roman-ISOLatin1 exch definefont pop

/setTimesRoman {
   /Times-Roman-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

/setTimes {
   setTimesRoman
} def

%% syntaxe : string x y cctext
/cctext {
5 dict begin
   /y exch def
   /x exch def
   /str exch def
   str stringwidth
   /wy exch def
   /wx exch def
   gsave
      x y smoveto
      wx -2 div wy -2 div rmoveto
      str show
   grestore
end
} def

/dbtext {gsave newpath dbtext_ Fill grestore} def
/dctext {gsave newpath dctext_ Fill grestore} def
/dltext {gsave newpath dltext_ Fill grestore} def
/drtext {gsave newpath drtext_ Fill grestore} def

/bbtext {gsave newpath bbtext_ Fill grestore} def
/bctext {gsave newpath bctext_ Fill grestore} def
/bltext {gsave newpath bltext_ Fill grestore} def
/brtext {gsave newpath brtext_ Fill grestore} def

/cbtext {gsave newpath cbtext_ Fill grestore} def
/cctext {gsave newpath cctext_ Fill grestore} def
/cltext {gsave newpath cltext_ Fill grestore} def
/crtext {gsave newpath crtext_ Fill grestore} def

/ubtext {gsave newpath ubtext_ Fill grestore} def
/uctext {gsave newpath uctext_ Fill grestore} def
/ultext {gsave newpath ultext_ Fill grestore} def
/urtext {gsave newpath urtext_ Fill grestore} def


%% syntaxe : str x y show_dim --> str x y llx lly wx wy 
%% attention, doit laisser la pile intacte
/show_dim {
   3 copy pop pop
   newpath
      0 0 moveto
      true charpath flattenpath pathbbox 
   closepath
   newpath
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour PSTricks               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% les 3 procedures utilisees pour transformer les depots de AlgToPs en nombres
/pstrickactionR3 { 
3 dict begin 
  /len@3 exch def 
  /len@2 exch def 
  /len@1 exch def 
  len@1 exec 
  len@2 exec 
  len@3 exec 
end 
} def 

/pstrickactionR2 {
   exec exch exec exch
} def

/pstrickactionR {
   exec
} def

/gere_pst-deffunction {
   counttomark
   dup 1 eq {
      pop
      pstrickactionR
      ] aload pop
   } {
      2 eq {
         pstrickactionR2
         ] aload pop
      } {
         pstrickactionR3
         ] aload pop
      } ifelse
   } ifelse
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour \psSolid               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/all (all) def

/draw {drawsolid} def
/draw* {drawsolid*} def
/draw** {drawsolid**} def
/writeobj {solidfilename writeobjfile} def
/writesolid {solidfilename writesolidfile} def
/writeoff {solidfilename writeofffile} def
/none {pop} def
/vecteur_en_c@urs false def

/gere_pstricks_color_inout {
   gsave
      dup  [fillincolor] (setrgbcolor) astr2str
         [fillcolor] (setrgbcolor) astr2str inoutputcolors
   grestore
} def

/gere_pstricks_color_out {
   gsave
      dup  [fillcolor] (setrgbcolor) astr2str outputcolors
   grestore
} def

/gere_pstfont {
   fontsize mul setfontsize
   %setTimes
   PSfont dup /Symbol ne isolatin and {
      /ISO-Font ReEncode /ISO-Font
   } if
   findfont fontsize scalefont setfont
} def

/gere_pstricks_opt {
%   /CourbeR2 {CourbeR2+} def
   1 gere_pstfont
   linecolor
   linestyle
   solidlinewidth setlinewidth
   solidtrunc length 0 ne {
      solidtrunc 0 get isstring {
         dup trunccoeff solidtronque
      } {
         dup solidtrunc trunccoeff solidtronque
      } ifelse
   } if
   solidgeode {
      1 newgeode
   } if
   soliddualreg {
      dualpolyedreregulier
   } if
   chanfrein {
      dup chanfreincoeff solidchanfreine
   } if
   RotX 0 ne RotY 0 ne or RotZ 0 ne or {
      {RotX RotY RotZ rotateOpoint3d} solidtransform
   } if
   CX 0 ne CY 0 ne or CZ 0 ne or {
      {CX CY CZ translatepoint3d} solidtransform
   } if
   plansection length 0 gt {
      0 1 plansection length 1 sub {
         /i exch def
         plansection i get solidplansection
         dup 0 solidrmface
      } for
   } if
   /rmfaces rmfaces bubblesort reverse store
   0 1 rmfaces length 1 sub {
      /i exch def
      dup rmfaces i get solidrmface
   } for
   tx@Dict /pst-transformoption known {
      dup {pst-transformoption} solidtransform 
   } if
   solidaffinage length 0 ne {
      %% si on affine, il faut colorier avant
      activationgestioncouleurs {
         gere_pstricks_color_out
      } if
      solidaffinage 0 get isstring {
         dup affinagecoeff
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } {
         dup affinagecoeff solidaffinage
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } ifelse
      %% et il faut evider et coloriier l'interieur si necessaire
      solidhollow {
         dup videsolid
         activationgestioncouleurs {
            gsave
               dup  [fillincolor] (setrgbcolor) astr2str inputcolors
            grestore
         } if
      } if
      /activationgestioncouleurs false def
   } if
   tx@Dict /plansepare known {
      plansepare solidplansepare
      tx@Dict /plansepare undef
      tx@Dict /solidname known {
         solidname (1) append cvlit exch def
         dup solidname (0) append cvlit exch def
         %%
         solidname (1) append cvx exec
         solidhollow {
            dup videsolid
         } if
         activationgestioncouleurs {
            dup solidwithinfaces {
               gere_pstricks_color_inout 
            } {
               gere_pstricks_color_out
            } ifelse
         } if
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
         pop
         tx@Dict /solidname undef
      } {
         /solid1 exch def
         /solid2 exch def
      } ifelse
   } if
   solidhollow {
      dup videsolid
   } if
   activationgestioncouleurs {
      zcolor length 0 ne {
         dup zcolor tablez solidcolorz 
      } {
         dup solidwithinfaces {
            gere_pstricks_color_inout 
         } {
            gere_pstricks_color_out
         } ifelse
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
      } ifelse
   } {
      /activationgestioncouleurs true def
   } ifelse

   0 1 fcol length 2 idiv 1 sub {
      /i exch def 
      dup fcol 2 i mul get fcol 2 i mul 1 add get solidputfcolor
   } for
   vecteur_en_c@urs not {
      /lightsrc where {pop solidlightOn} if
   } {
      /vecteur_en_c@urs false def
   } ifelse
   dup action cvx exec
   noir
   solidnumf length 0 ne {
      solidnumf 0 get isstring {
         dup projectionsifacevisible solidnumfaces
      } {
         dup solidnumf projectionsifacevisible solidnumfaces
      } ifelse
   } if
   solidshow length 0 ne {
      solidshow 0 get isstring {
         dup solidshowsommets
      } {
         dup solidshow solidshowsommets
      } ifelse
   } if
   solidnum length 0 ne {
      solidnum 0 get isstring {
         .8 gere_pstfont
         dup solidnumsommets
      } {
         dup solidnum solidnumsommets
      } ifelse
   } {
      %% pop
   } ifelse
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def

/pst-octahedron {
   a newoctaedre
   gere_pstricks_opt
} def

/pst-dodecahedron {
   a newdodecaedre
   gere_pstricks_opt
} def

/pst-icosahedron {
   a newicosaedre
   gere_pstricks_opt
} def

/pst-cube {
   a
   ngrid length 1 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcube 
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-parallelepiped {
   a b c
   newparallelepiped
   gere_pstricks_opt
} def

/pst-tetrahedron {
   r newtetraedre
   gere_pstricks_opt
} def

/pst-tore {
   r0 r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtore
   gere_pstricks_opt
} def

/pst-sphere {
   % rayon
   % mode
  %   r {Mode} newsphere
   r
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newsphere
   gere_pstricks_opt
} def

/pst-cylindre {
   /save-cylinderhollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {axe} h ngrid newcylindre
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      newcylindre
      solidhollow {
         dup creusesolid
      } if
   } ifelse
   gere_pstricks_opt
   /solidhollow save-cylinderhollow store
} def

/pst-cylindrecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcylindre
   dup creusesolid
   gere_pstricks_opt
} def

/pst-cone {
   /save-conehollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {origin} ngrid newcone
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      solidhollow {
         newconecreux
      } {
         newcone
      } ifelse
   } ifelse
   gere_pstricks_opt
   /solidhollow save-conehollow store
} def

/pst-tronccone {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newtroncconecreux
   } {
      newtronccone
   } ifelse
   gere_pstricks_opt
} def

/pst-troncconecreux {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtroncconecreux
   gere_pstricks_opt
} def

/pst-conecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newconecreux
   gere_pstricks_opt
} def

/pst-anneau {
   [ section ]
   ngrid length 1 ge {
      [ngrid 0 get]
   } {
      [24]
   } ifelse
   newanneau
   gere_pstricks_opt
} def


/pst-prisme {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base decal rollparray
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   solidhollow {
      dup creusesolid
   } if
   gere_pstricks_opt
} def

/pst-prismecreux {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   dup creusesolid
   gere_pstricks_opt
} def

/pst-grille {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   newgrille
   gere_pstricks_opt
} def

%% syntaxe : array N h u newruban -> solid d axe (O, u),
/pst-ruban {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   h axe 
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newruban
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottesphere {
   % rayon
   % mode
   % r phi theta option newcalottesphere
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newcalottespherecreuse
   } {
      newcalottesphere
   } ifelse
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottespherecreuse {
   % rayon
   % mode
   % r phi theta option newcalottespherecreuse
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcalottespherecreuse
   gere_pstricks_opt
} def

/pointtest{2 2 2} def

/pst-face {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   solidbiface {
      newbiface
   } {
      newmonoface 
   } ifelse
   gere_pstricks_opt
} def

/pst-Surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   {f} newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   { function cvx exec } newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-polygoneregulier {
   r ngrid 0 get
   newpolreg
   solidbiface {
   } {
      dup 1 solidrmface
   } ifelse
   gere_pstricks_opt
} def

/pst-fusion {
1 dict begin
   /activationgestioncouleurs false def
   /n base length def
   base aload pop n 1 sub {solidfuz} repeat
   gere_pstricks_opt
end
} def

/pst-new {
   sommets faces
   generesolid
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-courbe {
   solidlinewidth setlinewidth
   r 0 eq {
      range aload pop function cvx [resolution] newcourbe
      gere_pstricks_opt
   } {
      range aload pop function r
      ngrid length 2 lt {
         [300 4]
      } {
         ngrid
      } ifelse
      newtube
      gere_pstricks_opt %% r function [36 12] newtube
   } ifelse
} def

/pst-surfaceparametree {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurfaceparametree
   dup videsolid
   gere_pstricks_opt
} def

/pst-surface* {
   r
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurface*
   dup videsolid
   gere_pstricks_opt
} def

/pst-vecteur {
gsave
   /activationgestioncouleurs false def
   /vecteur_en_c@urs true def
   solidlinewidth setlinewidth
   2 setlinejoin
   1 setlinecap
   linecolor
   linestyle
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
   args definition cvx exec newvecteur
   dup
   gsave
      [linecolor currentrgbcolor] ( ) astr2str (setrgbcolor) append 
      outputcolors
   grestore
   gere_pstricks_opt
grestore
} def

%/pst-vect- {} def
%/pst-vect-2points {vecteur3d} def
/pst-line {
   gsave
      linestyle 
      linecolor
      [args] ligne3d
   grestore
} def

/pst-objfile {
   solidfilename newobjfile
   gere_pstricks_opt
} def

/pst-offfile {
   solidfilename newofffile
   gere_pstricks_opt
} def

/pst-datfile {
   solidfilename readsolidfile
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-plantype {
%   args definition
   args (pst-plan-) definition append cvx exec
   dup phi rotateplan
   base length 4 eq {
      dup base planputrange
   } if
   origin eqpl@n pointeqplan 0 eq {
      dup origin planputorigine
   } if
   ngrid length 0 ne {
      dup ngrid planputngrid
   } if
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def
/pst-plan- {pst-plan-plantype} def

%x0 y0 z0 [normalvect] norm2plan
/pst-plan-plantype {
   dup plan2eq /eqpl@n exch def
   /plan-@k true def
} def

/pst-plan {
%   args definition
   args (pst-plan-) definition append cvx exec
   /pl@n-en-cours true def
   definition length 0 ne {
%   plan-@k not {
      dup
      base 0 get base 1 get lt
      base 2 get base 3 get lt and {
         base
      } {
         [-3 3 -2 2] %pop base %aload pop boum
      } ifelse
      planputrange
      origin eqpl@n pointeqplan 0 eq {
         dup origin planputorigine
      } if
      CX isreal
      CX 0 eq and
      CY isreal and
      CY 0 eq and
      CZ isreal and
      CZ 0 eq and not {
         dup CX CY CZ planputorigine
      } if
      /CX 0. def
      /CY 0. def
      /CZ 0. def
      ngrid length 0 ne {
         dup ngrid planputngrid
      } if
   } if
%   dup RotX RotY RotZ rotateOplan
   dup phi rotateplan
   /l@pl@n exch def
   tx@Dict /solidname known {
      l@pl@n solidname cvlit exch bind def
      /solidname solidname (_s) append store
   } if
   l@pl@n newplan
   gere_pstricks_opt
   /pl@n-en-cours false def
%   action ==
%   noir
   l@pl@n RotX RotY RotZ rotateOplan
%   l@pl@n CX CY CZ plantranslate
%   fontsize setfontsize
%   setTimes
   1 gere_pstfont
   solidplanmarks {l@pl@n projectionsifacevisible planmarks} if
   solidplangrid {linecolor l@pl@n projectionsifacevisible planquadrillage} if
   solidshowbase {l@pl@n projectionsifacevisible planshowbase} if
   solidshowbase3d {l@pl@n projectionsifacevisible planshowbase3d} if
} def


/pst-plan-normalpoint {
   /plan-@k false def
   norm2plan
   dup plan2eq /eqpl@n exch def
} def

/pst-plan-equation {
   /plan-@k false def
   dup isarray {
      dup /eqpl@n exch def
   } {
      2 copy pop /eqpl@n exch def
   } ifelse
   eq2plan 
} def

/pst-plan-solidface {
   /plan-@k false def
   solidface2plan
   CX isreal
   CX 0 eq and
   CY isreal and
   CY 0 eq and
   CZ isreal and
   CZ 0 eq and not {
      dup CX CY CZ planputorigine
   } if
   
%   dup plangetrange aload pop boum
%   dup origin planputorigine
   dup plan2eq /eqpl@n exch def
} def

/pst-geode {
   ngrid aload pop newgeode
   gere_pstricks_opt
} def

/pst-load {
   solidloadname 
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-point {
gsave
   linecolor
   1 gere_pstfont
   action (none) eqstring not {
      args definition cvx exec point3d
   } if
   texte args definition cvx exec pos (text3d) append cvx exec
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
grestore
} def

%% syntaxe : alpha beta r h newpie --> solid
/pst-pie {
   phi theta r h 
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } if
   newpie
   gere_pstricks_opt
} def

/pst-trigospherique {
3 dict begin
gsave
   solidlinewidth setlinewidth
   linecolor
   linestyle
   args definition cvx exec
grestore
end
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         procedures pour \psProjection              %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/gere_pstricks_proj_opt {
      /planprojpst where {
         pop
         planprojpst projectionsifacevisible projpath
%        /planprojpst where pop /planprojpst undef
      } {
         /solidprojname where {
            /solidprojname get noface phi  
            xorigine 0 eq
            yorigine 0 eq and
            zorigine 0 eq and 
            xorigine isinteger not and
            yorigine isinteger not and
            yorigine isinteger not and {
            } {
               [xorigine yorigine zorigine] (                 ) astr2str 
            } ifelse
            projectionsifacevisible solidprojpath
         } {
            xorigine yorigine zorigine [ normale ] projectionsifacevisible planprojpath
         } ifelse
      } ifelse
} def

/proj-pst-chemin {
   solidlinewidth setlinewidth
   1 dict begin
   newpath
      /cercle {cercle_} def
      path
      linecolor
      gere_pstricks_proj_opt
   end
} def

/proj-pst-courbeR2 {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop { function cvx exec } CourbeR2_
      gere_pstricks_proj_opt
} def

/proj-pst-courbe {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop {} { function cvx exec } Courbeparam_
      gere_pstricks_proj_opt
} def

/proj-pst-point {
   [proj-args] length 0 eq {
      xorigine yorigine /proj-args defpoint
   } if
   /projname where {
      pop
      [proj-args proj-definition cvx exec]
      dup 0 getp projname cvlit defpoint
      dup length 2 gt {
         1 getp projname (0) append cvlit defpoint
      } if
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      solidlinewidth setlinewidth
      linecolor
      [proj-args proj-definition cvx exec] 0 getp point_
      gere_pstricks_proj_opt
      Stroke
   } if
%   1 1 0 0 1 1 Diamond
   texte length 0 gt {
      proj-fontsize setfontsize
      %setTimes 
      solidlinewidth setlinewidth
      newpath
      linecolor
      texte [proj-args proj-definition cvx exec 0 0 phi neg rotatepoint] 0 getp 
      pos (text_) append cvx exec
%%    /planprojpst where {
%%       planprojpst dupplan dup phi rotateplan /planprojpst exch def
%%       pop
%%       xorigine yorigine
%%       0 0 phi neg rotatepoint
%%    } {
%%       0 0
%%    } ifelse
      %gere_pstricks_proj_opt
      planprojpst dupplan dup phi rotateplan projectionsifacevisible projpath
      Fill
   } if
} def

/proj-pst-vecteur {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      xorigine yorigine 2 copy proj-args proj-definition cvx exec addv drawvecteur
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defpoint
      /projname where pop /projname undef
   } if
} def

/proj-pst-droite {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan smoveto
%% 	 planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec droite
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defdroite
      /projname where pop /projname undef
   } if
} def

/proj-pst-polygone {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
      newpath
         xmin ymin l@pl@n pointplan smoveto
         xmin ymax l@pl@n pointplan slineto
         xmax ymax l@pl@n pointplan slineto
         xmax ymin l@pl@n pointplan slineto
         xmin ymin l@pl@n pointplan slineto
	 planprojpst projpath
      clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec polygone_
      planprojpst projectionsifacevisible projpath
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-cercle {
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defcercle
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%% 	 planprojpst projpath
%%       clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      newpath
      range aload pop proj-args
      proj-definition cvx exec Cercle_
      planprojpst projectionsifacevisible projpath
   } if
} def

/proj-pst-line {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%%          planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec ligne
      eprojscene
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-rightangle {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec angledroit
      eprojscene
   } if
} def

/proj-pst-texte {
2 dict begin
   proj-fontsize setfontsize
   %setTimes
   1 gere_pstfont
   solidlinewidth setlinewidth
   newpath
   linecolor
   texte 
   /planprojpst where {
      planprojpst dupplan dup phi rotateplan /planprojpst exch def
      pop
      xorigine yorigine
      0 0 phi neg rotatepoint
   } {
      0 0
   } ifelse
   pos (text_) append cvx exec
   gere_pstricks_proj_opt
Fill
end
} def

% END solides.pro

%%EndProcSet
%%BeginProcSet: texnansi.enc 0 0
% @psencodingfile{
%   date = "22apr09",
%   filename = "texnansi.enc",
%   email = "tex-fonts@tug.org",
%   author = "Y&Y, Inc.",
%   version = "1.1",
%   codetable = "ISO/ASCII",
%   docstring = "texnansi (aka LY1) encoding vector for Type 1 fonts to
%                be used with TeX, following ASCII and Windows ANSI."
% }
%
% The idea is to have all 228 characters normally included in Type 1 text
% fonts (plus a few more) available for typesetting.  This is effectively
% the character set in Adobe Standard Encoding, ISO Latin 1, plus a few more.
%
% Character code assignments were made as follows:
%
% (1) The character layout largely matches `ASCII' in the 32 -- 126 range,
% except for `circumflex' in 94 and `tilde' in 126, to match `TeX text'
% (`asciicircumflex' and `asciitilde' appear in 158 and 142 instead).
%
% (2) The character layout matches `Windows ANSI' in almost all places,
% except for `quoteright' in 39 and `quoteleft' in 96 to match ASCII
% (`quotesingle' and `grave' appear in 129 and 18 instead).
%
% (3) The character layout matches `TeX typewriter' used by CM text fonts
% in most places (except for discordant positions such as hungarumlaut
% (instead of braceright), dotaccent (instead of underscore) etc.
%
% (4) Remaining characters are assigned arbitrarily to the `control character'
% range (0 -- 31), avoiding 0, 9, 10 and 13 in case we meet dumb software
% - similarly one should really avoid 127 and 128 if possible.
% In addition, the 8 open slots in Windows ANSI between 128 and 159 are used.
%
% (5) Y&Y Lucida Bright includes some extra ligatures and such; ff, ffi, ffl,
% and `dotlessj,' these are included 11 -- 15, and 17.
%
% (6) Hyphen appears both at 45 and 173 for compatibility with both ASCII
% and Windows ANSI.
%
% (7) It doesn't really matter where ligatures appear (both real, such as ffi,
% and pseudo such as ---) since these should not be accessed directly, only
% via ligature information in the TFM file.
%
% SAMPLE USAGE (in `psfonts.map' file for DVIPS):
% 
% lbr LucidaBright "TeXnANSIEncoding ReEncodeFont" <texnansi.enc <lbr.pfb
%
% This tells DVIPS that the font called `lbr' in TeX has PostScript 
% FontName `LucidaBright.'  It also asks DVIPS to expand the file `lbr.pfb'
% into PFA form, to include the attached `texnansi.enc' encoding vector,
% and to then actually reencode the font based on that encoding vector.
%
% Revised 2009 April 20 with doc changes only (Uni20AC -> uni20ac).
% Revised 2009 March 9 with doc changes only.
% Revised 1996 June 1 by adding second position for `fl' to avoid Acrobat bug.
% Revised 1996 June 1 by adding second position for `fraction' for same reason.
% Revised 1997 Oct 1 by adding cwm (used in boundary char TFM code).
% Revised 1998 Mar 1 by adding Unicode for Euro character.
% emacs-page
% 
/TeXnANSIEncoding [     % now 256 chars follow
/.notdef                % 0x00 0
/Euro                   % 0x01 1 /uni20AC
/.notdef                % 0x02 2
/.notdef                % 0x03 3
/fraction               % 0x04 4
/dotaccent              % 0x05 5
/hungarumlaut           % 0x06 6
/ogonek                 % 0x07 7
/fl                     % 0x08 8
/.notdef                % 0x09 9 /fraction at 4, backward compatibility only
/cwm                    % 0x0A 10 not used, except boundary char internally
/ff                     % 0x0B 11
/fi                     % 0x0C 12
/.notdef                % 0x0D 13 /fl at 8, backward compatibility only
/ffi                    % 0x0E 14
/ffl                    % 0x0F 15
/dotlessi               % 0x10 16
/dotlessj               % 0x11 17
/grave                  % 0x12 18
/acute                  % 0x13 19
/caron                  % 0x14 20
/breve                  % 0x15 21
/macron                 % 0x16 22
/ring                   % 0x17 23
/cedilla                % 0x18 24
/germandbls             % 0x19 25
/ae                     % 0x1A 26
/oe                     % 0x1B 27
/oslash                 % 0x1C 28
/AE                     % 0x1D 29
/OE                     % 0x1E 30
/Oslash                 % 0x1F 31
/space                  % 0x20 32 /suppress in TeX text
/exclam                 % 0x21 33
/quotedbl               % 0x22 34 /quotedblright in TeX text
/numbersign             % 0x23 35
/dollar                 % 0x24 36
/percent                % 0x25 37
/ampersand              % 0x26 38
/quoteright             % 0x27 39 /quotesingle in ANSI
/parenleft              % 0x28 40
/parenright             % 0x29 41
/asterisk               % 0x2A 42
/plus                   % 0x2B 43
/comma                  % 0x2C 44
/hyphen                 % 0x2D 45
/period                 % 0x2E 46
/slash                  % 0x2F 47
/zero                   % 0x30 48
/one                    % 0x31 49
/two                    % 0x32 50
/three                  % 0x33 51
/four                   % 0x34 52
/five                   % 0x35 53
/six                    % 0x36 54
/seven                  % 0x37 55
/eight                  % 0x38 56
/nine                   % 0x39 57
/colon                  % 0x3A 58
/semicolon              % 0x3B 59
/less                   % 0x3C 60 /exclamdown in Tex text
/equal                  % 0x3D 61
/greater                % 0x3E 62 /questiondown in TeX text
/question               % 0x3F 63
/at                     % 0x40 64
/A                      % 0x41 65
/B                      % 0x42 66
/C                      % 0x43 67
/D                      % 0x44 68
/E                      % 0x45 69
/F                      % 0x46 70
/G                      % 0x47 71
/H                      % 0x48 72
/I                      % 0x49 73
/J                      % 0x4A 74
/K                      % 0x4B 75
/L                      % 0x4C 76
/M                      % 0x4D 77
/N                      % 0x4E 78
/O                      % 0x4F 79
/P                      % 0x50 80
/Q                      % 0x51 81
/R                      % 0x52 82
/S                      % 0x53 83
/T                      % 0x54 84
/U                      % 0x55 85
/V                      % 0x56 86
/W                      % 0x57 87
/X                      % 0x58 88
/Y                      % 0x59 89
/Z                      % 0x5A 90
/bracketleft            % 0x5B 91
/backslash              % 0x5C 92 /quotedblleft in TeX text
/bracketright           % 0x5D 93
/circumflex             % 0x5E 94 /asciicircum in ASCII
/underscore             % 0x5F 95 /dotaccent in TeX text
/quoteleft              % 0x60 96 /grave accent in ANSI
/a                      % 0x61 97
/b                      % 0x62 98
/c                      % 0x63 99
/d                      % 0x64 100
/e                      % 0x65 101
/f                      % 0x66 102
/g                      % 0x67 103
/h                      % 0x68 104
/i                      % 0x69 105
/j                      % 0x6A 106
/k                      % 0x6B 107
/l                      % 0x6C 108
/m                      % 0x6D 109
/n                      % 0x6E 110
/o                      % 0x6F 111
/p                      % 0x70 112
/q                      % 0x71 113
/r                      % 0x72 114
/s                      % 0x73 115
/t                      % 0x74 116
/u                      % 0x75 117
/v                      % 0x76 118
/w                      % 0x77 119
/x                      % 0x78 120
/y                      % 0x79 121
/z                      % 0x7A 122
/braceleft              % 0x7B 123 /endash in TeX text
/bar                    % 0x7C 124 /emdash in TeX test
/braceright             % 0x7D 125 /hungarumlaut in TeX text
/tilde                  % 0x7E 126 /asciitilde in ASCII
/dieresis               % 0x7F 127 also at 168
/Lslash                 % 0x80 128 position is unfortunate, but too late to fix
/quotesingle            % 0x81 129
/quotesinglbase         % 0x82 130
/florin                 % 0x83 131
/quotedblbase           % 0x84 132
/ellipsis               % 0x85 133
/dagger                 % 0x86 134
/daggerdbl              % 0x87 135
/circumflex             % 0x88 136
/perthousand            % 0x89 137
/Scaron                 % 0x8A 138
/guilsinglleft          % 0x8B 139
/OE                     % 0x8C 140
/Zcaron                 % 0x8D 141
/asciicircum            % 0x8E 142
/minus                  % 0x8F 143
/lslash                 % 0x90 144
/quoteleft              % 0x91 145
/quoteright             % 0x92 146
/quotedblleft           % 0x93 147
/quotedblright          % 0x94 148
/bullet                 % 0x95 149
/endash                 % 0x96 150
/emdash                 % 0x97 151
/tilde                  % 0x98 152
/trademark              % 0x99 153
/scaron                 % 0x9A 154
/guilsinglright         % 0x9B 155
/oe                     % 0x9C 156
/zcaron                 % 0x9D 157
/asciitilde             % 0x9E 158
/Ydieresis              % 0x9F 159
/nbspace                % 0xA0 160 no break space
/exclamdown             % 0xA1 161
/cent                   % 0xA2 162
/sterling               % 0xA3 163
/currency               % 0xA4 164
/yen                    % 0xA5 165
/brokenbar              % 0xA6 166
/section                % 0xA7 167
/dieresis               % 0xA8 168
/copyright              % 0xA9 169
/ordfeminine            % 0xAA 170
/guillemotleft          % 0xAB 171
/logicalnot             % 0xAC 172
/sfthyphen              % 0xAD 173 /hyphen (hanging hyphen)
/registered             % 0xAE 174
/macron                 % 0xAF 175
/degree                 % 0xB0 176
/plusminus              % 0xB1 177
/twosuperior            % 0xB2 178
/threesuperior          % 0xB3 179
/acute                  % 0xB4 180
/mu                     % 0xB5 181
/paragraph              % 0xB6 182
/periodcentered         % 0xB7 183
/cedilla                % 0xB8 184
/onesuperior            % 0xB9 185
/ordmasculine           % 0xBA 186
/guillemotright         % 0xBB 187
/onequarter             % 0xBC 188
/onehalf                % 0xBD 189
/threequarters          % 0xBE 190
/questiondown           % 0xBF 191
/Agrave                 % 0xC0 192
/Aacute                 % 0xC1 193
/Acircumflex            % 0xC2 194
/Atilde                 % 0xC3 195
/Adieresis              % 0xC4 196
/Aring                  % 0xC5 197
/AE                     % 0xC6 198
/Ccedilla               % 0xC7 199
/Egrave                 % 0xC8 200
/Eacute                 % 0xC9 201
/Ecircumflex            % 0xCA 202
/Edieresis              % 0xCB 203
/Igrave                 % 0xCC 204
/Iacute                 % 0xCD 205
/Icircumflex            % 0xCE 206
/Idieresis              % 0xCF 207
/Eth                    % 0xD0 208
/Ntilde                 % 0xD1 209
/Ograve                 % 0xD2 210
/Oacute                 % 0xD3 211
/Ocircumflex            % 0xD4 212
/Otilde                 % 0xD5 213
/Odieresis              % 0xD6 214
/multiply               % 0xD7 215 OE in T1
/Oslash                 % 0xD8 216
/Ugrave                 % 0xD9 217
/Uacute                 % 0xDA 218
/Ucircumflex            % 0xDB 219
/Udieresis              % 0xDC 220
/Yacute                 % 0xDD 221
/Thorn                  % 0xDE 222
/germandbls             % 0xDF 223
/agrave                 % 0xE0 224
/aacute                 % 0xE1 225
/acircumflex            % 0xE2 226
/atilde                 % 0xE3 227
/adieresis              % 0xE4 228
/aring                  % 0xE5 229
/ae                     % 0xE6 230
/ccedilla               % 0xE7 231
/egrave                 % 0xE8 232
/eacute                 % 0xE9 233
/ecircumflex            % 0xEA 234
/edieresis              % 0xEB 235
/igrave                 % 0xEC 236
/iacute                 % 0xED 237
/icircumflex            % 0xEE 238
/idieresis              % 0xEF 239
/eth                    % 0xF0 240
/ntilde                 % 0xF1 241
/ograve                 % 0xF2 242
/oacute                 % 0xF3 243
/ocircumflex            % 0xF4 244
/otilde                 % 0xF5 245
/odieresis              % 0xF6 246
/divide                 % 0xF7 247 oe in T1
/oslash                 % 0xF8 248
/ugrave                 % 0xF9 249
/uacute                 % 0xFA 250
/ucircumflex            % 0xFB 251
/udieresis              % 0xFC 252
/yacute                 % 0xFD 253
/thorn                  % 0xFE 254
/ydieresis              % 0xFF 255 germandbls in T1
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end
%%BeginFont: MathDesign-UT-Regular-Symbol-10
%!PS-AdobeFont-1.0: MathDesign-UT-Regular-Symbol-10 1.51
%%CreationDate: Sat, 28 Jan 2006 18:52:21
9 dict begin
/FontInfo 10 dict dup begin
/Version (1.51) readonly def
/Notice ((c) 2004 Paul Pichaureau, under the gpl licence.) readonly def
/FullName (MathDesign UT Regular Symbol 10) readonly def
/FamilyName (MathDesign-UT) readonly def
/Weight (Regular) readonly def
/ItalicAngle 12 def
/IsFixedPitch false def
/UnderlinePosition -98 def
/UnderlineThickness 54 def
end readonly def
/FontName /MathDesign-UT-Regular-Symbol-10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /minus put
readonly def
/PaintType 0 def
/StrokeWidth 1 def
/FontType 1 def
/FontMatrix [0.001000 0.000000 0.000000 0.001000 0.000000 0.000000] readonly def
/FontBBox {-16 -1340 1249 951} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC4458BF85598BFFB688F90ED6A048EF34
1E514EB44F263B92302DA62E5D3E0E80DAA99252B0357D057396EB1F16BC20C2
D373CE5AD9C56779F676BE22DD8B5E288823824D460C36D4675A1E5FDDA0BFCA
B18C8EF171F0C7D70A7CE68FE415C852A99C172F20DF292CC04BE996D4D7E022
85BEA198A6A52B56E0D4A7AA76546CAE6E95496F58EF2373667756E9DB93E0C6
5F643442DC11AFFCFED478779F29D2E33FCFFB4AF8BBD57E02657B9481BFFB76
419D6BDEA07299407C5A881A239D065155AAD93DD443A2F5A63DA4B93CF868CC
4092E4018E1381462D1ACAE0FF3C0692AEA4B8DFBBC61B2519EF67131E60BCBD
D4197F3167E18F8337DF38FB55AD92A0732902C03D0477E855CE2D203EB62C5C
308E2D3989D7F942511B655539B135ACDCB76F20282F4EBB3ADE84A391D18AB8
629ABF5C341D148F9BEFB6DDA4128F9A27596E424D25A1A40E70E9A649A5EB75
1ACD3769AD2863E96862BF27530FDCFB9EADD44A87245F13E3B5CE357DD45528
CC07DD34B805C7C5DB3988BE96F467767F57010FAC8F11C8DFF34B5BB2F5DA19
82ABA1F350962917CCCE3754B2B66B0F747BE1288E39D6DF4087336D241E859B
BFE1A7F5121334AEFFDFE19282A2D901819A69CD0FBBA5114E8D5DAE15635651
F2024BF153159D4814E01DB13BBE5B30F1432EE9FB90C38D56AD2A908FDEC9FA
2F535FCDB34CB18D629DC7765B3981D35F35F8B343A677B7BAA0718BC6A6C861
D4264A15F31CD5D3A1712D61DEC88A462362736726309D3C7CA0F91342A1B59A
1B4A0FD09BA84709B66027DED3255F1428C66A14CD6A17F06CC216B2212EFF48
EB9FD25265774FF0C4EDDF26F4E4808CE7FFF5E06886827C5AA50D10E0CFC750
EFD13C10CE309022DC25A63294CC15808974C2D25CDD52A76A5608D21737C613
F1D92DFA645BB095635A2FEC39E0DFE17F5EA33F99D95CAE36CE9E768DDC07EE
5912DE11D07676C5C574B36F319243D6F681AA7E43B89729C75DBCE74179F941
07F9951E478E3ACD7CC3DCDD1E246800D22477A94A889128B5009CC964B16EF5
DE1EF8E472157FD8BDAFAA3F14C53FD878F80BC0A79D576941DC1780BB7EE442
4E17A533EF44942CEA21C149DC01B9D816CCC79B09A04CE6D8751F8CFDE8B0E3
833551E78EAE380960D098510F46B4CD276B00CF0D56E70618DFC4D3EBE88134
5C6B7AE262304E8385ECB2B1E2965118C057515B1EE31660B762196BDACA7A1D
187FA44AEF847F0C2F956BA1A8B0EDDE916E77D53634C137AEEA38805C9475D2
A5F9EE021B2226011209AB94F1A922492234F2AB6E03A62FC3E0C50F55A84F73
AE82AA9B11484D9D6F8B66D150593476FD86671DFF6EA0954CD06EE2B49D86DE
98F2C960EDAC5058C9D407E7CFDFB2332F6230340080AFC09139A9475B0BB200
6F9112209530A35F001E1F8C99D8F72876F48A80115EA2D190D913CCB4602630
37DC3DFB321F8AB0B0BD19E492BD69177FE94D14189B05070C12A930D2845C60
F20FA70FE6C7F5BD2114D414EA65598226876EEB5650651A9ED44E6FBFCB61CD
C3CD756F218941FB1CD021BFE7689D951CDC37053E9C26A6F19E7266FB50BD5D
7E63D0B5695AA170D6191DA9E25A6E760BFE85BAE946B0978F2C5FB8
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC335F6B5DE8C00317AC6EE
983987246EB7659537AD0F945CEB9EAC541E02AE257377258E81CFE33CB66A9B
EB514F04CA9AB516CCAFE56EB0324AB192EBDDA61E0792EC1857BCC062666338
0089C3A9FDEB405DCF235A497AC316B132B3476551DCEBA0560C18F1BF84F1E0
1467DE59252B169861541BD6774161EA8F9035787CA842050E2089AAEED6F37B
2D12BCF5E67293A1F71DF87589FD22D5F72B9C91CCF4019F97356DEBC9B82C93
BD0040BBCEB10CF8F607E0F7863C43D7F6A91917EBD66730DBD642DAB8769849
47384FFFB4994ECF216FFA8140397695EE5AD63F1156720A01BBFB15AA24FDB8
2F2A8F541C7FC860E03F5E4DE80BCF6891263C142159D5879CA0A1883A9B6C50
CBDA9CF0C97E761E354C39527F070E680B42E6732896B10E6A7600184B156ACF
57BD9A98F613FC166F47C3D1C4E5E02BAB648D74B078EE3F0D8148D981451BD3
918C71284E6154BEDF8D66BA1261A7459F64F133445F9BE19A2C48B1FE1D06B1
845AB18E2E5C17B77C48FBAE7AA98424BA0F90F689216F31EFABC25D4EC37767
C5A4BD9210AB9F0D3385717E8980C7F6C021061CC213ECEDD34548605F3FF29F
B92FEF1C849AFF8AD297F7A4259C35B7B9B679A509FB97F10F2BA3521085B1D5
104D43AFAED420272E0DB15AAF65567BAB2B030932584E4DE6150645266166F9
0B425322481A2BBB01ECAD3E011D365BE2C51E7612B0969A218662A8F3154F6D
56FACD9D11622AFBE969803421F6C2614896A0C03C341334FA8107BADB87B94F
160A7C59ACEEC8AEDD38E5A3DC178A67A00DF37806BDA55B79CD9D2D26A22AAB
35C0BDAF27422A084E2950E90E37F7B347B28EFCB28BE019FB924B0583462D8F
44FF2045DC65CA3C0F7C8169C6F76D8CADAFA86782ADF1D8B89C3A32EFA39C9D
654A6CBFF8C2B2319440728B74EBDBE7A952FA584C475CEE1BB7128A8E143C89
3E933FF2AAEF340EA1D0794EC48800B64C7682FAB484948D1AB28292C31ADA55
12256946F41A6A9F0A54178AE5A5DEBC033F675E2D9F0691C1D8993B422BB3D4
1222D40754524F4550C07AA2B7E4F1CF360FE98885DD6AEA8EEC99E208991584
85E0D8BBD44659B72F57E4B64198FD91DF08CFF41516112ACB0A383AF517A423
682A1F2EB1D8CF4F650EB4C109E377B9C011F1860F37C8C940A8EA49D8407CA5
E0EB5A9E92CEDBEE598F0940C1B4A46F9C9978033BE9C48BC3221F90B360E436
10FC36DEB929C1C2F3FF4BBCD9710D99C67356C48B90339D7A5F655AB097B986
6B7432798CB5140001C6F2EF679B5DA0D5AC832E4E047782B4548BCFED0BF7FC
61A6667E81A66D846705C54EA10FFB437E128153501E8CFE1B83A31891B7C5CA
83BABE929D4D73AC4B3377F9FD1EB0DF383B71E6EEBCAC80D48752B7615C06F2
4ECB073936A0F2BDDCC09B6D128EA4C5C917A33106F6FC3095829A5C77E96617
3854ABE9A368F7267FB14A88BF1A14B1BCD29FB90ED5C55AD867DA9DAFDF97BD
FDFC8825930D83893081E270D30ED24288BDF3231E4491254E60BFECF590D052
BFA04AA0012489E24F574DC3CF56974FB890449137A40EF3291D2E37D63E97E2
08C4A7CE56EC4F6A9385C25C12C71A48581C9B185A7586B6E51FC76E400A154D
EA6D7E86BA6347E0F8B05520ED2B0E9DEB88A2135A2EF4D2AB851418EFAAA132
7513566F4B10B2A8AB9C41181A1A4443DEEBCA9AAEC824CD992A70427B955BD9
19525DABA47949CFB167C4AF13A8742D2137079582241EE8A86B46A4357BAB42
4211708954BF392AB8D9B3C9526E2AEA33D769A6AFD69DFB334F8563E893FC2A
395249BE421C0A02C52F158A507CB63BC616BA3BE12F0358907DF9D9F2DF64B3
A6D079E667C60F149DBC8AB883201544DC7A3DA9EF403264B18307C8BCD68799
3F985647B99C91558DB88DAC6BF01F86B310432FBCD338CC17E17E0CA6F062C7
0246081A7096D517685C33D4EE9F97D3671929234213B3E8BE62FBE6170F755E
15A5B24FCFDC97A92DA4C24B5910F26394DEA30F975A696586A92E10FB0C86C8
D8E7AA48C0A49EF488BEE9F40DF393CAF0C2E9EA10B3EB5EA8CEAD375AEE157B
AE23258366C714EC9E59808C9BDA31E482747793BF33ED8C930CEBA25B9B4730
F14A596C1CD1B4B5CCEDE291CE3AFB7AA3B19AADA357918F3E2CB23F78A974D5
AF16BB30E14B4B79DD99C57FCAAF1A9A374C68B7FF77D030FB6349CFCF86E87C
B9D61C5F5EB5D874CF6FFB01E4432BE6C56F0E86CE9CF861290722639E9C6D45
47263F60381EDFDB8CCDDE45B5A2BDF25C27B13F88DE063CC0E2012AC1D5881E
724640B641DAD2C729FCCD36739567058F386430185B0C30B898886C10260620
73888091934F3D69DB72800D0C3C08B02E38324B3E71305AB9DE78C1D3A461F1
F354E125B561FCD30838615DB8878AFFC924D1098D2C73BBD898984313690F83
1AC1389C5A37BF3CF44BB9794148425A471A6E1D4CA1B2195E1BFAF29317009B
C9B16FEF75ECEBCD06E639D1F5D8828C75326B15A05CC7732DF5B4B1A8258970
D3DB0BCE113A6A72AA2CE5C8CFFA67B118CE009DFD6B727FE4665832033F0ECA
133567D66FE5ACB020A85995058B49A351782108203A45C3E22E32146AA196B3
12163570DD778E06BDDA240904A42E98E77155B04121E1D8A5B8360E99F8668A
BDB27598E5ECC4B00371327D880C2401EC48E074F448225851BB87C1373D8038
D81E5F9E3051ABBC4379814A275DDBD917DFE099FB32BF02B76E838C1DEEC722
E9E2439E296B4392AAF11143DF1139C7B56BE24CD65E48B0228CAFE35B05E427
97FCC5A2BC91E8EEAA999045DB364BC3C8794BDDE54020E7694CFA9DF137D9FD
45BDA3B91E4D1129D696AE5BC78EEA536ABB26FC603D3AB7CC8FCAE1177EE978
CF04EA9D5B610842F5A1990B82EE45D812CEDF97D528ADB4433E5C16881477CE
8BDF622FC8175F0DFF52A5BBF8F08C05E9DFAF70088E03157F97D1A97624C5C3
2719B43C98E41FE55394A47B2E396323BA7E5F5352E9195FABD598D55B0A89C5
8617FA9E9875BD3E8CBBABC96BD8C65B35F52B949B410EA7FBC6DD1952560235
DAFB4E2A47E726F3D1E9D320A5DB1F926D07F2844675CD61459CFAC2480FCE06
1079286DF9D7B4A8DEE4B1D93295E050A7A17A9C5C5673B88D224A18575C4BEA
ADB5782A1DFFFBA5049FC8D61AE413B927C0274368FB343E10DAA95B59E97605
981BE69A5BF653B114D8E4CE7774D566300720A48801B4B7F4E39A5B32C81FB9
1BB31F774F8CB1F07D66411593D10A7A1363B1D336695D7ED2B1A30A3D296CAA
B4BF0459A4A8C040EAD6EC6CA0A6EE762C0B8F56A07C342F9DA251D6B882B221
B21C98D7122B989A3C2009AD369DE0BDAC0AFFCF149796A3707F23BC000DEC9D
93998941A908996F697A3CED7D6561B5432024B86AF032D5C59FF758C0F6FEA6
D193194DE9ED38599DB2A56E672EE5175A07123793DF4BEDC209B28C45AE5775
EFA9BB17B6E49EA1FB1A80C1B633B2A6EEC5E20FD77997C5FA638EB8189FAC73
29FEE2DB382D88DF769DAA3E7E0DE0D421F5372EC61D31A7B8A486080A147037
69F96EF2ADADBF729A09D1B8CBCB361B2D3F24C4839AAF3905B73C16EAE2BABD
240FC82B0B81E97C2A9BC2277C7B67D8C7A21123F35A2981E13A466FB2F8EC8E
4EB69B4ADCAC12A8495C5C443584203EFBBF994D02C1BD679471E99EEF409281
848E6FB91C81494D4AE7F58F3BF1B99A6D6E70C71A287DA34EBD4AF78A021F37
873BCEE4A521D0D060CD1AC2B10C67DA02AAFED53C1E19AFA0A4BB7B41919E84
6384818A44D7CD0470F350DA816D79E07962809EFFA023A3DFFDD38D8A182D99
B9525782DEDAB8AF8B5A3FB15D5725633072B651C69A8C3E5355FD40EDAADEA9
7C9E362C98ABB00474EA5AA40457B4A64742140C81DB516E547C662B898F6536
AFED2CBB0F21096E055603783278F4D94FFA70E5D586BFA98D829C777900CE67
B4729687ED614AA483E398E745721D701D8CFA1F636B0C9C7691424DFC32890B
85BAE715470BD76A43C1AB10952D47C6C269FE10B28F67E30FC03D09DE7F75CB
C100B70C4831961501DEEB7D8C869447ABA1ABBCD4488E8C67BFA26A17A74C88
A7E7708BF85AD1D1604C108FA05F069D6AE8869D16B5323942624E82FE3E98F2
6F8646785C73AFCBA91BBBFF80BCE2D5515C36F27E8A9E5B50725BAAF4184FAB
B849A355BDFDFB3E48820F1AA9A74CA1082C60195FA1EC258CC69754128BFC9E
5A301AE4F67D869689478C36961963B468EA89368E797AA3826435CFB2CD64CD
B2EFD7E802FE062ADAA363786E10343105E27D47F0624CFA11168403F65AC3E7
5EFCED6385B1EB6971F2EBCC3E5EECC5B61619C085A1653926A512683C6D610A
AB704403B7C69C7E835AD2CDC07950A47ED789C2AD9A8A8A509C2B7DD09AE6FF
2B32C1CD87CA8BC0696574C67B96311F8EFB98F98AB468AD485606D6F3B9C932
3A080ECAF450DB007C6248FF86DCDE299FC9762C4E07E5D9AD31138383BFE0A7
0B62E0B07C313A0400267A662FC62B6F46B18062A9AC9C7D63DFA8FDC2A66E77
E07E5CFC49BBE003C631D1908659E8C4EA4B47A3AF5B7879610B18F687A4709D
C35F594B1216C2D9C7685BB1B0B552EABCA71C83C0C4AB4BCAC76B5E9D25C54A
3367170624B73D5CCD46951D3FB6800D5D6BB761E3215CD1B5C54B826C79D6D1
302485DFE88C095D74A0C9B8A990E07E106F5E851476E437E8CC706BA4F193D6
CB6FECC6088C079213FCC511B62612EEEA9E3A365DBFBE957B48C03C0CE341C1
879441A81C2BAA46ABFC1D6F293AADDAD8F4ED8C020C022A6D1B02B0ED350E58
ECA8C4A9EE0B5DCE101093B4528161410E7BE6BF7928523F98B5DD223E5C6F0F
F3D683011C316FB5446A9665CE1F0BA507011DABF4176A2E1C51A0A0861E90E5
32295AFBF77B92FD1D07921E828D5EC2B96E2B74906DF93024F445F337A37A07
735A36737CAB3F934C88858C9DECA5F471524FEE970A2B5E013E111D865BBD9A
10284959153EFCD2E056707765AEFF84A0360B28CF7A316C95F9762ECB5E7566
E858B2CC7CEFD34C4EF05B432C7E75B0D7153B88B585A260DC7AB5A603DB8877
56079A74A26C332D36B70B46A146A7D6BC6579118AC26F621DF51A76E580A496
B1062FE9A56C338ED5FBF1B52545C588605739C74104E048D8237FC68CAB8952
CFD88E031797BC79F33E07B3159F56CC2695CB2277C5244A8963398340477402
CA73FDA5992304E474560DFE1D95938A10562480BA0819A187F188EAD267A9D5
80B87CA561FA7247AF41589023A72FA7A271EB6F0D150FA435EF6A4E52A5A743
87FBFE762B85987F0096C2F3E490E510C478B7F8D9A5509FD88EF8BBEF1B0766
0747BF6D8E48A4D99845A65BAEF652CF4FBD307DB3CFD49CAE68841183ABD7EF
DA3B1C4E79B498440BA995291CE6E759A2BBCA40C82366A40C5371DE5D07EF91
9A938F23142BB074DCC987FCBD46714EEDA34D5883BD5B92A62701259915BC14
8498F04F23FF1E374A4863D4E5CD2208915F105BA9BFB193030B7A402CE1067D
1DEF81F110CBB181C007B3538E15B9C288B5D1D66B6F874B9D6AC543B626B676
1AA791766B4F3A3CBA29FBD8888831119F214E508626FF33812B15D01850C861
07A734449C3B34DAED04AB6EF99A3520D008408E54A4C3E1517463D97883B4CF
601F6FB397705560A2B7D5704BF556C274C0FA9C3A91607ED5D328296FBCCAD5
47AD6861D3873CC2F169B785AB3BC1D9CB8A2FF66653AB42EBE4B24C0D2368CC
90124239164AE2CB44D964677EB1969E80CEF22DC62C985C44F7A31828B4BA46
B77CECFC66F350A119BCF033183F4C779D9D71C71B4429A564AB854DF648EF2A
0C6FE46AF3F73FEAF7D2BD85125DC5A07106C98514F109C55D91592B8AC53C6B
73BACF76E1D732F894C4CF40173FB773EEBED273BAB53FFD35C6484DC0B9108F
BB0C19A84DA1C817674A3E6BFE0620BE37193F2BA023C2E483E1D302CD320F63
0BA5F689FE857A8AD5CEC842DEBAD13A8BEADAC0F45001E7FE626630A68D7D5E
B4440641C333FF05A2EB89D7F32F8F13909459423C7DECE75DED01343AD69F4A
5C1A5020AB64076EB9E9D85E452944CA969A37142A3E14CE680A38083B9CB05F
77DA5C7B2B01C36E12ED74B21849722036D41DB0B740903447AC162CD4FF98DC
7F79FB20200C8B457C8F048E3808F4E26D4D3C67A1F5D63DEF4707F6B100B540
6BF0AE61C6E44F3E38E3B8D2E8871F75B38BDE119C666EF64FBE7E0B88169A56
39002A6F111DC0E1E722EC7F2BDCEB0E41266E6EB98B64D42014DF2B20FACC6D
E5C7D28F9D37E3F452F9515320E678DF666AA59E874F4F0E7EFCF1A109CCD37C
1B73D92B41C75E304FD74C5EDAEFB46BFBE6CFA098132570951103F75182D471
9CFEBF655BC2DD63522EC883119FF0E9480ADB539AE25050C89EA69B3DFFE6D2
68E34547E7189A1338E9B87C87E77CF13B4BE73EAE1CFD8A6B5C7F412724B2A9
2BF3D6095D2F3AD63A0D6983DF61299EE6A0AAF89F6BC27D123B500EE6289328
E0049FBF8986F60DA0A94E563C56FDFD630C2EB15D4269E2126CF05E144B1BC8
7E4E9E509282CD129736A10B51E964B9BEC196A24EB5F351EE40FFDDCF408F11
99E124CFCA675F9A00C26DF29E7EE697BFFEFE459946C4221C534115C23FFBD2
505DDC0A5842CD9438A16A02EDE8456FC32CE2603B08868F0F26B2DE08828925
3B7B308FE9D0EA176683406301E0DA4B2337009C13E8ABAAC241CC866EFD3C36
4D7CF5B22AA04234ED01C6865C56FDE76C57C93C02B8CAFF2AC2FB4A2BDA70D7
0198BFA614A6542F41DA4C1E7F5C7BE4DD2BBEC4293AE61833E4FD969B1949C8
3069C3B4877A42D5AEE9022E7F973DB8A4F36D58F69C9F18DB26CA6A8DD12C7D
A1FF99117C063DA2B21F5E97F57D5097A0915AD56CDDDA0B4614B06E9F99005E
94BD1FAA3955549E925A397D2624E239F272B80425136F59F87F26BBB45A5A14
5BEE6A4EE9E73F9BA8C8459393D844E04A0D02620300E93CB1FC95A78391DE31
E840A12E50D312DBDF80B5C878DDFE3D0A47EB7E667B2842E45E9B1D817C9B2C
E2BF8799D29D3718E4BEC0954E2101093E0F11DB1B6C483BE56C115F78C66D15
4289775711FD6B227ED43A6F854CBDABD691999445F230203B766E84C51DFCB3
6A86E0D8BBD4FE7CC6AC4B334622545962DDA88BCF7983B9978937708F4F07EF
6966F99490B2A94466C4825BC7F34EF6EF44CBFBC5838CA0C04F9BF6A584E23B
53BA7672E1956BF9A81D91E460A40E2BB12FD85E96A02FEB18883C966C6C44E7
CD4BA10E2702CCBC3F8DEB6EC9A1E7A4D9E7D8D370FDBB317EFBB6377F82CAD9
E72CDE4ED9689C18482CEBB1D85C77C25DB2AFCBAC0FF41776F5E2F3FB171876
A4A1DFBB759B45F157EFE21092EC5F018D51449D8DEB35951536DFFDF36D1318
A631669CF0103CAE22EECA807E157DEEE7B693A7B9F4CB0232B5863FD8624155
C2E0075719B3AA5A3CACAD999F5A8EC54B7EC141D5F9A215581EBB4455A90821
06929A800BEB6C1B0FFE278346E6C0562F4ED0CA7DB301DFCADB2468501AC47C
DB7C0792A219FF960706D024C4B1B0C5741489E47391419C468AE0DC24C31C86
13F61AF557C1A8B4A0A5403A7E3F57D5C94C427BBF6FFB1A37BCD9E32C873F92
9E2D2225542CC649E068ABD93B87822B863FE57EBFCCC3D4D73E60B652906AE4
0B3C5128E79C2DA8694354E109EC64D08C55ECC10C05CFE0C0D3075913FC442D
B9FA51ECF957513AB576B164AB5C019B131D5FE30940C86877FF5D6C5E3F225C
6112F519C6DBEAC8772D68B6DF4E71BB42FA21CD2B921494C31BD10D5FA94DD7
513325F55ED85A72172F0E99AD8D5E60E8AB6711889A3B2673E5619E9342D6D8
C013BD6DF84F55D5691207358B48A1548A5ECA207317EE7089AC7CDD938795B0
1BDEBD75F2F131961C7066BE4784E01170370C90CB2BFAFEC2DE7B1104DCA211
0E112CE078402CD578A20CFC0CD22930123109A6591B08428383863DF8BC335C
360327D092301397FF9D6484C30B99C41C38C1659C8F4AA772CB11B5EC3086BE
133BB67C12ED827BA87097F1D066C4FA30B485A2B6584E6107B07203569421FB
72A54FF42C07554E5201BFDFBA832C86170FB4A227DE741A60A232459D506D7D
185BE46D0996770ECD2DD1850D82E879F5DFF1313037988CD685A9BB7F17C79B
4682B9803A741CC13FECDF73CF938DD2AA5F10146F13D4D1A83D86A9F0692817
DE3B3BF5254E59F20357BDEA11DDD0F3AE7DAC772024183BE0BAFFF9AD32B3F1
147F938D6A755198C660E99B9F75309FF22974D69A06D728D15083E41EDC6102
FECAE58D213541FFCB73ED7DBF03932E9270A3B82F98C02657D5E656BD9C4197
2007ED2E8389331D093775F5FB511A82598FAE54CAF3DAD94F210F233C187DB9
70A1687A79FA2075E07F30210230768F2901087F4D6DBDA17E4AD99A63B008EB
200E0D5E16ACB12B13D38D2574B91823F45EA38B4CAC1A11C04F381966F836E3
56FA365DA41C2B1E60C5437B8F7B9BE3DF23EB0099297227D05DDF0FFCC73791
E9D14377BA52FFE679C3541DF20887B2F7DFE9ED1E0431C8DA30F989B8F24616
390337BC5F8F19CB6F72A62EB4E4BBCF1FC0273A5850643E6715B0BEF8B3F710
4BCA943E5223427535ED57DB1FB9413FAE980DF2C8DD79AEC4D45167D751D564
E4613CB95086E2B62F264FBAFC7E90E739330CF673F176ACB3B40C2AD534A8E8
8B86E5551FCA447C955F87C644268FC5B42C927886E47443701866F75FBE3664
B8F412B6234CE95E571B8A47B33F2E8F1BEEEF87FF2EEEA163C5B025F43C36E9
E4B5521F31F8E710D10234C38B31C8CB3794B3400AB5E5E498228387AECD20B3
07606D3F7EEAD5B0AAE65FF819C098ADEF8AF1F0D23BBD5012AB0310BCD79BA5
AA9FDE5C106736820B57046684E4B315872876C04F31BB47262A722397867DF3
2ABE2DA5BE19DCF73DFE4559D65A67FC46206620C322C9F595E7CC16153F1221
59E4EAC694CD70CE876A8D6FA925BC7DF47112FFEEE0DA50ACD24842A73DD47B
D88651E93D2039E915905F4A13DE7BF67DE02D33EE25E911121D22B062823228
4EE63E6930C0D466EEEBC22935050C4C5F51FD627F9FA36E64C3A44FEED77916
7AB3897109F38DF2113C12E5755121A4956D37A9EFDFD0D0773B09DEDF5AE782
D46B9AFA3CC9B137D6546E020C5E0F14B3BA46DFA2DBD6632D3B3A0E0C2977AA
B0F25734EF7BA8071980768B26A3FD03A73D899B52E1872F13F9D164A307CD6C
DC8A09B98708AEE4FF1A6B425D821A7A71DA1A5176E44961164BFDB2AE879E7B
EE3F720EED7A440D5819580C478B6E18763B8CE18FA8C5780EEE7EFB67FF98C7
D011DAF6DF0AF50B62E4E7F8B2DED445EB8FF9E0017473C90AA22BBB1616CA92
6AF02AFA88B3E3BB48A9195C304704F4C8172BE41EADBEEBDEB9499F2A756EBF
E4B69E5A79C51DB4517AEC09EB13E3336B807B7D0EB4D7A42D6F92842DB04135
D8569D310CB4B53C28996B62CF0026C5357F7F712BEABD62B0620BA4E58C2FAE
A0067144036EF9AC875244508BA8ECC58B8597A64808DA172401BDDECC8208EA
DE656EE8FDF3143C5F68798F3CBA97931027AECEDCFF8E838AC4965F5802EAF4
DBDBF6F0803C0FF1033BE017C7840C1AC009C7D545112B3EB22582DFF12762BD
68515CC0CC847677F655CBF64878FB63EBEF47DB5F759D835FBEE9B769D238C6
9AD54D9DCC8AB3CEA3CAD8DA8D54C8D4F153A415DA4D1988F7F2D31001414485
1AFF9DF0E9ECAEA3C80DEBFA242CF041FBF55B862BCBE11FC759AC75F488283E
17D34B98E9F793E6C86BBED7E14BF6F12EECD88D1E47B309DC42832C04D724A1
CC28036FE9E5FED026CD7EDA764D486BB38ECB07C6EFEEDBABCFA09CE0CB7CEC
E402E1EDD759BBAE0B6A6CF275DDA9034F40380B709DC2F3E490E510C478B7F8
D9A5509FD88EF8BBECF51EB906CF161A063401418C574E7CE10B87E61B5F5F2A
D06D61E9E46567F7C26E60BE92928BEAD5C2B48B667FF6F63251802FEA80C794
2C2B753B20B5E4080E9573669559465191664D6BFFC3FC18FDD7355D4D5AA7DB
5120B5BE0C9789863B30699912992BED4504D209ED369EB345E0A9C1BE0B56BD
76FDA509935A0E867D57F56B5168FC051198F53FA26A6BED166468CE72E06B40
1EE88E2423F42D60D1EE26E1E2D0B577E53D1DACD07F3857588A6358A35E5109
1ADDCD3077D05BBE42324CBBE3B14A73CEF43B595B877D7ACCD3A08BECB50111
FD4706232150C380D8BA99F8BB61627939B6F349C030C255922590A42F797B61
1CDDF398978656837893CBAF5B9672FF8DA27B3CC74903509EDDADD2C072D787
71AA1CCB6169F63FF47B21609CCB685091DD8BD7AED5D306DBD5432E6EF6ED9B
93D2493F106E3779A443487D89B7792E8CF7A0413FE26A4DE601315FA1135CB7
CC6ED4607F194FDB44E481767CF97600ACBE8868CC263D35D082CE150C382BBC
2C4EE826624B982D9489C05168439057B8FE6854366A77219C3ACEEDB94BF034
FB14711FC2674790063F898BC526CB2B3C1753FD240D77865159DF957B63E24A
7A54301D35BE9F8F9C31AD6BDC76371CD385892B3DD933BDA035800A3728D93B
36306FA4FB1B075F0548821BD07EF426E22EA483A9CB04D2249024A41FF0644E
96B9707011F6D27F653808A4A07F6C230B0484F97C878FE0713FF2BC4C910D4A
5CA7593CB530AA7E1D970D64091771604237092A9569FC1234374131CB271EA2
D95D6FF45BA38535B05E1D034571EEDCD97785A36DF0FA32624C0C87040D7A2A
DCD518603A20AF3C67AEA589AD38BE8279D6FDA2DA5DA2DFC47E282329084DD8
6CDFDBC122AB16A9CBADCDA8301007E5A8B15E6F2F2979EBB3006CC25FA70652
F4F0A9B74C7B4C9C3D5879042740351045C28B8A3FB5CC4F6D9EE789E42C3309
492A3DB30D87A3BF218A65049BBEB0122D313D064B0E699C59BBC6F426AC0671
48FF6F776640C64940A4056473E13A16B40127DB0E0C8D7F0799A8C0E0D965F8
FB636D1ABE5857F22DDA63B6CC8F44A2D2A802B0AAE6D3E1112AE68CFE6FABEC
1ADD82AF61BCEA4489304F694C2C1063B3576890D0897CB066840D525DF306BD
03A65EC3C2ECA2AEA71819CE5CA3771B40D3AF39BCD5EB1DD64DB4C08432BB37
BD5DD3B93460D35A251EA07539B45BDA63F1667AABE05CD3BA19EBB913E320F9
F732ED1D2D1E7D8E9AF000EEB4FE91F0C5FCEEC1D5F6642B73739F7078E1B4E5
DE61FC180F4EA5000FC2EF8C01FB54EDD95158D8800F60FEF22D8FB92DFFDA92
FB12AC337DAC9E67CCE192ECB6749EA561D350FE26687AFE1A80ED1D38F95048
587B305CD2A9F23DD367C75D9255F64530BAEA462C2031D3C4F1C1557DBCD03D
299A8E76EE6A498E3AFEB8276C8CD71182467AD8D487ED71B1F89495FA2291F9
274F17488B8E50AB2B36968C8DE9FABE9ACE6C831B8969237CB42E5C894CAA7F
027E95F0C7269F25E46C2E24AB3C9C29062266C1FE4458F3F47382A12C1C7628
7E373FD941A706B647E1208E14A02F59DF632D8E5E238371DADA3249D7F4F9C1
BF904F4FBD23F22A45A44A1E4B240CEDDD13D38061B81F641A982BEE3ECAEFAE
E6EE3A505D27D84BDD953AFBFE20BF73A556A1AF5A60B8B129F80EA04BBD9DCD
BE413E2D9FC0311D52E6B47C28BB1737D9ADD8B3838E8D54A5DEE75801F5F379
22C46FE8971B87F4DD78B9387A047FD4C9FFFDA5F9E783554606989FA71F2B23
31AA82E5581D7C2000E09D06FEABF091FCC091BA0122F4204176BADEFDA1E071
87CD112D3ACD5828901EDC75C031E483D00129B8159490317737F63BFB2ED6D9
245C7067F90D40C1E4FF461339D47F852697A192D8A35256DD2882EBBD50875E
DFA9B3F607911C9D78F9AC2A249D44E7655D5C5D9506D2151336168FA3FEF107
8B2B3129F33C5E01DE5A5E6666D2A7AC842936503F774C4F1D84DAD406B1DBFD
722F375EA536832DF64A939000AB0788E49650795BB5BFA7A95D28D2C34F13A5
6451225C8B18BE71E9CB626C45C1DCB4086F1C2BC1E78F2FB3C7BA0D02856514
60EF5F67DB57C29F9DECC6F31CB782C53B009E9EA4FDDAA547A5C506752935F2
DAA595EE46F3D492BD1DB1A822ABA5DA75C5254073B89C7B0B505D5CE5B409CE
FDDB85FC2356AFE5F3322FE62B0384FFE209E1A21F84F0C3364DAD8E40732BA1
BB9D6797DB55EE3DAAF9377FA7F1F34CEE6812D84A6FCDABCD2E04A57012FE80
0A66818ED566EF6114B23EC5400FC7D9CFFB45756C398D4A72CBFD23D73E6FDE
E3B9223347D0F6812CCD4E3223D7F31A0866C84B01018BC3649404E46667AACC
6202052F26E49D2B1583BD6796DDCCFCBAC8BEA39378F32514C513041E1E7F70
405172AA74EC7C4750864EB992E3674E80D3DF9838065790887B7DFF87D0F370
F2625BC4328967C977B402C4A5C321BFE834C7A0ACDEE73E5FFFA1E2F9FD0A76
628504062AD96365C078230A3F4EF71A86398D6ECBEE0CACFE45760EC965FE1D
DB1815D29E485F8C6E4CF13FEA4279B7AE22A39B78CA0E2A64472036D5CCD82F
E5688E20806F57BC047087667702E433E588E9D68054B08F2C430ED7AF62E28C
E55B0E478A1D8119639F1AF07B2A724EB8AFCD6D2B3CE88E98C87E2C8DA9F47B
56EB94B65C620821EA4CD60E1F01193368747AA3E8A0147D69721C29375FB36B
F464228F5E75318114E89E77B4C4EE13726F95E3FC9DBA6673C707C4C35DAEA5
041C672D778A986B19FE3454AFB214A89479807A3A8E822A378AE9D5AABA3199
45D4678D01BE3F00201C40221BFF7FA9BC7913FB7A5CF14A7ED8305E2C660AFB
36A0D5600501B877F3E74F21B77AEE253F60B061CBABA6B505791439C73F49CD
AFC26882C8540868C862133314CB51204D0CEE005D5F93D1A2FBD5AD8CB1ABFC
41E5C04B4693C31D756F608F7CEC6413E48453B70D3E05A01D0321FCC7F4272D
921F422AABF34CADE52C1D9D4089A8BFBD761A1D07F8EBF5667D78046F961F42
1BA031AB2B9591F5ED4EFAEE85EDBD00A622EC66CC1D27AB9A2718001316F0FD
02A9DE0CBBD3EA5500F0DA277BDE65946F4F3F4ADDDA5FDAD805E78C1E42A891
09E41B97771C69CC6EC2F7A7F271B4AC018DAA9E22DF0BD0FC1C15CDF19E6114
05A28A8E0756BC42393BD2E816D6A88CB8611A22F2DC68BD14330402B7C8198B
01D058FDC990C3DFB30704B1DFB48CBCB53D0D6B5795846D7663075D06C04BC0
FBE31D6262767F0D40BAFA9E414A88898E7BE07A8DCE545E76FBCFFB0446CFD3
6D3F6C54CC6561EAAE73613092B859E0B094065B2B3F60084B5A319036CFAA5D
222F01870D901FED11A555BFFF61E504C2693277E8A42191F60B3630F626A823
5F0C8408CEEF4CDE49A4009C7BC0FEC1028A6628C28A3F816B83F3F123332575
D9665E7C41873B6D0D21EAFF270E2A36518F3B26BC7B7A273064CB4CD5C8F336
847E3A2660A1125EF9C3ED577D1F62F1A3C6F082F0FF91E2A4A692C9D2037405
A4A87A227E1E369973921C8F74E200E1D213DD7980173A1859C7477F0003803F
4697DA850C48AB89778534084B0429E3D371363CF47D7018F8D02284764F9D3E
950B2E18A2234E0245D5EE2E0E265110EA7B121889885CF0891ABB0F75E3CBBD
5305C3F4964CCA87D8BF475588A0590DB73FD838194A11CEE46C9B67F891D342
28252DB31CD41A199C054093650D6FF3F0F3BED706A5BF786FBF1C8A0719736E
582F04263EB863D5E7A385F86F3EC96DDDB804546434AD4EFD3F95774A6A65B2
75F0F1D250DCFC85E7630942961BBD39F4DB515FEEC0665C24981C04915BE9B6
3B4CA6F4056331B91EF2C0FC58CDBC73175C2A6750A8DE510A351937D2FF63BF
D092091A0DBAECBF2840EC61A26F1B06A8F5F3B58922F0503241FCFACCF05D7E
AEDB92DAE9A441EDD7195675C655C49CF46CBB9224DDA497B16E345D26712C40
658B1702681285D38B3AEFB10A95ECAAAB6B5EDC6F75D8820477FBACF33812AA
9AAA9BCD0D98DF776EBC81A56E2E72A98A183BDA3D4B6BCA8B13941563EEC302
D5E1F82A5D77304F083AC617954A426DBBFD739F8717141C123A2702FA0840A7
1D8CA73CB8B2786B49069FDDAD8B64219C829B9E5F613AC0C67E18DB4060BF18
E59C5418E30B72AA838923AB3FC3EEC3A727857F176FC19609A31CE5A19DF3A1
EE8AD25993B623627EEABBDC2EB1FE719223DBC6C57A94FD517973078F15095E
006F462FB357A686FFB229C40556DE120102CC9D0030CAAAB61485FF5F0A9F08
8977F050F46321202836DFE33E7ED895DD48BB8FB030C08D32A183876BC78D25
7B193549CC2533E7A2DA8334B4422A0E7FEE9DABDF4A24ACB5481F550B977469
A829526E3C9A1590C7A68F33226FD9954F343639D765EAA46295CEE85FEE6DD9
F83480D17BF80B0EC9F20912C563146D876AA3AF7DC1BC08AAC7F06EC62221B3
6CDFB10134981CAB1C80AF4CD5656940712886204854CB0B311AD1D431D3E579
56343220F5C26749DCDD2C50FE5231ED9A71A03474B48C579DD118B07D599272
A4E41C0FE85BEBDF93D74FFC0C0FE0C8427506F3245F8ABF89C64EF9EC87138B
9774845279A47150F7E4593FA1A1542C4BCF9E633CFDEB4E0C6ACCD99C80F56E
D4A02AE13222BBAD97A0011DAFEDB23A5E99B008F8818D554C3F7ADBA0489EE8
012C2FB8A0AE6669F583F716CE99103A4E2AC67B2BB117FDF333902B26ACE4A8
AD235C7C3E543035B08687409C050773EC5AAE093555362DA46FE15E7862BEA5
498E92A15F8BF75AF299C72EF10C97C1189B88A273E624CC61BCD227DB26D5AB
971FB9B7B9ADA5D5A1A5C4F03D46F8A5ED2B9D3B94128FB4C3C6275C76A3965C
A6BE15AF277BFD5EF7B1AF9DB2B213FEFDD022E67C9C547407012AA530C6E2F7
CFC6DA18993C7275F16E2FB18A0A7C99DC4868F3A403F81AE80DA82918A11EFD
403AADB9F5CE8AEAF517760E35CB9479BC73307F664462B60B4A9F0BB7687A84
A2BAE8ABFC13E4126287A5F87C9001F48D440835790AC6E401F24D9BF7375BF1
E49F02CEA34AE1269790E115612F51065C0786AB14F3DFEAB944F612813A5A62
5DE6C55EA47EB8EA4B4C2CAFB375014EE03CB73D135FF1930DD972DED332FF0F
415014E3EB088AF6807AB097B495A1B3D6F7C35D6402E68A84909413EC0427DF
0594F7E803262704089DE33AE11FCAF075C64DE59E10AD1AA97FAD55007F3122
30B23AA25A4B4580B03587091DE4B3DB5E573C6932480A1005C19F24B4085FA3
4A29AE1A53456DF61B83C112A938132673FA5C4561F6990457EDEFCF87854837
AE303D8251EBF34EAAEC52BB85D939EC763CD1B4AEFE7F8FF5E4FC5DF05E965F
271DF2296A6B3E3242D63C339CA4DDB77CA5BC7FCDE63C04C2F3E6A888C0483E
78C471602E34ED2A88D20F1281BA45F39CCC575822E7EE032116C35D7A826724
B1ACACE72ED796E87961404CD606BFC95723B8FF9F77FE51E115D242157676E3
FFD20663EC72301C57BA3F27797F55AAE443E0D1C1E7CE69860A0B5E208B9E38
B98B970C427936D02BCA83A0F4CDBF0845681A0B4FDFC4E2ECFC83AA304767E0
ACCF055D4642FFDE8148E2A25664EB8B336E2895FF2441F6472F4C1445AAF5DC
6B256792F59A2BEB6003F4761DF73BF1ECCD88A2F5144424647A819599834DF0
8F1FB211818ACC87C29951E0F2FD7D3ED019CBBEAD595A3F57C9236A717A8D61
8788D52EE9911A6BAF03E5A1EA83EE91E1866429662B26A32B59F0704DBD701B
DDB57D812E33D34FB734EEC2B8AF8C63B61F630AF50BA0B90F45844F1FD00A9E
7B75B75D423FB54CAFEFFC503A1A39C2534D45DB31F0F5BE82632E44D855C3F6
7B18C4840C77F817AE00824E01D7B6BDDAC11BB4691ED70ACC01202963F50470
C34434465268FE34851092CDE6FAB8815536116D3672C955D2DD8D3E38FA013C
2DF9A5D358AECB36786D892C94C2004D1D172B5AF7A8FE43C04A42FFACE6E527
4708268EDA98ABBD171C4B66810B22737074684D94CB6D37D83D2AB67D6DC58B
119177147625AF840AA32660675E9D52CB8D48E075ECC8E456BEB850A193D508
C13AF74BC6F722B3A2E9E890F4B180FD81CB67DF0E3D1654A59885254A3C8FFE
75CA7CDF53D352F90DB20C8C459136D6B20B4E18A761EBB81326C8E14ADE0FC4
F203AA8AF0721937239D2592106C0F9879A51728AC075C2E4F8F351CB2EB5E6A
3A4832EDDF28DD6B64FCE5C11291C3B354D72312621F3C868ED1F211633E56AB
D81CF49B28A69A71812009DA9DB28125212ED1ADEA27F0309E90C5AA1B0DEB43
692CC933EDBF3BD75DDE715A927DF408FAD6DB28B00C3CC2D653889744AF493E
1CEC0CFCB1EFA9F302873233209B7918B2B9DE5E4546CB24E068292C1AF5E52F
A098CD7F65C9077385B8258658128A229F8CA7DCC3134F5A1E70C9A94D7C5635
DF9A00D422F3424D98E58B446892620735479FCF9C3B51D78289581C77E718D6
AD6520A5E9E8F0B3F0AA7B402A4F5710C66292413FF9E655D13DC571BC0EE989
E635988478E24A4C54A24C3F36B0BADE583C4C762CC2A687924BE3FE6B056AD2
E2244B324D92830B187AA765BFF837CFF93A3FAC33668F06645F216F95C1CD9E
203C5A4D043CA8DEDC4BA8D2CE34CDA8A7EF789E9A1F8D26EEB6514138E903BD
331EB973053291448C5B61D09F15EF4D6C681E92C8FF04D6A30F9A327689101F
ACE7306E7326221CCFFF68B5C82E6AE7BA706F350CA8163287D0BBED2393D3B4
4263FA04C4BBE424753D09E15629F0B3D7379428C444C19AEA8E5281A3264BA3
57544E9219DCF2C915FC2C6FE7BCD7F19B3A67924716875F355A09E1886D9B82
F4273F7C5F7267A4BA350D60C61CE526B825DB26EE433BDC8ED7A841C85E2664
28145E4E1EAE441DCED84ECBD8AD65D75B88B345A5915063461730C02727CE40
691845E7BA082E7EBFAFBE468EC8FFD5D7201F38E9A73C446E50EFF5DD608286
7FBD4D8E5B8F374E102E90610D73398E426EE30714DC962BB105F8892755EDAB
C76F71BB247D4F3DD61496311A47D3916A2B8DC2692533723839B18F8FC3B028
EBC7D643BD0A01EC2FCE3A9EFDE7175C7BCD17E3B57A15BF97FC4C2DAF83FCB7
4CD055BA794637887A513D2B63F6B5BD18DBBAA2F41B0A84DE218714AD51E353
D8BEE513DE7F288E141E334F37B232FD87C3EF21610EC8D94D0BBD40411564BC
4BB7D7CB018F898E4F3692254E8C5ACC71FC80BD3635D6435CE9C31D22326D14
7968CAA3F54D3D179CF7B9828B36C3FDDF95DBDB93E8D750ECA96BB3753EAC57
74918650CAD105789BF5FFA1F17A1189D19E070AF19A7A1B411603668D9C5017
ADD3D5335AECB799B9DA38E52291B0B42D001B73108E75BD80D569AC3C91F16D
3EBAB60755BE6F58CB25CB4668CDBC9C4AF0B337612FB6AB3AFFE6AD2BF4FEF5
F2B19DAC43E7E89087089B480B614B49479D01C73FC5FED4BCE161BFF9412EFC
DBF4FECB5453A1670646B7BDD020C15B2428A598B70259A3396BE60D2A191057
40C4463B6328EBEB5CFBBBAEA088C8C542E04762A872B71531F858C9B86CBD62
7C3F212CDFDC85A02FF61F4FC9D84D0A31B421555CAE728187ED76722F3AC8A0
033745292232E5DA6FD5A9EC27032FB7907EB16C79D33DE6906B0DF613297A98
8EF346490AB6CDF3BB1B3BC38EA7ED033B824BCC623BBA450377C4BB67EC9BC0
77C843BE5F4E5DC0FC2D4D7F4BF39EF13893E06FCF4FCBF1FD689C06433F88C0
E66668C2C083223AFA9EAB1FFDDC5C9029F22515F3DB8D573738C567FA80762B
A97B92D5C34EB05773823DF1EFA8D90A75F4C03D49A378E08F1D90B3E33FA250
5745B179D594E6D35538367DFD20C81309F4EF4C920F95FC64BA82B0EAA7D1EC
90079A76A37DE068D522D068AD132424695E979B96C43AD6080B1F515A3150D5
95253DCCD4B477735C210318B636F04B83B823CFCEC83CF6099B2CAC9DCFA775
D13E1D07E419B66846BC0ED7D637D11D1D44A970588E55C03DBD0D7C7A395E28
72F26E3E5363E17FF4DF5BDC6C5E526B0599B5763218156C82DA67916AA7565B
09493002587C6385F9C7200B5ED206D19B87527C37E1263029347703D1E9B1A9
3D963FCE6D717E05751F255CF1092541D76DEE775AE1CF62BFCB97F2AAD5E04D
BAF0226F08936340A19AA421BE74A9A4ED500C1693BA5F3CBEC946A710159DAC
1EEA0E04DC2CA064C9693CDAB3EAA9F2338A2A9D530E9B5828B5C924070268B5
D529363297DA46D48AE2925A6FB696C63B4BDAD72924FC657FA1D220541846FF
A34D313C82E8A20C89130F13F44F6D84A8B01A17E2FEBCDFEBD0E3D1366B35B0
00155CD0A2F3F314865D387ECCF4F65FEDC52F516EB9A039C26DA9A545208E8F
5A66ECFB3D6C15473BB631C3375B34FE1E014C61D5B53FC3EE01185EC7458FB7
8EC1820FF1CAF0CF2A7BDE5579DDD3A1D0E64BF631EE88F19F4A33C36A635F39
84C9ECF76C4F9B302B5D2A881D921BAB075ACCE898D39E66ECECF4868CBFF10D
5DA884B6B88DCDEE191BBEB770E37F1641C43871920D02C085E85E4F6271087F
FA5BD625294077DC9E46FFAA43BEAFFCB034EC1F3B53029340EF797B7F6B4CF9
74687D475E916D54FA5917446EECB9536A12E0B40241CDFD2C9C68C8F6ED7288
D6695EABC54A5414D909BFF59CBA4D4BF05F8D32DF7313323AE75140D46417B2
44EBB3704A7E1C7099A3ECB97A1DE10F90E585D0BD39D4D82D39B91709C321CD
213611429C771EF176B9FB7894BA4082DE3ED74B72BA7ABB370B34C78DF340E2
0C3188E7E196495B827A4CCCA05614BD742544855B03675DE92CC3AC70DE7F74
C6699B71CE8D72A7B0E7AE84BF3D661586A279458D0806124977F2BC4ADDE87C
9EB971AEF99BA2A5A7DAB5C6A17AE59CEC1DA5EFD381070951A6CBDF2BA5BD3D
54F63DB4D146AD2BF483D025A1945F7D29C0B82B03F256001F3F50055F1E2AD1
93E266D1B3F7EAA1975A52809844500AB26565D707EDC634A50B78ECCF90E9F2
B97C79960EE80782AF67DE8434CD7BC1B68F8EE0AEED22FF6D888BB0FB39DDA3
22FFD06CFBF3E439AA8CE50ACC8ED787362DCDE0A2960137557351E036CCEE8E
A594B20FD985374F7E7AFD30B8EB77DD72397EED4C59D5872934B392624BC61F
F7123536F6F5936CAA2124372611E3E87FE865241AC0558055FAE941C02262AD
DA8B7B629A01A231D5E06B24416DF994832CEE8DABE8E0EBFD31A18851572C45
235265B0DCA16D71EB909BE35BF874B5C59115DEA19E6C4C907A05E7D5A923EF
CB73892F6485DF06444B26231849CEE7550A52E36FEB3DA14CF47B54759B5FDF
A1E1135276ED436356C7C5565ECBDC6944E6E0C6FCE7B99D2C7CF683445D8E62
98117B0363A482D885510EFAA989661414122012448868B43998CE849B1261A6
982A9950A46862971A257E620368E3817D6355E6550115F0421842E7E21A4A14
69294470CAE487DD975B436DD18AD558A71355DCA5A6418CFCF1084C3D9C48C9
CAE8811A9B447E1133EB56FC691697180F5C278A9FDA020C7326F1D2673374DB
A76CCE87AEBA79A9BC49A896114810379C16BE88BDDF357E0EF1EF8FC8D83D92
88CB8F3AAEA22382AA188FE8A8F9E45E42170164247FD405F6A8CCDB37A1B10D
CB35F32CDC09BC617618DEB1A9870992B204706A1FF355D55096D744C01360D9
6E3C8377E406FE5BE20C4C791874745B0F641DEA19BDB8226A5BC28AFAEB8F01
68B6B2987A22683CD0E4B3DE283E3345A78DF89764ED88184CB7F72F2737A7DF
7B2BD5D9CB15505CEA61BCC0CD51D68878AFFB2E8ACEA1592EE30C643F55D4E3
91FFD2BCA900DD28E31568EC8CD4F0E6968E84207DF193692B5CDC84079FA7E1
5F86449C4BB4F3580CDFB1283EFEF7142B108F68F3A8EB50A5979388D9231FB6
C403C6EF1383618C4723EF1504E996503F94C0D982FBA53FE20128189727AC6B
9DE2BEB47AA81D30917354885ADD225BFC8AD10F5956412DDAB4AC96A1257E0D
C4C77E14FFF75C41B9B326DB3ECBB5D8A76A11D8CCA18F4DF2E966E802C7F935
BC32358C8C207B3084C2FB477E64103BE68CFFF6C0F13A59EF849721552BBFDC
F1BE84321DAFA13572FADFFF6252F456B95D81E978151FB907B8BF0FA5C787CF
EDBD88317BB1FF56B90E52C25618D154C3FE0654D4C38B8F1B098160CA67AB0F
852C9781C2058DB12751023FDF5D36A29D13EA158051CF3FABA9891AB1539C75
322D7A779F01531CCC34653A38F70443D00B723C0D95DF90F089D078C2915BF7
FAA3A611BEF95248E48EC8BBD7085E74BE306D67CD6255D38AC618C672EDFAB5
6EEBA7DA3C5B62CD671914FCCDF43C6A5728A26C45D7C59B394466D03279ABB7
E50A9B7146627AB34372F74B77D5D50CC0495D8CAF1CD7AA918D18340101ABA8
71EA40841A9DB50B28D2988FB407F0648C32E3C2911D8A6A8A0194F57A5F860D
72F428E27BEEB679AE98A2C1C39A003EE9C585825A1155BAA58B8B52CA91CF45
024FEEF3C59BBACFE6BE4A0E65E0C2E29FFC08454627B79FA38400C865D541B0
2CF354E4A987040C65E1DDE45F3C7301032528DC81E3EB4E8985CDB015A9B707
F01198AB89A17B78704D7D356289088CAB7E727E7BAE8ABA10F9AC859AE4EDEC
97758419473B7F6603507F154EAAA4A1EE7A1125C7FDFEF6645893390DB59502
2D9A7AAF1ED6D1B33CF72C7D049ADE87619073F3F1B4A3ED0CDB8FC13FF24296
892FB804C62E44B6C59F19AD467F92DE86FC70BC885BE6EB4F4C8EDAEA8598D8
3D42F0390608A424095F9F406F76E91A3C388478AF873055C2903F8564D955F6
1B5B761D729B883C75EDC6EBB4FA42133537162B8CBEB0CD5B3E16519762FC60
19A9528ECE9ACA6A6682A5C4E9B506CE78CD4CFB3D10CAADD22BAAD16299818B
B4B472FDD5A0FFB0B5A878966574C7B411D178031390546EE856DF0E26121196
06D13A639965E100A5F2F1D2EA1916696D4537718AD30D0921BE98062527B6B3
31CC40D21BF3CF7EEDA52ECF1B5A2A3B922810708073492D6AD02C257FC66974
C77665104892521B5951E170A0B1D540B4A2D31D65E990CEE7196A15869A8962
095B52DA3734540B2C297773FD5C5A9416928A3370CC79865B038AB4BC903334
4A7D91F1BA18220296970A31F100287052DBAB96485DCC59C0928920C71D40BE
BB14839F19AFED3FC7AF7F805D296F2671F05C3B33A68E08B42F34B7E5028A84
1C67D094EA93B72083AA7E8F9CBB79FEC082B3271D2CAEAD55A8FB50B570F889
5E369C372B2A4C0EE23F4BC7628F410DA8FA36AC114EDF069E52AB72DAAD520B
CD597E88EB97AA1A455C1064DC5901369F36F0A53E4FF6EE248E7260EE152AF3
547A337BA630C15E81621185DC9F68B0C393E6ECC7DE37F5C86A51A08898453E
C11B98B4AC797D6F38B6938AAFE59DA4BB0D161F95A80CDE86C87F7EADDB5DB0
A291DFF2784424DAA4684C81CD27EFC6D0D7406BAAA2292192EBB51666D2E959
8455C9ADC79EEB6BE36357964513DAE3E521223448FBD7257E03B6AF9A87098C
7462EDAB99B0591F6CFEAFE8D4C46D2B08088FB1F6E1CA4EA3A8BFA8F7D99B27
438F7BECDB9427AFCD2F02D9555E4355D26E9855C76E7E1CFBC1793349AE0557
474026FB1E6E632BF9B9AC67D7667A6309D2DFA3D25A9A47EC4E445C993E160A
BB8C5BD6C5063DF81FF71A147914F39A6B24A36EDA2A0428833A9698E7AB0B69
CA6C993D577CE6037B62BE377F1970414F3002EBD12ABBAF80FBE623396C0B9F
23B7837B2659A9BE0EDDE47161AA506DC20AC15646AE0B8DED3FABE16C7AFE2E
8358ED706A67F0E0B9A714C995F868AC6B131396B19B3A6590DA21DC0EF5B43D
F9044EF31889977ED1198D6E0FD529EC84EA0F2E79476BDC2EB6AA8160730DBD
D946370BA0B3D7888EE528EFAB8401FBEBC552159423ABA68E9CF7CAC2D42B6E
EB2FE577DB49608401D02F9483E38CA2E0F0EEE5C62E0472F7E68A036B7F7258
FEDACF657930D580C43458591CB38D0E1F06028C0191013B2F921FD05F9AADA8
52C85284B97D39EBC44B59B61EB318DFF348CBE26165E4C83F96A08571B32123
6E9FBA14D0833C84272D8D0CE676C0C05BEF830E0EA244901F70803B99DEE813
0DB2041BE6F0B8C1DC5F1A8D9807FD67E2C3316792F1D9138EC57B990296ECA4
541D424377B5ACB8E3D3B7BD5590A403098B8EC0A2A5A16D4AE593CE895509E0
949938832B4654905ECB5350A6F0B13C71EA7C9C2C9611163592AB48E017875C
8788D80DDC5827357C3AA1A6E542730D629CA6CDD0205692300955A3B8F1EDB8
13C8945966A54D969194F4A40C52A97AD11067F62478B8E2F082BB9C649EE661
C91326A553005DD7CDD11DE93495AC2A5620C3975A351F6DB460A921F813B53E
BF003BD3C39E728A2C0E2BCB7AA83C3761D814C983BAD7449E00C7DD357B4460
05F8FCE25E6AAA994D5EEF6147A81B866BAD915AA655B8A7C54C48B32A7DB5DC
146D5D4860D1CE5297B15E108C7008CF6AE0C29CA28C61D49170D2C9FCF42F3A
9611D33F234456C35D5609D722AFE297F96CBAC60DDEE1E22032F2D66B8C5557
BF8586CE7D413189B4DDF36F2E903075D55733A36360892A330750169E7B8792
96354ED2620801851E22FFADAA82F5FBB3A8579431212C7A24D135A18F71B307
8FB4164C17FE9FB7F0F1B29E8F8873D6E8105EE5E68130FD6E105620FD2A0B2A
EFAB07D9098D32EB1E5BA23A97F7C0A604611751C95355A1F1693C9B6B2D2B16
98615B89A0A0F52B4AD627972DF1E6C494AEE795285E41CBFD0E60FA01CBDEAA
A69D797040FCCE8DB4215A023365BF0D2B1B65E5CEF0DA12A3A4FCD3641AAE
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1347
5296FB33A7C728385CE3A6CF8AE664B90042462B94A015D5E8704070AA59636F
6DC7EF0DA3F7829296DCB0F695A236FDFDF7F6259B93A89085A7E9C818578EB4
A5B62CE7194D5AD4ED8D7C0A1593641F0609FBBBE7EEBD2D0C6FCB75E7A5907A
D7EDDB8B14D3295A425583E66138AE558807F859688E51C1788E04F8FF6AF035
3ED1B6827637A8043A451DED8B6A6F25C04968AAB2910DF1314D1B4A010CD4ED
2FD8455FE6FB032968765E65BE3556338A12454E8BCF6DC82DF9529B9BA37245
C3A13FA42B9C8A9C98B34D79C82F9E61598ECE57E551BF193BF37ACA22B901DE
D22B528806F4D4A0BFA0253A5BF89BA1451F39C395A8026A725FA8746E36EA41
C57E7E0A23C7592786987A899E28EFCEF81C18AC249388867DA67DA44DF3E926
AE8AEBFDFDD85BFFA477D990FECD8CFAA40F133E5B492B50B5B0A56669AE03A0
F69BA3A59693416B6758A4EE5CA1F3AC445031ED0B3FF53DD57E53AB4918EDBF
1B76FFC1DC977E95A4B4BF0AB273EAE0E4C1613540117E10965F800C4D68FC6C
6E6B1D1D19023A9F88A39807511D45410BFB50959821E14F973B43BE23DD4755
8EA0E536FA063D6DBE5E0587A1CCE422CB13471E3FABC48437040563AEC3FF18
E73E781CA45857DDE560013B3B394283B77D62FAEB6119E0E45D3C997CF952A4
EF7713EFF5620309096E21A686825B3FF021709810ED004976DC33831D413CD1
10DE5D757A13E41BC82D0980459AEA993B1A885E53B69F001742690F9808BF40
F20BC69852916113CBB1C8B0BD415D0A960D9BB3D7C125520DB431B4FA02E0F2
A2C0F3B4F0125A50D73227C4272665FDB30CBAECFD676FDA60B2E9FCEB294E49
F4B99BE151FE87CCF47A4425EDDAA7F4A05BAD737B2A2EC035EC3E98B6955CDB
8AC8BC34F46001319CBEACAF2A782AAAB9D1407E2D2E39A8D5497121887FC42E
F417E925728EB84608A5E95A17730962F63C8A84F7C40DDB31503BF1AFD89227
97D010E0FCA4ED09178A078B3DF00B0BFC2C39A9B9E5B204745C76D1D0DF64CC
1A13757E16CEFFB047B3AE8446D1FDD2FF4F0EB4576579693CB650538DBEA4E6
E3E77DC2D2FF6D901187ADFCF5EBB60310A153EB711DC797E2E645C5521AA45C
4CD84FE0DBFB12A35F89B50B87CA337D8FA4BF4D13E49C837A417C604CC5A5FD
F4CEFE4434A95CBD688B57D57EC3C9F1DAC88100D396FB795304C25A4E5B8E0B
3B7917BA23FE181FA5BDFB602C34241EDB333D1DF9E77A57BA9C9CF317738CCF
41644A3C942B0D7DBFC159E00FB693FE6EED3061A34A7B7F95E8004CD6ACD7F6
64D76C080D25C518527278DA0E93A283DB33DF941BF1D2A57901A431A7310871
84E41CE5A2261DD2E5776A1A85F85A9E50D5CD221D0EA7E1309E321AC3767C09
A995291CE6E759A2BBCA40C82366A40C5371DBC450233D242E0E257BEE60576D
C435AB5980A3D7A38A459E955F4BE17D468F961979196DF6FB2F2C13B3A109E5
0078AF0D3EE755BD6B818628AF0513E9E142E657E5E6F1AB98E7230F59A3B587
ECEB8350FAF929685C6FAA5F9EB92ECA3224261089F5EDD60BF27D4CA3552645
B83D67BA660D49172E098EB6F9535C3419AA7D44F776816A24AC8A56474AD40A
F38D0F60C1BF6DD7497A54689C50A72CA75417BB50E624B6F32545D3CFFFE39D
5C8D95EB8B14EF0E66EB181D25199CF082C7DDAE3704EE867A86A7255AF70B46
BFB257213F477D3F701113C3894009C96562613DBAA904267AA499AA180CBE2B
9BB2A9508C3A7E0BED06CF038EAA5E5842574A6A30CAD56F0059512322F7E37E
6AEB655162DDF0941AD7227F1F959581603846000C463AEBE2BA17C53786B323
5673599B15F2502DCEB864A068B774D81FB91B9130E6936AF27B389EFC2BEABA
AB06FD3DB73EF380C72BF8451222673577CDC316277D0CE8C58D7B0AFD3E3C6F
9533EC04B7DE36E62B46670D9B461C5B8FD26CBFF7E94C4C23E1A9E0DD7625ED
983B64782D0321FBC33A36E16B9D11E1D6C711E40F1F4F4ECE4C9838581B65EC
EECA7623439904285849847DB2AFC0A9DB38681252FCA11FF14BAEF2389C26EB
B2709C412893E6CB89584A7EB07972EC90CFAA907DAB25BD669A9A2148C86C5E
A285DC044E9038F979C4759B618AA3F2BD0889B0B969AEE111E75169858F623B
4F78529A879BBA682F8D863BDF959907D29E4930C538546D6B4C2521B30266D9
9A6B5E670356AFB931BE743C0CBAAF7AD64C17B4ED5D28E46BE565886D4655E0
3F65BA85903555E0B60F46E593C13C036D1269C3BD6136F0361F1463A922E378
FFB5BD509A7C81F838C1352A05CEC1747AD16E7C3D0454EFFF88D3C6DB47CE44
054DD8F09D9C60BA426362F42976F88660178B7B0E299550B81B6D1448AF0A2E
E95A22596E86FB8CFB2CCB4F1F587C63986A42B542F96FC4EA927EFB0E565364
BE720CC14216323CFD962A96DF8967753AA96964C3219CF0EE2EE50ADFE72C2D
111E7098DADCF9DD7109391F45E94FADD1B904F4CA460E1998016880D87F5FBA
B600E1684C521ACF25EBA39BE3815F5E4EEA8D279E04CCC0876BCAEDE0ACA357
859950805B191293D63D92E4238E710BDC1F1097D299968B41C274117B41EA01
4F1A93B7D99256305EF1BEE7737C2C88BBC0CA2AB171BCCFB881B0DA9DCF8AC4
C0BDE975818210F7AC185E8D49DFC06BB005EAF2C937BE6C9B2749EEF0D2850A
6B1A98DEEB6754D7E6C97452983EB4A1DFDFBDFEAC9CAF2F90E408841B04192C
7196089DA1381B475AA29D3B3553BE091C5E5407628C6358EC29D71C5F8D3C7D
FBD5380FBC4E3677585592072A236DA1C3F31E7B6141AFD4DC51096B86B5DF2B
B184B7A86D23A9D6C0750C57709FB4675468CFAF925FBEE3F36F8AE8997C1E1D
660281939753499BC7D4D248CA261A20BD6502D2A9E2B929856F457DD152DE1C
B125D85BD349E41B26C148A8354A4ED109FF3707E9BD58074443951306255418
1EA4422831848EF8794E72EC4135B35F933CE7ED8C64D706E117DE4281DE735F
5BD6A13EA61830D09EA755B42B3255DEC3D5B5AFF499D91052FD8AE73127D030
8406B1C14AB7C456D26C40215B98FE76BA3DBD1D6F2EE82417FF0CEA4D5BA1AB
C3C578521DBC80A565A81CCD913C000221247B8358B43FB42B44637AFFE2AE1D
7EB90034B6412BCB251E4E363F20A3AC716700FD203DAF0226E714006177B2AA
2913815B040E0B2B9573031AF9742392138AC91FDEBDF16A6090242436BDE531
A007D8D7C9910578DCD4A3365CC21AD90F14CECB3E58A0A8F663E60F1E7307A3
162086F239F737DCE787E36572605F1472CA89B365E9D9FD077EA391C8922ED2
BAD14E541FDA2669BF02D09C5DA657929DAD4FA1DD0EFF5F6CDA9F37F977D155
B85928907FDF4B928D2BC5F2734A2612FD558D28F78E93FBB48896AB482B687E
0179094C29FA3F0882B3F29E8253F65288EBFA21BBC85A7C2878AABAE13EBD57
3C7A473787A3D4E157EBE139B0024920959F61D0BA242F5FE84E969A1CD9797E
07C1069B69B6DE2F1F2F72AAE38C579752FEF3A6D47B05CF4A16E5B47134D97A
BEBD25541599DD68E0DAE5938DD6FC656A6FED78FE33164934D86E2F73407612
0326C42236D743A4D8980E5892C1901766A6477587123FE7FCC6185224CDF975
CC7EA00FB20AD59BD541AD445AB957D99D98533E602E3779DDAA29F3CFB26981
1590D10494BEF4EC168A52AD1982E1BCCCA10DC2C059D2ACDBB0186538F39266
CAFFED5E34F70561F691BA31643A0B7B1E1CC382E7C032DA97122B66E99B0970
0325A6C15093276E071E1016F30DCCFBDA67F6ADAE29019CE89981E6E55835DA
3EB3E3186E61A7363B1322C9A4713643CE6C8F041B7986537516A6AE978EEBD5
278AB16221F2525A8CDD9D44276DFFF4415537BFCBADB5CC21C11782ABDE1247
83E2AF586E27C2650E93A6665B5CA97AA25492F48B32096E99BBA217D9C12702
BA4F4A287BA295E555A69C09B9B2E13D84B035511F00558E74A2A50B299341B9
DC0AB6DAB870A8B4F7FB949DD094DD1E59DA20A8EFE4232BD56F60B7201065B4
595871B573BAC93A9F5E95E8354074785A57C5F46CA0679F9B200CEB625A2C46
BCC7A04EECFBDB8063860692D8961FA4C3229B25D8654AD3ADC8B4AF758CC62A
676599C2BD542B3D4285E54D25BF4271915848291207007952C5322E029C8240
6DCE7750D7EFDEC03F78EE6A9BF7857E7F55762D2E96487B3FAA216A16D5C0C8
A93E393144D56BE28375764BD1C519E630125AE03ABB958DC8888051E52F650D
2D8A6607A8506F268809EDCF7FD67F41027DFCBBAC63644FECE3F1DC5CDDCBB1
17DAA439A6A4C613CE0753666F37E5BFE1A7FCCE35E848C5480CA1D2A19D8A28
6C31B3181C72BACFBB9F0811023F22CD2985F94EFA1E618E4BF03A46E173079A
D5F94F4D461064A04A60F7AF92C35969666506F5FB0DC935CDD3E81C9257CA22
6B56373246804BA5F2259C9AC2FCCC8BF3C5E2A21F76E0CE5C9D7EF37032C728
129D8B1123D39B30DC635476117D38C827049CC401F71407301BF00B6F44EA14
0CDECA487AC35BAE98CC6628E51EBF4A27148906A0AB66AFE79A48A3BC9BC904
20FF4B8E11D075D8D47E8E39F7721494892434BCE500F78A26A0A0B05A791D9F
8C1E733A92C8B94D5BEA476C882092869C7F43F3D5998FFC3D6487C745A14389
EB7B27CA751C77328D1587D0DB079D53FC179049E054532B243BEEE3AC43FEF1
FF955C9F58B2DC490CD3CC898C6DA80D060BF3E1C1ED9DB78BF62EA8C68918DB
DBC72825D48264FFB7F6F0EBFAC5F98348D70CA13D96BD5AF5E9D0D84CC312AE
5B99CA89CE44379C031C3F3503A4CE9488B7277B4CAE3B0FEB1B6B608C92E95F
F8A661D05224B631DD1A67D6B5D1A4C2C1EA29EA44F05638D8F0E857E48A611F
EB52A12DAFDDD732C8EA6580DBC5E1319AD8D18A619F3B355B613AED6D1A5539
5DBFF7EA0FF9F9F094DECCDD9F43986E6243AE8587DFB7A933233D567664C434
AB0DA3E8CBF9F6CD7D335860730CA3D0E05C374F605A05FC4EDD40053E9184BA
D9B9FD75C42E5727AAAEC6FE4140086FD9F9CEC2000297C58B7DA9731FCB1144
E0DBBFA306F06252947B9622E13787525FEA11B2E0E000708A5BC1850FEF5599
45B1D5B29044C6B2085D6A446FD90725B633A330C11FFEC48299B8A026B3CA47
7D7EEDD79A717108ADA01F9CC65218AD1E77F2C9F704605BE7AF7719053233DA
79C27C1D6EAD3DCB103B9E0346824DA25030F5C206CF074E2ACA6577A5548AE1
D897A0A78C628671B204A2415D8333407C56AD63402F07562905FC6C3208A14C
24DBE03BB7E25B8BF03C3F882DF23070BAA0752629601B263FE7541B2DB7C9D7
E0CD879B9C6F31616FFF538B2446CB5B5152192EBFBF182F0D752E73611FC5A0
6EF45CDE05CA9B914FB53BBBCBF095024EBE14D3A0BA9C0B070524C767499819
371CF255F2C5BDAF9CDB68BE8608407B9267ECAD39B33097E6C9739472042C2B
147E4A34D9C4132937B34154B0E15E6019D09253DF5D8531DF6FE3FF0E6113C1
A0F8165D2D757E94536E57A10CB83E2B3AAE31AAEDE320A056445D056E01BE09
F60D57253B67C90FDFF6429109D12C9AEB2767C8D190AD1C8A0331510C003930
CD829CE10BF9356B6A73A4A68C8F9467EAE6A39A649CFCB8A124CA32D196951E
171AE3D8D4274C091856CB963DA61CF026564CE6F97FF74420E115AF317E848D
429AD13A4C819B18B08095A07528C834007B5394E535885CE13B5143CB63168D
570BF027C2F927B774C765DCE4EB39BA2B76F03AF3AEEEAADCF4AC7215323DC5
C067B9FC8FCCE175AD8AB403005A83BEC15AC45C83A40AEAE90A5DFCAEDE5962
2A2EF7918616275D53AA30F09A4A686E21504A253F442DE07FD007C2E6FB4A94
984BA71061D2148F2882141250729CCBD175F000ECC75B1CC36E16022D28110E
8DD2B4217A00A2D1EE379EEE514E0EB5D0EB01E9169E938463C1D510072E9415
66295D1816086593CBADA6B5FD69CB12B0259767D8E63DAB7E4A220B50141288
B7EAF92E4279CEDF3D9257A728B78F0ABAA635ED3F627C4EF44D186BDDCBB1C1
5B4A024FA6305A1F446379175489CF225B3383C3739E30794C9DA6CAC1DCE1FD
8B27BCE943157603B0A317D716CDF0828C25C7DD412D8AF3AB7A8D39A38DFC2F
B09074E88CE835765AB686E00C8E8B145BCED5493AED6F7C5306199FD6AF0128
F7A626F8A2147F6726664931D8F36D11B27F8A1E3CA71B3F973E0E0694746186
3314F674702030A3356F8827FBFCDF4F00E19F48ED38E9F0CA25E69488DF642C
BE80A48A2B1862114177E562B6B6620FCBB0A5871E270F4981DA75C803BDA8EC
FC9BA3261B5480BBF066C2FE27CC11952FBC56B95AB907813638EFA565CAEDB9
9F36FA1A16D0A79026E034B23E1A31DB992E804D0A719CD4E8F548479DCCBED1
ABE475FE35EEA451DECFD18B26B1128B5ABEF2F84AF40F4E58304AAC2DA8C65E
12F2561ED8440DFB26DCE67BD992B553560568CA3F6E7E9585C5FA7C7079E372
D05EE7D0DB8FA58CAF8A510C59E2ED37474B6B0FB3C7106DC4C3D25B3C587DAB
F1A685D31683DC55CF4C6F0524DF72974B75B2FA84A4AC427E78063B7A07C0F3
F592BB136F41C338062D4EA75AC5843137AF0EC4FCD771914933CA8DEAE07099
B16063A9EE60D6840E209C2254840773BCC1E8512ADFD954845CE81845421528
AD133A26818679CEE6F9C59F6FC1211A48D16AC13894C9156315D7BF174FAAC6
A2DF94FC5A030E9658247E52004AE4CE54863CB2898B39E2671F2AFF273AC239
ABDCD321438A2A99AF87086D986D8F4A95221FFA9FD3D5CCC67F835A30768071
9B505DB1DE1FDA800FE0A2ECA39C569A573A79CCD0495A9677AA9568602BAE65
6CA4B939B110E435A6C93C4D7793E55DAEFCDF472EA459E0E1230977EE7D7E3A
3F9D4B2F42A572E10581724AD74A2CCCE77BADAB3DEFAFF5117988FC94009BFC
69A4F3DA17340E96AF48E894EA5B5B450E3DA5364DAE633A191105652871F96E
0C9803BC9388A04B2E53249756EB3A88AA0A7F57A7F583E13D0D9651F41DC75E
E6F7F90937F8230703B7782BAB40B6BB5A676561BF61C8922C000B0537FDE8E8
E7686A6DB5AF9FFC5ADD3D1982209E9DB259884EC257C1123A42021D85C50EF4
C2991AA96DDF4F2B1644A36FCB6F8A8B93C301A8319C5FE61A64BF5E8BAFD59C
3AC56AA8308056778818E798C9B19235FD0717CBFA4679C8D20020081161208C
1680D7EC23728094F3E95CBE949EF4B833D951CE840F1F0F037DD85FD5B25EE2
3E0F19A5BFEF3EC9C9DB5ECCD01FF0497B4828827028654DD939DDB00630CD51
26B33BF5AC212003CA1DD8DF977C4C06D2A398121942C400E92CE441B8B6525D
70B5D231FE5E26BAFA71158D1D32875913527BC0E6658F7F5A6F1A68BBA56C3C
727D60E8A01B20109AC8A08C0368F9F90D9C77BD85D66D61636FAADDE4BEB556
0A05899D4D1DA428631192A0049CCFA058882E238B34AFF7BB6CE48E7FC0EADF
3FAA51A7D9EA54F27832DD190335B8794C03333311F4DDFB16E70090214481C1
300B4CE6A4305ECFB83AE2AF651FC75EF9B65C43DED9057DDFF852E4A562E91B
485996D69AE2935F81AE1AE673AEFBAB1B81CDBBE480F4EEC2FCB08047398980
AA50C18C5CBE6C2A91C528120151C98ED0EEED0435148D954148A63E3B94F286
97EEC2A9F5E7BAD96532AC0E44FE4F1A0A89A9F1617B2355608AAB86713AEB5B
E37CF9E5292F6BE24DED4793096A62F675169BAE41BF058990ABB33B93DB0B58
C52C99EA803E18C3EC21E91BCA362B5E8D633AE30DBDE3D19EF41866682CF476
1B7B833A51938B1CACFFCDE63ABD425AC879D7E8F0BF84815DA57679E2C6FF64
EFF9A4EE8D1EC876BEE8E218B3511FF3B796F29827B6310FEEDE5126DFEC5ADD
5C92A6FBF7BD3F1AE74F89E2F583C4AB9B55FD1CD5DF311FA2F6A46C3997E87E
75178791A5B6025D16B05EAD2C398C8B02240FD1EEA4A9D8FBBE315888240D52
145DF460348CC94B0A793201CBE6CCA897724ADA553610240BA6204B18741F90
8B15918F1B2619ECD874C5DFBC3BB5E53CC12557D56D42B1E77335CD4283BC3B
0C9EA74C18248DB5E457B25F1E0DBAAAD50CC3852562DDF81F10A771F756AF24
C1656103BDC50ECBD9A7194EDE4AAE7D71770BC8856CB5EADE4935606F3824FC
58CB3607003E439BE1A5583DBB33FF93C653FE0D9D34F7C5D910CA46D6766FA0
1198F88EDEC7578C9CD3B56774E35E6A9E4FAD3BE5343F616C04DAD3DA73277B
725BC8459B520D1D09B698842C66CCBF9FB7332EB0FB51D0925CA1C459C4979C
D0A399430D3DC3FF156B5828234242D859AFA10C3165E4C035D2303AA65F51A4
A78FC2B50BD9B928D13EF9AB2E76628DCEB39128E2DD1BE581D496963504B2F8
0D65C79709531ED5E653F3876022F31622843E989909B44CC8AC84464E13F0A7
CE3A22082DB051694EAB53619B7E0C2C4555E13DA0B4D818EB8614DDDB927F5B
3BF9B315C9F68139686D99FC6C149538F6615D460B5AA814A25CC7FBE5464EF4
14EACB1761CD177FEDF18FB3805834AC5F5C9388C107F31D1D4F833299A46D0A
03F699105152CB1A493AC718C18A01874C34BA1C6D2B3D771505F0C808FC3DF4
8D557672359EBE87F395BC078F505924081847B16DD373D8B725D220C7917389
BAD25276BF53017C3DC55A0FCD9515BBFE8EF5684F06C52A22C34ECD3775CB8A
B8727A385275CDA64F291A0189022446D9524C8ECAF12C86752102A42E0370DB
F02A9636E89EF7A7AD84593AABFD54F7085F54B26FAF6D73BB836CFD53A03B2C
CF128C4F4089AC7E098233AD72AE8521883576E2AAE7D8EC517B91C1FCED99E8
0BE968CD37CD3DFB261485B6030994BDF91AAC0BA2AC407A1A91344648FBA9A9
3CF961399EFC6843E35E01006AEED24264851C4312DB4D59D7333F31ADBF6F8B
1000E8E0FAB2FC22B19808469C49A4083CFDF7589B17663A8C44065A89B2B94C
55B36606559D583B8C0C9AA639BCECAD2CF94B21A1430FF4FFA83E27BE714736
3E427949D3657744C665EDA7C8DE3B9692E7A0DA07B8F967D7D5939CD0153A96
37747C4DAFFB2B91074C87CB5F9D3472B51A20A27258A8D0ACE7A8413CB11E8F
F16D50DC6886A867E874B6B663D045AA571D1CB29505E073F613E8C5CD0AF1DF
0E5657BCC8404A36DB4A079CCB685091DD8BD7AED87F7E9DC7A793605BA3D670
E7DE363A04FABAF3BB4A6780A65408202D64F17FA59D380C43040D8CDD6C1F5B
A5BE1D5427863E3D2826B48D03BEC53BA7C6FC8AE122D70887FB78A1675FFA65
2D04D2A3F7F77E16F187D6EF52A277EA9AEC33475BB13860874CE843D3F4F9DA
A3401B6A9C57BDD2CB8DCEC72F3B60508154B0BB2844FBA68284B67A15DD0A87
467844246A646D34E200D9AAFCBD52B06FB2002E17EF20E3C79EDBE0084A3246
BAFCD57F610B204AD9738039838BB87C04842E0406D0770CAAF836CFB392A29C
10FF23883099832AAE954D0E9CA3C299DC5543182AF7DE93337F317023808453
277ECD52F191D509BE5F98BF0B806FDBCC96BD4FFCF1E22FCDE84045867F2125
1B1D3735B67FC61795C412FF962A0C305B94938B6CA6CB9A4F91140370CC7E73
AF103023456007FAA6AB1340719657BD6A7A98BB2A1B03B500C80C94D0D19940
BD3B54587416A15C0F25BE8E7DFF629137D36D3285466FC08729B21C4CE0C59A
E3F0A9618CEC31A56A5ABB558DC3FE6C1A50C18264243766F5EEAD3986F24610
373E176376670E3C0533EE681E5E368E8E42A7823EFB775842E145A359135D0E
D916033173C1CFDDDB8C73B21F8CEF1C4DE4D921FF1D07F1C9CB3E47F08CB2C8
53F4C69BD08B223F1FB3AF7ECEBAFB9C39BC0C9816E31125A87EDBA919866204
15F00D7E79AD42E7BD446CA4D7E64BB4ED16C34954C98647134F9371E7BF2A4C
72F9273B3ABE59681C8CD97CA63ACEADC667D4AB9FC6C329D81A7584A5E2DFC2
A6B3B71F81FCD47FC7338A1BB2524D1DA414EE6B44DF3AF0F3BB0EBCB2B99749
E610D026FE874A3995DEC573400A9DC95986443C0883A727C13EBC6D6AC9046A
B67ACCC68093D644763A94F4E0131BBB42EEBA0302F05B67269013FDA935FA86
C0A0F6038EB3DB7F3D3CD0ABDDFC846DC19203559700FF2E10DA7F6F6DD14D1D
59B023B3AEE83AB15AF7820869815377244A07722D1C66FEEA2D504C13E3B3CE
FAF9DAD18BE6622E7CBDCD49275E37647F60685A0D9C56CEFF1063C112263E43
0D9B778401B6F8DBEB1801DE2C81BF75875073104FEF078F60590335227CBEF4
79DA9C6EF483D1046E1AAD0A95DE4DC41FE95879B4A1BEE4453C01878274BAC3
3405EEEAF0EEBF3582F1321D8EFEB37CC5EBA8D9F0CB977E7FF9545C33E3A872
7A035C6E837FA32E537DECF1A11D139EE9DBB6CCA124FC5F11B023A244087C6C
899A8F7A63FEB05A3267826830A2486F985F61CA0E3E3048A26E20B6638AB9D4
FF6143BB59339C5E0220FB8FDE9D58FF7CFE2A9DD7FE65EF6C8723B960AE899E
EEE1ECA969448D584CB47DFC696ED862C8E8F64B57A55CB3AF8DFD5AF41A8DB9
1E627A1207F27FCB125391F0D08EDA95723F609835D9DC31171DCDD896EB0112
AAEF28A6AD6DBBB36ABC629763F67FA13B81938EE0AE0A124BC903684C07F202
205FD1ADD19DE618859C957D0B8DD011BD67682CA8BA5D1E02AA624B2D77010F
7B56E542E2C34DD94C724D34F42E59AC0FAE7F4A952BA42F1453D0EE9FFF6CC7
07893A4CE16FDD7E2DB73D4474C9843956A241C90FFD91A30617BE8FD563B466
3F73FD821AA567EA65ADA0703D3FBB5282962120BB58630A43387816D8FB6C59
4E1B6C227805DCF438CD9F7AED155714ACD40CB03D0F469E4359A634F54FA49C
F4FE75371240A7C00AD974CFD92693876FEB436C6A6C2183EB49EBA58C37C2B2
F30E5D2307B7EF8B7DCBDF521BFD0A35816D4833FFBEFB6329E484260234A495
777D9E8F6D35D04F16E0FFA96702B2A871F588D26DF68A04EF893AA22EA36E86
7F5341725B73F6E22A8D95153C952A0CCD0D4E15BC0A01BF04BB7F34C33FBF2D
21D28C0F0C6DC339A048B5867D728850F130A9244391A83079BA74C8A9744526
B6C7048CE5551FCA17CE75330CFDC3DEEF3B6773527ADB2A7BE9033257BC15B3
773C8AC36B8059954E81CAAF2AC2A3AC8EFA7D8547256E3F5BC94FEEE84B745D
3CAB1071D31F7D8FF737CE8228671097A421027A4F95C88BE390A770D704AD81
3EB9B9D4E45FC9C3919F7390481C9B60BF8CD7CC9BC30E757CEBF5D404BD7640
3BBF553C2DE2CEDE9D16C3636010463AE4209F5F1529F979DAE7ACA3C8A63273
06B69B44F1CE0E98C91EB9D5A9EAF4ED4B8A85D30563096B03906C4321A66079
764CC25ACAA78F164C8E670FADD8CDB833645B818C34402BD44BD6DD755737BA
5395586B4DD29DE4513AD05F6FCAAE4BCE32995ECDC83C8B4D7DAE6EEAE1F7F9
59365E6642FBDD83503D108EFABCD32E66B851E47BDC854CAA2A9658D2BE5527
A74A0185D97EB15AE6A4D855D3F798E71C88293D097DD746A1E88EE4E4376EE6
2DAD3F671582D816DB4742340BE64D415BCFDF96A071C2BB5217189EBCAA4391
030F817A990DC8DC506F68407693D54445CD335698377F78DC842589D89A115F
399D6CD104173F0CB98FFF72243AFFBAC5936F1E1041C7C9F9A713EB6B1CF214
8002F9A6ED9979E675BAD8444BAAF32132C691252495954BE08A25FF4A75F5B0
38EBE06639B9523164C6B1362B779B16AAD7B6B4038E602E32841D449C841E27
4A87E45FE589DE38FFAD2605E2F8B9C28DFF4D636C1D143E8D648049569D425D
85FB58AB983094F4E255E582774E66DB0716390CAC3B657571C0C0901C857EEA
2CEA3E71631E10253DEB5FF410FFD50954E3ADAFF81BA8EA8CD328F5F4B4193B
06AF1B5FB4747D8A5C6945A12BBB3BCE8E4C2392172BFFD10BC240C421210326
3E2A6C377709E5AC07A93715C6B0B7F1601B2B5AF34363C0EB2D87A7BC96C8C3
5FD9442C290FABA3A44FB69D0A10A7E7782CE421AFEF2BD97F4E938B969A5A8A
520315A0FC71D709B402715E41D884005210DD51BD52332C08563872CDCC2465
A94804FEE28288DD97A987F7CACF5D5D79E8056E05BD2310AD33D22F4032E1A7
21856B048B916E0C53F4EC10F01B16A9CC1B8ACB2EEF2B425422454C05FDD3EB
10F2536E1902E82B66A50720D5E607D21C4C6B5E4238967342D7714172F78FB9
CC566299A1F7155F6226D25D4BB6966ACF3A2EA15FE6AD0DE22EAE2F244E4B3E
A742B23260EB81496F956627BB12800B42C6E3CCC0C03A610437CFC4AA0603DF
5CDF80B05529FAE6F3FCB066A93B0D0627AE2DC8DE153B1DDF23B49B76507C7A
3AE6B8ACF953D2369E33AD5279544590B29523DCE11A90CA5B7436369C0F4198
8BC0605DAD4036F7915B4483F340E20E3FAB735FC84B268C51B824339AE3B6EF
4FEE04AFCA4551B26AFE9CF25B051F270C8B92398BA1ABA804DA2261426BDDD9
DF4E151C923134128EAB6A82D16CA6AF635ABE83DD748E267B3A50BB15FEBDC8
CF5E2876FB04FFBE75EF50873AC01A67FABF692C887C647A3D05B21F2D844068
29CBC9375FABE34D60E788089CDE2F0CDA992186AFB1C1CE0D27802FE0DE5F70
8F400B41F28F26C0F555C88009D9A55C99FD33513578CD040F7509F0986E0C14
0F4899D33317A2B5866BF2DE9211DB5882C85C0CB015F6CD3E4A1F870E3626DA
57B681AE720143FE320560A08E57B814ACEB2D40C793AAAA1B74340E75A1EB73
84A870A673667C5369467F0661663BCB4C01670A0518BA88600502F76CEAFCD1
246A7F703742AAEA702B26C72BCF3CC561F55E0355AA33D342301C22DB39B879
31A33A1A0DC22EE6630D6DD0D91719E269D722D9E4977FD2E4A6CFB431DFAAFE
F53A924F29FEF6CD671F232517AA77DD0A04ACF56C51059BBDD1A16EE157276F
C34D2809D0EA1958E171FE2BC22C4891C90FD14DBE3F911FD8DCF1CF39AE522A
16088E865940DEEFC4E06D7DC83F1C67B8012BCCAF89CA270A5C9A63E3118EEB
9CB0BCE1EE6149F64F240498B8A045F01D1BD6B8843AA8E6111AE1F9022A8315
1E7EE3914E0C8E881F5DE491EFC654DC35BADE6F4F190838E7EFBF8D0C635736
0C70178D13ED72FD34DC36FFBAE7298CCCECE778CE7835F478E263AE7407A1AA
28549A67CC2A7A0BFF209F4A9ED61562F06DB8FA8A0D07D5A93A43D328D93FBF
FAEE1674E2D1262E3368628477F955343C40077A99ACE7370DC11418D38CBEF0
F16FE2929D04D1D0CB2CC4DAF6C229E1762AE3E939DC8D23EEBFA40DA493B708
32FBB16B62D3C3BC3AB4E74A7640B88EFD1F8C903BE888B26C16C14F25607305
C615C472CD55598D4C479DFB66CC0EAE65DDF37E26AE1FB84FA57879E638426C
02680E6017AB66D03C04A8E1B87E90454576D470080B16A0D115F07F03CB023D
21DAD4A1B9FC4F807EEDD00FBC2D8F194CA32DDC3B101EFAC2342C29D52E9540
9ECAF9BCA99FDEEA9FCB2AAFD303FB91E013456495665B246D0F370BC97A8E15
661D2A7A5DA60505FD15416D60CC1F17D9F16BB95790DCDFC79D5AD672CEEBF7
25AE4982C761CE78401F9A6D1B61F4172EBE388767AC2EB3ED7FF33EE876A9C3
63164FEAE857E1F926FCC572CC2FB927CCFE62186B578B6489D4A3B165DFA64E
27FEB0357622F38310E7A63D6D76B5D7A9CA15D29E3132566C430D25251A646F
C3A42BD8984AF87A745248A1C150948B56C5F47504A0D172ACA69FAC8CD06EF6
E640A7ECED8FC5B856247311F18D9343BEEDC9E34765B2092F401A70C28C82F8
967DCD6861709357B483C438451D7350E94C705E40BD3900983F8AC35DDEB9F7
7BB874A63E233D0CB484D0B7A9EFD1FB7B8766B6253C28EE49FCC2F6AA50EB7B
1502547FFE7D9D307EBDB72A8E20CE8414C1C0BFA91576DCAEE2E0B8DB7B447E
684CB5BE6A902019284285C1B13568B2E84C4347445796CBA98FEF57DD1154A3
7EC09AF92BA3CDEEB338396052D84D50B820DA23EB73CF21E98DA94754D55031
550B9F7D314DB6E6D8986CE1175CFF9D3E73D6713304FADEBFB2D407DC6B0C70
1501F6A4CCFE747B9604AD1FDA8FA8F7F8D10D44929463CEDA4A44B8D78821D6
74812A37E76810C60BAF765B17A32BFA641EB887744D82A1CAE07C00E677EE3A
749B4C65C1CCEFFE6759B564C8AD4E031E7651D0290E8C93F1406D8C0E84B7DE
22E98593C6EE311311950AC80E52CF5C0667B676291B9947C694C45D6BF7E869
AC1F4D4C2FBA1773D8A37FFEE1581682F59EB5758E50D42DE7BAAC743415F89E
08D7796032F260DD7E5A87599E1764308385626802EC6E1C774EA6C79A74A94F
9E3EB6460AB08FB28E1B86D10A8E9FC2835750304AA7D5CD9810C00625A9A5EA
E0F871E5F77283FA7D2776486FECA36B8F36EF3B61B64BEAA7260819AE69F718
ADD410C36702FB3C23E0C561ABCB5DFAA10EBDEF784E38FB9D1DF6FD69CCBEAF
F4090C93DB84F3C4DDFCFF4F4527607DF17EB7917D028F3543A719B292B83803
34A646C175330970C4B29C215AAF351D8B1892E791FC6CD55C809EA997335CFD
504C5E8F4DAB454FEA9CE58E05E4B64890815C4D0F99BF4A7DC9D4218C5D2CE8
E76019236AC14295502F99864295D314305084A9B39735DA5CDD7B5DED411A71
64643F6DD799E406BDAC92AA3DC3B3C0BE7B451E79635C45E9FFC0D2FBDEB2BD
17DC0987CE11FDA25FAC28303DB5CBD44F52AA973B3A18A47696466C91EB2BDD
576E57D4305FD1E06A6E0EFB02CDCCC5FF4B4E6266C8135A00F9555EC5700EEB
5474CCA360D871D829C09CF8A412A561C153669FFA9F8A0F3DC9F9946647E18C
577E0C4BD66E7B8201BFAC677BF418AF7707F38117B9C90300F799CE84B98630
185BD07522A850EC04E312833ACF729AAED944A2B34699C845A0D700B3EE9A40
9932548A9A6E850F0A1F59CC55101175087D0D908EADBAC3CC488458292FBBDE
942545CB72BCD25E5CE1DD6BE2FAD70EC5A6B26472666EC54A104F474B6BB802
7A4007AC48F2085C054366690A7AEF52C85ED8BC454472DABC57F84A3927C3AF
10683E2817DD1B419121F73A92F471BFA28919978864AF3A2A3B031AF66804BD
824C540DD13F0BE948459DE6BEFA0691F3EEEF8FC50CA17B7D3B87BAD578A6DB
D511CFF7A81E66EE993617C73AA7506354B999791CF5AD5B998611D002232146
AA3BA4C465A3A35B1EF7BCE134D8CBB4D564D6F4F2A8B315D11CD401E91199D9
92A3B94C5153C1C0C913EDD7A8E59761EA175CFFBAD4449281C2DDAB22E27BE0
57B2156C10E9E38254594DA32EC8A95AA41D13815C016E7A482CD1996599DB94
1E330C3AFB34B8826DD3D544EBFA1AC7D6227345D0B23A761B1D3152B5B5B41B
81835D2AC1231308F3C87C9EDE9ABB0261939D9C7010EFC203BEE28E1F39EDF6
4DAA18A8A9D4F5678623A3B376CBEA623954E749B6C0D37793F228DC74DD405C
430273F7674C70F10B3B84CF570C2A67677B31BCA614AC2D82646173C5E7DDD7
80BF7B8C95A6025F590E5200612F9FAA14C8C2FF63073EAFA6B5BA44E70FA9AD
7502BDBC25F773BF4E72600E1DB01EEDD7E94D3758714FB64F43C02C1C158B6C
BA153925767EE70F6AED4EE2812F4F888D04FDB4113E29692A4CC6703C7006E9
F83F3AB24598990A8BCE50E3542192E38897D61021A1731D030BD055D207EB38
3FAAC90030818380C1496D5FB6ABB410443B0DC5EDF740512FCDBF84B7E6F8EF
279F5BB05E6CAAAB9D704BC9B4A3FAA2061B86A6A8D6EC7A8CAA1BB59B48711F
400042377A95ED10E3CC3D15DD90BD765018E6337741D5378FDC7D9E147985CC
CC5ACB389884DBD15F737E9CD7F82D1C7D76E6A0D3512DAC05A5AF951E389945
20A1858DB67E9B49B1ED6B39AF73CC14C21C3F225D66841720CEADA16E15E26A
E66707D3BE1795BA3EA6C1091E9F502FC3A03494B2F795B38B1D21EEA0DC7235
411451A4742C073A736D834B5A8ABB4B1B7C6BBF204EC5124E98BADEE3F764A2
7C3D55F194F20D597E2F40FBBAF6FB1405318375D35220C1114DF3AA44844C8E
AE1002751F452373D9B19945F3FEF360A42535CF53AA2BD6B1944B13DC1C4FA3
64EB988F759FD597273B3084969DA6CE38A1B0CBF035E7274DC03A457F55A8C4
6E41C06BA59471989A0C2650A156230C188C0DB86ACB74F96E61B0A0221E3797
EF1DB23AB8FE577D2D983BEE0199C0971356FC4CFD02BC3AC07B6FB72067E95E
CA1C615C54EC221E33CC14CA1A45F02EF219126BED8454B0E9AB6E95CD2DED64
499BC2BCAB9EAE56ACAE368633EBF72884930C355B77758769E755C352EB4346
2B63C7F7CF793CDF5AED4427E271A81D89B23EC2F2A00E45EE5B766BF6432730
80C8DDA5070A5110D014D6FEDF8382ECAD42BAD9710BBAA3E5AC62E8F37A5103
FF8602191824AFBA1D4F7B7ACE3AE46ADAA2BE55B0270415FFCEB7C381170B31
AECE2D5D606F49AD222E15B6F1030F3895DA625BDDC7D3F56E6609FB3F0809EE
8E2702BBF0207CBBE3CF66829AB4952ABD2A67E651F4A00219F4FEAAB75EEF56
9C40D2BE2E5F6BDCA909B1E80AED0A6C594599441C88F6A62E6E3C0239C4C16F
BA8B4664410B81057CA2D9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: MathDesign-UT-Regular-Italic-MathItalic-10
%!PS-AdobeFont-1.0: MathDesign-UT-Regular-Italic-MathItalic-10 1.51
%%CreationDate: Sat, 28 Jan 2006 18:52:08
9 dict begin
/FontInfo 10 dict dup begin
/Version (1.51) readonly def
/Notice ((c) 2004 Paul Pichaureau, under the gpl licence.) readonly def
/FullName (MathDesign UT Regular Italic MathItalic 10) readonly def
/FamilyName (MathDesign-UT) readonly def
/Weight (Regular) readonly def
/ItalicAngle 13 def
/IsFixedPitch false def
/UnderlinePosition -98 def
/UnderlineThickness 54 def
end readonly def
/FontName /MathDesign-UT-Regular-Italic-MathItalic-10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 61 /slash put
readonly def
/PaintType 0 def
/StrokeWidth 1 def
/FontType 1 def
/FontMatrix [0.001000 0.000000 0.000000 0.001000 0.000000 0.000000] readonly def
/FontBBox {-57 -270 934 789} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC4458BF85598BFFB688F90ED6A048EF34
1E514EB44F263B92302DA62E5D3E0E80DAA99252B0357D057396EB1F16BC20C2
D373CE5AD9C56779F676BE22DD8B5E288823824D460C36D4675A1E5FDDA0BFCA
B18C8EF171F0C7D70A7CE68FE415C852A99C172F20DF292CC04BE996D4D7E022
85BEA198A6A52B56E0D4A7AA76546CAE6E95496F58EF2373667756E9DB93E0C6
5F643442DC11AFFCFED478779F29D2E33FCFFB4AF8BBD57E026444829443DA20
793A8A0DFEE330711201A681335D7943546B6A977CE340221A32B75C7332B6F5
7E9638700DD1492BFC5FB85571162621039F2248F922D9E8778B3B696D6A8C0E
4C2CE0F342B73497FED99ED4D8EEAC2A0528B1587DAF42D7F23D00B94FF4ADBA
EC3DAB5D6E302C8F0739FED0C3AB8EC6F6835A5B821766FB207D3CAF6D6C8F57
9457CCDD4B1248AAB5D946C5F573A9E137CD136C7E349863164AE44B940F4CE1
29B16DC0AD577E903F05D1CF828069D3877921DEE00ABFF5FD1D9D3C3629AB02
1890A31A879478E238C02651242878654342E671128058BEE997A0C37C173900
83F6C59804BA58CB308DA861E13F85D84C241684D0C6D5F0D19A73E154C6A122
12B4120133D5341DA7721CAF7AB5B1D3D7F3A046D1500308379CD0CA1D120B08
07A0C000BE5B66E2B287A9F7BF6E04B9B1018E1C46ECE17153EC9041723F8415
F928DD92466CE683FB961DB813EC36940B166B3DFFBCAEC3B23EFBC23BC42931
3F35C1CCDCD66D809091086399CE73990716FB7ED9D8DB245494268AC823CD18
D90521983025D29832599B9DB79316D34403F2A0AE14F69427AB9BEB20004935
EFF1036175054AF40CB40B9FFF217C3790FC431F77FEDCCFA3BCB29CCC03F5A5
316E8EF02AD00BD058A67AD013F401C4A12D72524FD4073B97BA7A8C5862E253
BF46A920CF87EC4A7C16E7B180AEA340AF5A231F759EADCC73F355DFF878CC6A
745DF9BF1D540E680D6E38FF2F191552277DCBFB896AD5F4893E775126D4AF04
36D5C1F4277D903DEE2A91C25DBE2A1DC92860DE02A73BAE936EC6D356F58D52
2F65415D11A31CA1CD78499E3A70D1025383B70411FA21ADD172507B4BD0D8CD
7939284603376F4E98FD45919F7024E561B28562102AA1FFF33AABF98D7CC2FF
BDDBC93891A7241AB06B6490F7B1855F41CD00A116A46E058E8F07EC2ACAF07C
9C53B766F9694CA73D5AFAE067B8FC129B33A40C38BB1F69F69112AE904376AD
D97AC0CB718A866D0C6314F75C6300E4B577E3C58B941166C16F6C6361D3C1E9
6E17AD82C65D78716A64E363591C86F988A334E3D26FD6DD41384C155A789FAF
6A18DC9B42E3255D9F5B6B98BE29A04D45B7E273897E49595625A12279D82E72
57C05D1C52BAC0A57D87572F8FBF25824F2D2F067D05293832D071DCB14BEB4B
D9FD2FC1FC8C4F06EEC9D76FCC7704ACA9AB8446E40547FE2ADE9EB5B3E91A2F
2161F705D11941FA5008D5AB1CD6C8394DDC136C16C2109C8762FAB8989CE9F9
9159D73A23934875D1D1457E4C9AD1635BF626E2180F13B7974BEAEADAED78CA
714552C153DD1114B5674AFB4FA98B410E0DD0A02E3D6A7B92D2E0B2CC1437F6
1C8FEAE8A1DE043AECC7FEBD79E7BEFD19D934617267CE67186236C1F9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C5A68EB2DFA8D4DD83DE61F3DBA36E97E3B9D
03598A007ADF0105B16288C6DA4E024850CE068524199B057DAA355E4536EE0D
736E89C40EBB32B4A86D360D5BFCFCFAD31C18487F931AB032487BBD966F0ED1
8D81410F813119C112B5BEFCFB76101C07F53D05B8BE04D971C724DB2668731E
96F301B6CC25D531E86677AACE3EA3A91F0CE66E21D7084346CD33CBF25CBEF5
D472CB4C7650DF6FD8B3B31F630AF5107AAC6C8EA23373D0BE06E4C1188B7A4F
E59DA23C2B6E2E8E94CFB4A81105C648AB572C4998ABA63A89989A282337B556
2C601416984C2ED0A887B5BE606C3882B8E6E927CFC26313FD9D352D3A7BB065
9B58D13BBD84E1216C8926D2CB3CE355D958E1FE80BC9701C6ECBE840E637E64
C347CC94398B881FD0AC49E530DE619BC49A5DD9F91B4766F06D0F943CB8861E
D69DC71DEAB42CFB71077291EA019468902186EEC417AA6A483E768886444090
2F283615BA3755E3944C8D5D5408531605BD13EBB44A71F76248B694684125A3
870232C3CCA4AC8DC1EF163019E6363883EC4892F625C6CACDD72C726E008744
F8383B33D234761DEA8497856BDA04DD10EEE7043BEB84C62D7B46A094EB3699
CDB1A9406679EAE94F1F933DE269C7AC15CFFBE660FC1E5A4758EA23EF14001D
4F6FC6FB27FFFD254B345C3C32CD7F70DAF4D48F9516794CA4BAF0827AB41309
AD1CAE4940E093970991AD11C5A830E17A51EE27F727EBBD0411E3DB595FEF8C
2501BDAF0235FDDC02683334FF508FD924B568EAF96E7344A565025C2ACEEAB5
E059B2545EC497B4599F155D652C89E2F7F8438C5F9AB06D6F945E70E7A91F26
BA7CB2DE1D1388C75F569346AC1959FEA21109882780DBE5A7582180678D9CEE
63A5FB5DC7454899F13A930EF1A537C0EDA7D4C76C855C45BC12BE221823D9BE
B06F2A0BED0A6827BFE0304DC92A25B84E14F382E2740428D5783947962415A6
3B9CDF789AE3070BE336348745907A0BFBE003908350E3A8F434D382F30EA747
F7A0D539C1741E53F46618893529904DF7678AC70610C77C6A63AA336AE0A2A6
0A0D4E9B9A8B87F8733A395A95680DB258E429BAF4C2173AEBEE92747605A534
DDDB4A6F978F9743D4F66FDE43D7F1AF0936E3B968F041096A1C38C146521F4E
AA2AB5EA68C57F7F6AD56BDF7737551E662D293034CE8DDB7459FE830C2714A0
7ACD1FFC9D9C3CFBD95E989F400EF49715BDFF46F1AB2C3BDE3991CE58A3DFC6
928B4A4802EE064E3D180A2E97CBB7A8F0A01C8130F81F4EDC87293390E2ED53
A03C5355FD40EDAADEA97C9E362C98ABB00474EA58CF886B546F22E6340946D2
3E445FAD9F901D26B254842B76E7BBC0538DF2F8252B59495A5FDA5514308B6D
D2C61BDBCA46785D171D94F03151EB9F023BEEE0F425108529468B1BE6DCF2EA
07D80E163AD774E3D20508D06FCBB3ECFEE9B17E9D26ADAC2A9DEC3DBE7CAC2C
BA2170132AFF273A24F46DE5809B3F0C4D8ECA4318D681BEAAE203EF7E43662B
FA50296AFD5312A3E6AF9D70480FEBEAEEDC9512B2ADCF92BE7E9636ADC6BA9A
0E9A9656CED23B42327AD94D68EE8D98A8492917E0BC314E2DA4F77AED29E639
513A808EEFEB811E28A9B6F6EA584F5AAACB64B05CC9A872A040076CA7B490ED
937402A801F9E0029CBACE3AF24DADC509DD78BFF19D4205A1A09B3A20D7FD1A
F374025BD6CD3A2C9558319D356A7CD6076927B8230055E3BA59CCFB24F42091
0F9C8FE95131767EB292F9A239BB81496BCCDB12EB0B4362F38F994FE92FD3B6
CE9B584ECCFAF571E03D12281FCD91539CFF28B33E6A57637EB77CF7193CA644
E1DE0FB783CC1A863887BB264607F6FEDB0325998413F733CE2681750BF5FB5C
24BBBDC24B5877DEE259BB6F2E43D69C26DD0B3DBB903AC7FFFB3DC12F251F8C
A9388E22D254BF9F8175739791C91A895BEF70C272431F91B8EA9A0A2C866530
5BC482142FB4E6AA20ECB3CA6BB47096F043A4E05ABCEC025FDA253BC020EC9F
864CF2A8581259BEF5771154CC2F69B7AE36ECAA44E041678CEA2D0042CCBE9C
04628625EB1F97CCC0715D60E8D5D09561164EBFC3B14A86FA11D120428937ED
47889E0E62E784122D4676B478D947ACE5D87938B75EF5E2411E623AE97C93C2
9A9C451600D3A397BE2BFDE4FCFEC619F484DBAB0A1CD8382E8BBA514C679BD9
000FF23382B628A2BCEB6A5B093DDF4A767C5863F6DE0DF78ED2099426FB69C8
C12B5802AAE2C0AFBAB5B77E75504CDD3041665DA950D8A9F22B9F56D76CA5E2
185562741CBB5851DBABCF75BC714F2674CA3E77F6D29A348BD97D57AD16CCAB
7D7F223B861C50F00055856C79C5CF74403C5DCEFB7A6F2938889B7448EF76C0
A4598EAE51C82488AEBF4CC53A2314F41543EA6B9165B5C4E856B81774CA1D75
70216AD5F8C7C9A78FB227658039FD8EAC28E032A55E43C54D1EA5C7F570F064
7A3C41FD38E7B89219FBF4AF358357851E54DB1D1543FA95EC9602867727E8AC
100B5EF88CAD7C88144854D5503188915B38716A9EA6D1968CFB5EFD2CB3AFF5
A5CF19043C69D88160C418534DC3D868BDE53935D717EBCD44405C3F675BDFB2
4C5830E7293505B04F5FDA21D1E2BC9C0EF7E514CFB6922C2D5D6FECBDD3AC61
3B14FDD4977CCD8C45FEFEBB1E5752F9A5C90863C06AF35066E1C35CF9E82203
8086DEFE5936CE43FE1F62F320A5AD8CD57D768391594ACDC5883A9EA157E658
1DB6C98B91E194DBB881FC7174823D830A3F1A7F6310447319F2134FD1A34CB1
71BD224EA8B3CA63E584670C65547D3E9770733345E7DDDDD57D37998BDC7206
999DA0422B3C323AFD2186EE32E8CE08EFAB7E1F822FACE8E263EE470FA64C94
528036B0BBF32C79B3E9EAAA49F4A22F5D9792CFDE3F860F5BBCC19A1ED5D9C7
9A232E1494ACDED6E0C41D40D27BF362BA853EB17A65A167A3A57A424DF5108C
C51CA723B9D875FE6A5563CFE51F1A1610F246C1AADC8F2278C29266193AD7A9
51CCFBC16BC2E035F44E727341CB43730DB05E11FA3F4C5013815F4CBCE24D31
C89CE1843A5FD14BED3EEE6F9117339B1435E29AC919EC6350F479CF2091862B
2DFB76BF88E031A46A830700F3453F91819066BE3A01F991D3467235D82635DC
923B167678D73FE339875D96FAE2969F3FC7BFEDA3E8221C03F946784F4CCDE4
53B029D9FA918E22787B2B7A5E80708B62A06012B241EBCC5740C355A0907787
BDF1B75EFD9C437B56526B060F44BD5F2C8B69D84C9E572E9A13FE8C031797BC
CC7441E461947496929C34F63BB0C543295D4872F6B02B8A8EB8389E6087982C
11731329047430F58E222C2E6822B51A16F316CAF9218FBA484AAE5F6AD0EDD3
4849D34031646A8B1342380104A49C289D045552F1BA134D604991AC8664CF23
116AE19F25B3EF9620C88CE528A59E78F80FB5A74F1E1E1F85FF09AF01F16F58
DCE3112AE7E3DF27BE32941BCB4EBBE21E1397F434916BAAED237068B50A3702
8A7DB257A718CAF53B2777EE70C93BB925D0C56D15A58B909FF8A9D3ED2103D8
A089E0C9A1C3FE5B9A4623DDE2F295A6ABE297A112A2CD9B90E07EC89466DEE8
87EBFCE73DDDDB9CFC98762439B24B812F0C159432E789279D67F41BAE286EC2
551BEE15F67567DAFA80CC7A5334995C16C39232F4E79BEC0CE82481CB09448C
4651CC89195824670D54EBACB326D820B397E3327A93B12DE606043FB0D17588
829C59D283BECFEFAADAD6B2A30093630529D66FE545671E70A9F986561B0039
11110EB25E1204E85EFFF36DE4BFE53223D096352FFE3558E431C4479B252F79
440EB30FDEE0F98153BD9DBD1AEB0497C689A3DB4551F5778B539014942319C6
3B885A9AB4A9E8E09AA083E4C94C1F65B5B8E1D223943881017174E65477B522
01AC3BC10FBD7F49A12B914A4A4796A7013ADA7A45A2FBE6134D9F04BDF0CE5F
7336180EEADDE033AF0E18F1BF844492118A70FC7C5E108F90B24E6FA9BC7203
8CDBD5145F0FA57ED72F0026FB34501EA44EBA451B2CDE1EA85205231B2F9C02
E8CB2F6AEDCDF5033805FED20C07398C140A9C1328C6C3253C24C65B5AA610C6
792459C0549B805152FD312C2339F566E12D0783A7BEF609DC61380632C3CCA4
AC8DC1EF163019E6363883EC4892F62D6EF9839FDDCF096F8D035234C4D210DE
7B57D143E794BEB24A8492B51AB884232E9D121ADB66C6A314FA6066D278A3E3
BE987F6C8EB5611F20F59478241B55A4C7A586252584D4D071C1465CA739E00B
1830FFB8A76038889833A9EAB291D61FF863D3C64E1B66C0F15FF35BD7E09A4B
253F197A5AF0F5627D43475625FF080683F6FB3AB23D85CC8B701E98BBA740CA
D475C44F9A6FA62BEEF516078C72A4B1677CD67C0896DEB68A17D2DDC7E9DBFD
B74A53A95C73992110DAC52428ABB293A350C319DCA7A804D65D09C6AE3E80A8
5C5013C2D98C4345A04D2DC9F3EB180AC11099E20006320F54BB206988A14CC9
0432386E51FB9A5ECCECE43FFAB9245FD87282642D30067D42FCE5085DA46C33
F4CB4404465AD111586EA16547F12369BE1FB27F064184FA7599AF4A8C97F121
DE22254F5D22642493AABA9732156D1883773E269AD58FA9D0287E9C2421C1B9
67398C83E1DE18E8B15DC7EAE62416D0D3A21CF48B3FE66962F72287722307DD
8BE87D46DA13AADA0A39D21213A38953CC58D737F7D239D925B0DD448092EE15
7BA9B4053DD52456D8D43114DE5C92F38C0A336F16ED2460A6B15FC7C2415439
EA33999BA08C604EAD5F8085A0FBAC57012E53E34F953D2121E1DEDF815895A6
5989D80CC18CB75637513A95A5AAFB7FB94D22A77901A431A731087184E41CE5
A2261DD2E5776F06B147323A7715AB969055859EDC8A940AECB01AD6071323F1
D52116B1697DCE7759EF0C24CE0D3D63D6A748F703109E6FBA852F889293D928
9C2B6471263141D2177CF58DD1B493838FE10BC502424F7EAB83B053AF950C85
07A8A5043226AACB841CA1E81B31447C8B7BFFA94B31AFA02DBD8119C5CF3938
8F0972D13AA69EC192E9067AF2F264CE7FEED858C464F3D84205597CC4ED61CA
4990539E12540F010F9F4070B73731FE278B33988478E25149AF4321F8BED277
B49B8B6276B5B1B46025FB43893291BDCEA2E921D80FAE2FEE1B2FDC1BCC641E
9CC8B89441B674DE079EE97EAD7B24EA36BA7A628735C8C3C0F03DD8D0E4008A
7DC06E0DCCDC13E284CD1C00075B1FED384FBA149FA00218500F458DCE7E8A42
EDF647251781DFF83E7AF220D79E9BC64AD1CA5C0B9469F723C845710FE2D708
B7243642365B425B02E9D82F4D14AF09719C82246C7F9AD3723596B11ADCF09B
CF30B0A1CBF3E4C8BBE2482C2E8DF6B256F64411DD39ACDF31FFBFA86407A133
C0500421D81061EAA6D1A85E6A26AF13C67FF81E7E675FE3A4C9165DE5895481
4A4A5691F38A04A745512CEA13ABB3BF00C2716F032F15A90D119C43CD7FE068
D35C37A1339AAD0B01DF02333DF9ACB79739227B0AF71E5706DDC1694CDEECAD
37C3E4F84562F77158BF8CA607EB12F341DDD600C91B202D30670DC48DEB4363
551A6EB2B7D1DD5757A5FBD67C615B72C93110F501DBE7C66ADCEEFA8FFC4DD9
9D2C1467A712075A71B4576EC29AC37A6F331E34F660DCFA9F6008F3676863B6
863792480E596302CE6563AD64E3CA7464C3E04E4B15C8E476DA4B7C3E2AC6B8
69C2814CAF26BD3389F8ACFFF8C7D91BE31ED3E6C46A908A3A13BF6188DC1833
305147EA040B7BC39352E1B52E0D7920BEE4A0333AE20C8CB226F1BF9EB9222A
660A9A0C3F1F5ED107AD93A096258B2278EC4A564A052EDA61C77D4130BE3FE2
BC9CD49F90192DD3D6EAC776A5D930033C7C2AC69E20DC470F09401D2EDBF716
07293065923D7A645733C4064D8B66422CECCACE16C4320FB0174DCAF682081C
4C2E462E081B6FBD373362EF77BDB2B8D701696AA117FBEC8A5E7A4C63CE8B83
D4AD3A540AC00C809463C27326AC79D7C3AE68949C199926DB8079F7CCEEC78F
2EB8D614713593E16EA88BAD50732A73133F50C9AEEB43F8072A1913C9B54A61
0583604E5FCD80DFF912A00650BFBF48E193B58E38DED6A5D94668AC792C2E45
0B9BF523CAE5DD8B8FB3E0BFDE518C3F7988D35B006CE68894B0407E9CE35213
484D6EE3FC5594B360B664440B6B69F8AF8C85A768E411E47A248FCF7ABF96D6
709B3BA5094FB5A2A6041D629DB8446F37289C1AFE7781D7F2D613E6488BF74D
EAF14979CAABB224C1843394EA0DAA3854562E8B620439F55FCA41FBC3D285A4
9FE08E192A2694C151D5C428C76259A8909845C2A0B9930B900AE29C73730B33
CB7C3EA09CDE93BCDA2437504AD748E76949F5848DBB629734973DFF998629C4
F7D41C4A95ACFC86BD9CC130D94B8F34141B4B1E2B39BC4A9046DC77570CE4AB
E7C8A1B7C85B6AED675BC9585589B27668EE934563FF9416CF4F561C0F16F1BB
EC9A49ACD64B60FF48673C8AF8DEE9B0A86139AC17EF59C661C386AA8E76475F
7F5E28675511A2F2E201FF9681F31A70A9CD70475B33AE87892ED473527B2947
E7D3929F100D3158A253F224547E764D44F5A47515D1F43E80635853AA7B9B87
A3659FCB8CD67A6849068E3A8D13C5DE51DAEA400AAFBB29589AF81DF9908719
F95A2DC80C0F5C7D6336E0D3887330D1BBD7E0FD6046851808B6EC51C08D9B4F
66AC56FE1616899A681D827E4292F7A0B944955947222199B8D101CD4D4A85A0
225AF1CF1C0C94CA8B0608E7A0EF4C4E7DDC4F32250C68A8AB44141EAE0E1729
6476FC098BE6A9B67F4EF4B993863C95186206F777B710E508ABD34A8F3C4FCA
044B736FF8632822619AECBBD05FB82601DD08103EE32C195ECDA1822202AA04
5CE90BA96A3E2A2E0788313E46C18AF378060BB39E499346B2E37427A5E40551
B37BC85A1F6D3F7CE856BB55FB81B0975DFD287BC2FC539D3C5601350E23DC7F
4F675EE4C1422856E528EF1E9F46002EE1FFF6D54DC3528437993BDCB6B39A00
DE952F20E91B9F2DF32707FA6CDA25A61F6E08C20D209C546D920126284B37BC
6D86BED1BB9110842EB18B8C456B760EC8B1AE7A7C37172F453970FED1D35D6F
A97A05A937A39DE4178D1BFA4BC7A56E2E35A3FEA7C2B91B672FA20FBD9BFDD0
C9408EB60587AE12FC1B863696FEEF72D174122FBE17C3B34ABBB4CC233DCEC9
8C42B1081E7EE99C741A3E0ABA769FF7E74D9E833F73F042DD5D6BDF7BF71424
AC14BD16890478691ABC869432C6AE0A488FA258BA92C82BB547BE5849C61431
0AFB51160C473D6FAEBE719B80F77651B6B1FA8B4FFCBCD6D247848CEE1E2837
2637E0898927F2AAC0C03C3F55165D0508583D0BD78EA8DF6D98421E4EEEB0AB
0FBF2EE89E1490EC01CD9BCB09DC6BDDF9F6674B508B50A18AC8C48F72381478
BAEF236017DF01BDF2C611D54DA901FD21BEA837C1BD89CF6B66763ED753D496
7EB674B8684AA0C7CDDA058371D5C89AE015FB9A9070A58074E87BB7E48FFAB2
C31E48D2B0FF627653220F147E8E2AE9A38C54DBBDE58FB5D156DDB355D66FC9
A93F4527426997D570625A039ED6349CC062DE4926661171D369639D199FF885
9EAAA54CFBC801C11E798CDD131FA793AE311C879D8D904515C85A50080668D9
C4CC8AAC6E4AEBF53382FE98C1933B7D906D3BFFE7B605CD2D29851F5067A056
1E1C27ACE8384F4B60390E7462FE75BF2271411625258C323E44E9021F596347
220BAA4D3C336745BB03148722C32B4C686CF8751A5F32B6E6F0DB14F5613DDA
0C417731B77CAA4A79CEC1A2D93BAB7E55F1E3824CB32F17643A3C4A17931A3E
E11347BF1E47E1C844D8C40D24DFE54B251A66754766D76BF70C8E6F06DEB131
617CDB1783E2CC95C962740E00BE3A234A8F1D6928EDE38F420ED0AA6B05A74F
E04F5D563B95D4D710B097FE18C11CE123035B009CD90EA317F17E55EE1D2BBD
6AB2F1549680180FF4EDE6D79F990C849E58BE3E5376F2CA3EBAC0F572B565AE
C4050E35894DBA1FBECBFD8C57E661B6F8AC23CE589192462230CEDB5B6CA0D9
B4B719D6626F6CD8BD72A2DAA0D901E7DA06903970684B17A6837F22918B1382
77A36450886CA446343DBE18CFBC83E39DE7F2EED269F8F236B4B1CF7041F44F
C33CEDB329EAC163090F318FBF6FB9FEE66D917C5C925458C05172054A305592
2B17CB0D6BCF9EBFB596D08C040C49D1DF66CDC5D4751903E10DE42E349947DF
6DE46071B57F38202AAC92ACD0397089388502DBD9914B34B989B6A64020C3CD
1A5ABB61C65BB9D2F77F783A6BFD7B871D8E92B0FF9925D13990FFCDB4B1F2BD
14804FCD812DFA307C4DCF8223D06F6E6075701EB85CB48D38D995525B4D2EBB
22EE09C275F0803DBCB039270FD66C5349C261F501AE1E2A6B0A654DB3F9DB9E
DA17D5C10BC684A68F00AEBBB07EE330E9BC555650372A4072B5950E97E14CEB
0F7659894E5EAD172C3E68D4847543948C36DAFE4D44285DD6866CA2F20FF4B8
680B20DDCB7B1E6ED63B45048ED4D6928021794369D01330A31D17F7D1B01230
38B2CC569AC49EA3CF0A8999FEE224139642848EE7EA133D8A5D9A0B7AB28C44
305FFA226E65DBF2575E15D9A9DA5AD0D471FE753F4191C4383CEA32D9FF169F
9742D55AB7728F10BDA7E7D2A303456E6DF291781C25F53B41C013C0203BE99D
E24AB5A491729057FB18A5191033AFFECCA3399C2832F197F035DEB406386786
3344EC5C76CF05131B16FBB3532B35600F338DB57321A391CDAFC20C8BE69A4C
23BD0DE3323098B7460EF69F3ECDDB41677289A59BFF4CAE26AAC25D9B9F7907
EAF80C0AA397395B46C494BC3D29D021A5E90CFF38798770259E0D5D46F43FBD
588ACDA125975271A48DE9BB6FE3F9CA701DD941ABA6B1636C6699314BE3B46B
8DF2D8CAE82840815A040DD73274710E5A305CDBF5C3A42B12AADADF127A5897
2A7270C4C7537705F53DF0DD0CFECBA1C6DAAAEC3D9A511B21CCB8F5018FB397
BA61727AA8556C09CB74B3ECFC932E34CC153336D544B915BAB1506FB3E10C96
F85FC7C0684EA0C757DF4FB0A9DF27BD6706DDEA29D17A8110C4E53B11DF7E5F
7B8FBF219E8E889066A511ACB6CB95E8D87F36E776FD2EE0D3A69A21ABCB6364
E90F8AF679A81ACFC5CF5B045E923878E5C1111BB98B0A313AE367E8BABD3CF5
F4984320AFE6E05A944FE692A262B8E066BF4BA88A45E30F2B0256D04F6F75D6
FFC70887D9B7310834A0C6D1D1B4258D00026754FDC4368E53628B4705E9B590
F66208C3752B2FE07DDCDA7DF609DFA4176D7A4AFEF043DCB5E98EE43F280DFA
28809FC12E479E44EED6B2C3F7FC9CE70E23A2FB01726E512BB102DC77280F78
CE304C9A1BD4B85421054A5029B9BAD745AA38A0703A058F21FA92A79BCBAB17
5859798EA12AEEBB22D4A285E22284958B85D6995D6806D22816784752ABC7B0
00E081B30D22090864A65B595D7BF36D2C3DD000966EB167B01FB957C7D09E1D
0D4D02C50583BA107A8E385037850124F185E025AD88D2852D3779DC1E973CF9
5074FF4E418EEFA6A8EE8DA3F43B9DF12D14B18997CC665A2AB057B035CAB622
443A1BE41C0162474A815407BB27CAFD10211D09160C6B9D336568C3485FF69F
A514F0CF7DDF193C320F676EACC3059E66ACDCDDEB3E5C3456A6390A3D403B3E
C3157374B94C5AEAED3CD2FB319AECB1B2326E800C5581D1A4D95A98D7CF803C
CFC1C9FFBDC5480F24B9D28142BF6BFEFB068120D24C10E82A5A02CE954FAB39
3FF78F9939E6322EF78B8038F602208661926D5D5641D9FA6E15B019D5F83853
F50CD574310B685964AE1729233D6FC6D4C00C89D451146706A84305F2AB62D9
D9F9AD99CBAFE5D7E243FFB9CD2C26C3A3D7B644A2B629E9DC141B9F1A9DD784
6F51418A8ED6857D7C042F5C2148CB8BCDCBD824AFE10B362F8442C718CD3936
E8B58F06B270C5D10F90752B5FE224A5A2E87E747934BF9FC282629FC4BC69A7
6BBBFDE5EB377A93CAF39ECDF7CAE75F6FDB6A1005F7DE853E8552A23D33CF6B
816A45E5E77AB50894CAE346162B5861E2A64CDA6E40EA28594A4AE731BDA734
094149626C96FC9A03B929C92DBBB7D960C0132A9F64CB510B56835897FD9B00
EBC3BE5AB9BECE12518105D6A84DE220B737A7F82B8B17590D62EF2B52DBECD2
CD64D21A2820594E4339937E452EEC4BE893D23575226B1B0CECEFC6C5473B38
FBE2DC383F3F8607F736730310308C22902D9C5258DAEEB7485A3794C1F37152
4FEE2210A8CAF245E9115B44F39E1E8A5DB3DE459916EE870857073E06B76B9C
BEE2031C63FFE7F9ED5A61AEFC823E6451B1D419292BD386F8490D834DA175A4
F49C85C1BABC140FB86D03C28664B9DE8BEA1505C9DE5734DE581EE2E117C4B4
C8CE5753D3D4D3A68B7BB7E79315FCB599AE122A3004B41BFB2C146D133AB21C
3FFEF37694766B00A80FD576708CF33100B66864514057E210657C6F7FC2889B
249B077747839BC4D6C9DBA89EB8D38653AB49198542CFAB9D7E997D0D0045E0
9059F1AFF60BBDCB52AA32FA748B0C2FCD9B93EF5B1BB46C33A707AD0B17E89E
2C44B903223896F7983F5BB67254B450318CFD076AF3EEF62A4229E8D2693588
C79FC5A0DDDA7D5B5CF4B01B717091F51609454A8D6CC4964F065B58AF99DF6C
F3677D76CD892A7E81AA5F1D41FA62395FD1F81BECD4BE9C7F777342E80DCA6C
6957C879318EA43B7CC317D83EDD6BD8D1641EF2CD7122B801E83E0DD96556B6
9C5E210D63F4C3AE877798807D383BA95CB9AC7525714A6C3F5A21D3EFAF54AF
9B16CC630EDBAC427D234D9BD24E31E519CDDAADC161AB89234FEDD55E675C2F
197B84DD29BC363639778B3B4879D1096790EB7DBB19297616419FE0267E774C
12798F14A11ADBF6337165498506261A9473DD74EE8C893D45EBCEF01D15D2EA
3CA039C509CA7F7082172513B6F93B12ED1EF88D54943765E6E2AAD10DAF9B01
A46971369695CADEFA394863533CC40218EFAB2EB93AFFFB6256C6A71BD1DDF0
F7255FC2C74D21C744897063DC90998921D45961B560D84414B7DBA351D62B21
CD66C54A0D6D1BC51ED44EC5FADFC1A6EC03D5DC0615F84EB2BF8178BFB8E2B7
09C51842B9C469917AD14294373E995D893DCEC3B01594A9641875F9F9083E2B
5BC5B0B0599D9177F5CC97A434B28DE8CBED2FB8719076FA1F1B9709BDE5D9BE
ABA4C6E7E807F4F8A095043CD7A203D903D20D5AB5D07682CCF7DA8040E39361
B923F8D146EC4A1765703C6F88C134D9DB2BBB111298715A9D64341046477939
2C081EC0210A1F84DB228057C5C9EB0A13DCB4B9267588A673F84DB78BEB15AC
93680584C4DB9AEED50FB34B2ACBB0FE76BC68DE5C7E2D00C9F6A8837A4209D5
13D9E1E2D65920BBAFFF7CBB52293F49E5F6E07AA35AC713435A80029BDC3580
D5F60DBD363387588BEDF95D03D2A8669EB4254BEE228000275E18E6CEA3849F
FD625D686E4A665D3E2C275AED6327F5CC4AFACB4A15B2FFF0422F2DCA50BE1A
E4819EA3CB61D69DB088CEC21CC81278B1E9D199622C0F4DF9BC99C219C4653D
4EECF3BFBBA10363FD574DEC79A4327E1DC9A6018143C4E92C2D932E74CC1500
7ED2B9A544576A46DE450E51709E8D139FD43786A19CD8EFD6021E95D9B766F6
BD0A2870A6187EBBC8FCF27801A33E04C8764699C3F1DE84BA1E17E41D264922
9523FDCB2A7193382AA12A2AAC572D7D4C5EACA7DCB8D83A4BFDD5B3BA693091
AA642877B203BEBD856CEB10A9340FC89A7899D37A6918FF5F856AD72A3520F9
3BA686CF408BD7D5C48B2144172B830FA23E06DDE61494CC80FBD6308635E3BC
AEF76770EA8D1EC19C2794CB618204EFF29FAFCC7BF32CDB1B3A12F999854146
6DE1DD0FACB53C18F5228D98FF8491E0EE389EAA858A62BA34016CC28AACA1C4
6D23A6F17A374567EF7BBE90E9F0710DF284AFD587212B53AFEA5B8E81F75D29
536CF825DCF0C0F418731677EFAD3F9B425167E01784AB35C02E9E275A9BF666
37DEEE1BE4D1CCD481B85E75EE0F42077589D8C35F0A75D97D54562EDA7D4E72
CA67750FECEE8E9A01615173A1DA6EA38FD26EE2B0149EB0E8C85ED8752A9532
D3898F5ED36E933E21F0F1AEDBC37F358D1BC3640E49DBA07F1B20261CAB35E6
402C55C42CB58BC77432EE201F41FAB734278171EC93FD390773E2A19D0D5FB2
D1F108542D0CEAAE54294BC8C67503E86A960B617151C7EE98FC5B8E92D28F3E
F14C28A10803FF9F11D482DF403E07E9920CF718A649C442A05AB00867FBA0C2
58305BFB1B83CFCE04E06DCB2A66C9F1C9ED1E812B006A116C82E131A8779D8B
B07977C68ECAA3048E05E75726823FCE87D370DD6069227CDAC09BDC3605F115
4346E6F12957CA2D1335B2BC15FA4C96FA4955A5ECA3F815638BE49F613C85DA
ED8AC7DF3E7562979DFE862B2AD1A0CB459583EE663D1751ACBDC18112011F5C
DE11C9CC71A274E3E61C7C65FA99AC139A5BB8741B68891CBF5AAA2937E82518
CF33BBF61F0164529FBA57A390B661E317C735011F3F36A8AA00F37131B2BBDF
65C7CF4185D90125E07D9729CA797ADD61676394B7058FF3616F857403B1E817
DE930DAB0CBC1070A024D69A4D8C56D90BEF5E8FDF5AB0BBB0D4BBFF8C194008
BE3659A38E4C52E9325C828022B5260DE89DCFB69527C48A6AB6ECBDAD3753FC
BB08057CE8B370887948FF0FAC092033C7B24A6AAEA00F7D18765E754602EDEF
6492A899ECF7DB3731D4D705B154AC639E100D409C810A246B2E9E938DC254F2
3C330BEC4B9782494D322DE3779E3E74A080B1BD4042090E34996855118773D1
003F3124E11B9F0DDCB92F3B1E63D2ACEEFC66250DE6B814AE17E8D907CAA163
FF2A5AD34DD644F69B8887166A46429994074BF65575EAECAE276B63BA63F5D7
A52173D6DC70965D0185F5D3D0DC696282162E063C94BC7DDEE988AF2A55F51E
B2B729AF0F773FAB9D8090CEC7B0B61DADB95FBD3B2F73F7F3BC5A136B80EF85
FFC11A75B21A2D70F40580FFC7D49BE9BDE0EE274CF00B91750EF1FF08002C94
2FF99BA968282073162A94E1E5F139C5C00992AD4C529CF52CC62E8FAABF3070
E881763CA84CC4FAC5C0D6C88FECF01D3F9522793ED0F581050CD1EBD7C726FE
275241C84569F2A13CE289B41F640CD3A21878AF0758470A3B7EAD188847E02A
86E606BA56A72088ED9E4315321D0A9067C4D7164FBDF0259D7E11B99F7A3DFB
45BC112C777254E94B44BD58CDF97A533EC486A9482AC063F61C9FD18199CE68
CB9A56CED23B27D2EAF4118C387907BD5A55FF0A0D2387FB89EFC6E5F571A546
9B163A23E4E5ACA7C37C249392D77CA5BE520F74692E5295F207726535042004
2BC804EE8EC4F287448532DC131833D3C5B6663653439CC169C93663CE05DA56
D71DF8DB38CD8F2BBDB5908BF8D8A0D849645FC561F61D009032F836ADAC6ADA
3FCFFEDC2357FD86BB0C02A8A1555B79949214EB5C3C58A8907ED43A9996546F
DB9FD0770391BA92819399361F75FB1AB623958AE99BEF2F8F6B29C7E0C637A9
03C9113D41777A63A1536A7A573E46FA18DFFFFD0A06E09BC8D2E423D8D4D0C9
9F825E853113DDA7BD2117A94A65D60F82C35D82EB937CA5667B7AD33755A78C
8367ECA28628F43D76FA38F1ED82BF46CAA6DB5005AFA7DBEDA40839D5FDE771
1B59D6FBC18512613DBAA904267AA236B8639BFB33BCEFE3018978E2CA2D1A75
155855BCDDB67F35386BC666DD2307639D2E12CC59C1E26725668D5E10B5ACD3
A3544E96A8F46425303554BA06AE21DCC84EB946AB45170E0A5D3982E92399A9
4E17266C01E5B23388C088D21CC0305DC7E075B31C4309EC18725C6F9A241100
F3F708F0CE57377BC5B6E2FE5B331A8395D70336166E81BA94BE3E3A8C7E961D
67BF901A4606B75E6D7DD652BEF58CDE11FD66422063373404C169C994C4D1BB
D27B060EDA6E7815A4459491C3D3449197A1CFE8B28CE280968F377D8594121E
C2C5D4A711B02A7429E5C1E5620675752B396820E1F4DA34EA4CD9E81D205333
4288F26272576C6C5AB6CD689B6D8A9E41120A0183897A12AC3FEB21FA5B912D
968755F86E5D8D32883D924A5F84149C85FDA1FC2B749BBF6077BA6EE3FE80FF
36BEB5C46DF19DAD88E54025A65B2A1AB34E5A34434D867DA1824BC885C10B5A
BEA980440F0AE401CBEB5E5B85DB642F76F629CAE9562D4521BCB2533C4974AA
B49081BF8353B0A18DBD03EDFD86EE3ABE6817910506365C320AFF61338CD420
BE1B687462E9B3F2794BEFDC96EA878113F8EA94F4893F75F279D14D6BA6D533
F2358B16EC62A21838B9A60ACF9023E2C046AEA111F2A94D2B78BC5D65295709
58A7F88B48A0E2D9152F4CFED01DAFA82B1B24F6E45D61635E0DE5A5623B0797
380F5D9397D0526C1984B98D3CBDE7F979854CD11DE3DB174ABDF4136154C6D6
39CEB6F892AD5EC136764864A9C940D3924CBB7925D7A94101795D57E4FB4CEE
87F7EFE9CF6524CA3120B3B878B549D3B9C8C2E0755929D306960B8449AFE241
1A64D045AA579E6E278FC5D98D5461F4EF51DEACD1EE1AB160F1FD3D13CCB7DD
3366ABC83370154C15F9B7CAB4354E80D1F3EEE58C25FFB876B9B45B8C02157C
8F9A1BF73E924B79412CF259543F48823065A16BDCF7F55ADE78AF879D60E593
DC8887466226FA0FA399B62F4D6E1D466FA1708CF933CCD2C49B0B2FD1219593
82B852782BDE11359986D1F5FF4BEF9105A1A016A3347CA0C9CDAA5D2348522C
FF545B455B5C7609411913BD1786AE1AF13B492D00A0BCC25931B45AB43DEB17
5286A312C4A7D289DBB7EA48F8EA96BB82026DC6A0B631FBD0D21C5F67E6F01C
4C5248F4A59B2E4A7C4B4F8BA0BA8FB96D002A90FA8DE506F212525E5435E5A6
F107A552F897E3037AE59C665CD642C73D588F93D210435CF236735D2A680E71
55F6CD43A8491373352251F4AB70CC96721E97CEF1AA10CAAFBC0535A8CFF78B
FE5613759D301431E6D67C78D336D90A1A0932ECB02C53A05C4752D265A34D2D
5B4858BBE8F26F2D624A056DEEBD0BFED3B50D024A8719B8C5AEDEBE29F49B11
1694728D25A657E625AB95503EA7C6115030B9FD25B7828AB89594B26DC2DCCD
75E400AFEA1464D80451E300987E27CD21EF56D9C17C030425C744CB20D88DFB
BFBE751D82B528DA1913209E01385A9A0EEC0FB9D2AB26174565F105BB8DD64C
7B2133F73D13E5E1697079E372D04654D3A46CEB6B9A27E8E04DDE855B0F97AE
283CE31F8920359C2EA090F70D9AE34246DAA3D4606070F51AB333523D39140C
4014E88E29D13839D4BB882A041343EDF1D2A0BB1D9709C315A0AB55C2AFE1D8
5892410B4557386F9920AFE6B44B1E1B1CF6EBB997E80A43BA32FB0E441FDEA1
5173AEE0BEC68B90200876C40C434387BA9863369AE1DF1AEF0F86659A1FA777
95F74F6EB43A4B6561795547613B189DFA54B542C99301D7355439B8A66870E7
38B59A8F292BE1BDB951B472373731405B8CC04B282911DA2526D69737E53273
B7CBA171F62C7CE9E55AD3A5A7DD9CA6C62E3C2B09F4E2E92B66015C88D4F3CE
79B47E1D1C678717E41C4C455362932077A60E37BDB715CEEB8953D11D10A2D1
203AB9D5A8EC03D0E8020C9A9B704548056BCA524F15C95FD9A2C941EF4CB16A
61EE3DFDDDA5DAB4204F1750FCE4D7361E9B6EF5FD97BAABCF4EBC835C13CB08
FCE74AB8B8CA10515A0B6A02E1D6766DF76E2D584B53970FB59CFFE784C8D588
DBD6F6F085FFC6D8CBD27D65D28619407826B976B369B3743EC052C6A87F6C1B
23B7CD964AE9C1BF80045B091C511F0D727D431E21BB9B3FF9B589106EF5736D
517270A28963972DC6AB989D83685941A6ED47D6CEDF3C4886EA974279EE82DB
08325C083418E1EDD194785993D22D3D6DB181D4E782EBF0876EE07CA656CC6B
AF2A66523272BD23A95F1D7F8F2D4111C945EDFDBA626C58BBCFB57B130D04DA
C91951EEA83393727CF7568B78ECBDE72A3AF67A03E164E7546E945833BF863D
4FCA6E6B263B57E6AB6624CA6D81496F997E07DEBBAE4313ACCAA9A25DFB4C5C
14746E84F5997139E5904E2B004FD188C37B54A1C88E4B7227CB5C188B82E1D5
B946A11D8D5574BD58EF481C0F33700998EC68D6C9353D698A564065B2287986
88766FA6419B8807B3BE93FC7D1C6AF5CDF33ED763017F42FAAEA0D9595925FD
2E0A6C36DDD0178092CBFF9860FD3A5E69685F532CB846022EA4FAF32C358D35
7B313F341DBF3464691B9E41E27865A04BBB0EA3B9E6760CD2C00F10DBF28E15
DE27876D9F664A210AD3369A1F0F9A629FCCDB3DBD6E29C165614CED908B9409
04190758C0CBB8C1964FF4F1744C345B62BCC76F84729028DD21AB0204FDA2F8
79A61287B8494EAE784FB6F5B748C2B00AFAC85301D0D3F2904CF0A60E1DFCF4
BEC37ADD51CF5493485FEB4885EB2F71789CF1AA7D0BBF2C988BF3FE42903868
43756D83797C26F0C05169ACD30AC13905209B9B46B8CFD302FDE57F3B4DFFEE
2D9222C46DDE2E453F64B32611DF4D91F3AA8619BEF55162901002D74321FC30
4F408D4E49C0B993486B8587EDC80880C197A4AD3F0C70FC7DD421DACF240FF8
D356DB090F8E6E6E608994AF43FF9631C419BDE34B6D4629AD9888B524141B3A
390003C637B22593A0FA0931D491E7E86BBE9104D13158D39B8CF51B30D5D807
A6648EDD4AA24DC05BC1B1CA560637285F5A7C5F891F957F3987262C6A0255A8
B0F53CD7D3F5E12E3565E72C5F043F2AF92D60393FA57112016916868495A799
C7C0B1819705BD1ABA1C963796DD5DDFA3EEEEAF43E3F1E357B44305C5A7C586
8248CA2885346FB419EB1295C8AADF8329EA46BB6C69B652294A12208E838A10
D80860E264CE4FC07069E9A169136F50E171DCD1C5ECFBAC1231AEFA736F5A3E
977CACBEF04FD5DB3DB82C49A42B3A943E5802B58CD91BF3EC0712E5DA4E97EE
AD0FE881AA10FCA53B6CCDA8FEC819BD1B60F6DA08F5F63143592B70F4B40508
7D760331326404F6245645F0371763EF4F56B961F808BA7A19ED863ABE455BAD
764776CCEAD7E18628F7BECA325E1666B4A308447EA15D6465E53D677DE77C29
5EA89CE26B22E916426CDFC66E1E624037B2221EB6C4D846ADFE7E2620AC8042
B31A376F161ECC38ADAB925FC3BA479C744FE2ABBA86EED599046F7DF55DBADB
01F1D8DEAD036208104F9D85BF0F598DCB52151B347977BEFB628B86506DA3D9
4D4B152F940A9EC892074A95102A8FB275FD32A926970C7A0E5E45376F996740
3BAE5A62A288F969B5FBF4291A456EAAFC33691D7CB7B06205FC3BD42C4F0B1E
B402DA754920C845831609C895A81E5B74994421BB302D337646B0F640B49BEA
08761CBF19393F1120E319E3199FE3FFC39A718613E9349BC02116F463EDA099
F60B6E32038400B6B53CCCFADC51ACDE78407F64712841CD14A759EA604333B6
48F372EBD2CB3AEE5B1F5223645B55B74589D887D180249373406F815F320C01
E0AAC1745BF741437C8322FCF8DD61AD61205ECFF8D66E05EAE35C4F593B55FE
F9A4718EAB617594E3F65451A6396E3F776D651DE309005EC19E9DA271EED4D4
96938935D4060B6899D8F5B51F403AC7EDA7172128BC4721976320B01EC04E91
317A9E7FBCF32D453B5CF58242776939AB0210B033F887C6D7F334874D8C87F8
06011CBAA8427D1DB3C8271A7987679A657576352091C1CDF5ED49BD321BA5D3
2AC0F85CA8901FBC0FC1D27455BDE1FCBE461E953544456B6B5E0877CAC8A96A
9366DBC85E57274438D5020B3055B5F85B90371FE5E7A63EC2364C9D4FAF61FE
17EA23D5B4F9CA92EBD61BB0132505B10BBFA56F66B4ED040B1463A0E8078C7F
5EB81DFEEDA2305A710350B97F6C4825494B85C4F085F87E3F134E8A36C93B3B
D67AC41F1762CCBB378867A50A759BCD62BB9133C4E80DC0D1722D3E86283FA0
8F44E0607AE1B90ED1B2F126EADC0A9E632F95778DE6BBE6B9E89FE564D02B4E
F2DADF7A20E9D75B3FE02114EC387631C8AE560F3593D5886AA028FBD6F34EFC
0A8C49D37E94C43F8BE28B93DEA3E0CFBF9F1D64B423135C683588DDF2416793
4FEB5FA6B4B37585EDD9DB77AD3CA93784471D4AB9B52FB24E931A114F70983B
43290BBA94A6F1B802ABA838B2CAC1C2F35F8E0F2B0C51FD932FDE2DAB0A7C6C
E1346653098238F5B2EE610FD7745EBD3E6A2DFAF85FF72A63B5010B804A4EB8
50E010BAA1C241BE2B15C00D214E8DBCE36AFA7F42D18429DD3E82B3169FC3F3
FE6FD3E7751BF8BDF23AB68B1F30A36BB2B28BC61204E2CBC2B55C7FE80F02BF
7F488F6FA3C4B1AE31FDB3F8AEF0D4F035C96E7776576D8FE00757D04E950ED1
8195AA4795D438A25BCB5749F2CF35DD1DC00618E956067991AA920C4B86938A
839973EDCE2DBC88FA9AB8670223BAE7BC42C5FCBA4ECCBC647A5ECDD7ED30D7
10B74E8A3EA33BFD1E448EA10F6A5CB8E9D3055DF9B0B37FEE364E1ADD5833B8
9E9FA45CFDF293FC880C74FD07F394CE2094EDE9EF1B9048D4A9C9B9D13BC5FD
126106F7A22A30BE86B5D4D989348CFB84D4C4C473369C340C4C484A87B8E519
70F556F4A8EF43E7F99C388D27C62446E9AE88760733D17B1B12E2C06599B92D
54E683BD676A6ED057CFDDE416D6D27C406E4697E90B26E739FF3B71A2094CB8
59F518EC208F11EEF954E614F4015DD41BC1DB369D52367BAD0CBFC2826286A1
CA0F850218772004FC1A72BE809EC4DE2AE71F931AFAB4E939BDB8A26ED4C9C2
AE53B9F5DC597DE5AE6EE164A4F6A4BFA5802203F21E9A8C3ABF7FE65BB3E83C
3F48936C94AC1E5105F9F0B3E45EF849FEAA5A36022B167FC1ACC654DE1164E5
D38A283D3992E65D0BC30213E47AEE747DE5CDECA3DE77606420F17C6FD66860
1E6139FEC467DE272D5B2ADA97AD185ABD63D4A0514B4D06F480F6C525CCB574
96BE635D53DCB80572A003F833B5213D80ADC922BFB473DDB8C194E5687B83CF
C7265BCCE5782776ABD8EE2043D1921D82BA3E8DABADF2C519F938114E53A752
321C64FA7D23B7E8D30D9F8FD94464212E191A2C5CD429D8FD13433172AFC36F
6610378E20512A2B3BA0149A037CFD550C4B415251765BDC7BBEAAFE07D616F4
319F403056467B88BE93956DABBD5B8A9917D399DA6C36AA152F6C171877F4DC
EF4A86B46B4763F62A08183BC0C89BDAEA2F0D3A659D91ABDA027140324D4567
15798E035F2DBD8A082CB617AD9FBF0C7B4996B0C0D474CFB0D2CBE0BCAD4E30
ECC208FDAC360CE17C960187A60A450A88BC663C83FBF296D9E256EDFF5B8A37
115F0CCD4D94469AC52293A07B3CC459B654F5DDC51DF716D16F7C8A68189662
FDA241FEE0224EDD907D784C9E821B2E8064F9AF648BE526CED8610C484F8B87
EE0A499E170CA0E06F6BE7C26806EAA084517366F576D92AC6D4D60E2C6B753E
2D8C10A69CE139C5C972B985F6E19B9BC9D9806917BBBCBB2231BE676E9E6D9B
D14FA048CD897ACD3D2773AE4D3BF6CF5F1D810157476128EA8EFF5DD137A2F3
813DF833ECF29DC95D4834DA8C5DB7BA688F93BA30F2D0FAE58BDD983A95829F
BC3F2314BDCBB3BCC40BE4B3EDE48DF86A947620533E5AB518B62A6EF9CD140E
7768D78C863B4A7453BCAFEE5B03FF30BA288CE3AF49AC04497F013423557DA7
3A6058627CDCAD2E2E6399842A92EE4B39833D5A1C4E3F2C3A9316836FFE093D
938D2676B52EAE90F834A8E6921282CD2ED5CF85F0AFC3728CEA9F60DB50EAF9
75A67E70370FB2A3CD4434BD9630B8C02369053E31F2DAE30CC53CCBED2614D9
942AAF99F581B5898E580E1326BDB796791A1C7D33F3B54E3AB542DF74AF75CF
7AFFD9E4899F59EFDDF4D1BB38CEFF52197FE8A854D05E8C12755BBE29548092
5128DAD7F9A2A37774A763E9DFA8114D3B24B601254BBA027EF2ECA3A1C4DFFE
60E5B7A76D20132D5982941F43696B0D72DB688A68447BD420EE77C45ADA3833
385679415CECE7FD583372D0C2F0FD12CBD080F99C018C06B208976BB8FCC1A1
0CDBF484AD8F08EA1388C9A30643D09154D80D1825776EAF7AE4B7ABC3247C70
0CCF4F619E79DEB1D0856386660248CDF15F68B9FECEF2762AA4EBD0370A562B
9B86A3BEA13C502DA43A65548A7B1F566109EFC522677960C1AF4B143A066786
0E3D577C9280A11897BC73684186468AA6B4A7A625F4463D9DE35B62143F433B
D79CC89459E8C05C2EAE5D2DCCB69CAA67C53DE18EA6A293B130763EF6AE5913
7360A4F4FE485CAEA1C260DFA2A7CF450F9759990DC62901113FF98182904CDA
5E042D1276ABAAC8562FDC9A4CCBB3A4F2A18FFA5B3FEC2049CD20879F9A9323
2881B83DB72E4C95460308698CB12775E0B255D9BEA9DD9E26508125706830AE
464999A215ACFE6FB7C46EB387C451314A40F18F973D7797ED225EA974799A67
7EE8D045C88BAF258D616AB3420E4EA73612908E97697174805DACDF0C168F28
00C1BF03C8D258A869D7BCEF970537A568CFA721DD0E7BB475515B40D891C3C2
17295CFF82E2209B1C24F13EF3AF91DA59CD234F0F82A29384EBB8F70FD97516
59498C8682027BC97A779A85D18224BB03441074CD21FA85351DC5FE41B83C2E
94E4D6AD85B937BA400CE149F3E78FD755E8DDEFC00439A736350CEE91DAB444
3AB4241D1D2641645DA874C97EE0475DEA232660F06B82DB1BE380E35D6BFC1D
685CDF57E9073490811DF4C8C3A39D12114CB6A4D823052A4EEA24F1016B17DE
8688080A0AE333EC20A8D0ED479BC8F5A74A85B2B5F5E46EA8876B4D9F69DD35
72AC205FBBF01CDD88EEE006742316D374A7203AC798B690FBDEEB4FA0642373
228EA709CDB7E894E24E3538DA725004B16D43272582901692CFF2171F6BB78F
33B387F88315CCD0FB50312F86364558B972EF73FCCFC2B09D501513E8E5C927
F8CDD136A924DDEF3E20B4AFE8C04199748EB1CC5D5DFD0AA5AD7BBFD7929F76
62924F9084459BD382CCFF10EB8FD3AF133B4BD62BC09A36553D04D0BC99FEA7
DD600043CAF0DAD5DE710E7AE12A871C14B33D6027A6DF84C73889951C9CB51D
BCA5F1FC0B379F295E3175BAC2E996F91BA0B9981302D1D426D2726BCA0845FB
A879CB0E9CC58803C7A76B099449D26C720886EE15A0F659F772B0B78836AC08
522F36951199E0B1547680421ABD74108FEB2CE1C695F00B16D1C3E99C21F9EF
7933F5370E8E597B9796B8DD33D9BB5E6C55D05E3664756E6E4A6A6A5A33BCA6
7AF60098E5027816D658A98225A2C2307ED79A9AC904DE10F19B6AD7AF493FB5
7457B3F1D06B3283C07A977F8198B13F6588D60B8606C97DEC9601BC0A57DAC1
7F3210E0D7C2ED711523C84A4068504AB43174B57B4E86B3B53BBF3F3CA27955
E957A970569FCDD1F614094C2150D3C9FCCE9D5C534840EA11B401204A239689
2C6E3E5872961C5DCEBC446BC86005E733C22BA2C6D75A0632794F558E496C00
209D2C2C94915B3409A033D9481A6151A818E189436289B0A72A23AE0171CBB7
7EADDE2C92B37564B96654BFDD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: MathDesign-UT-Regular-T1-10
%!PS-AdobeFont-1.0: MathDesign-UT-Regular-T1-10 1.51
%%CreationDate: Sat, 28 Jan 2006 18:51:11
9 dict begin
/FontInfo 10 dict dup begin
/Version (1.51) readonly def
/Notice ((c) 2004 Paul Pichaureau, under the gpl licence.) readonly def
/FullName (MathDesign UT Regular T1 10) readonly def
/FamilyName (MathDesign-UT) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/IsFixedPitch false def
/UnderlinePosition -98 def
/UnderlineThickness 54 def
end readonly def
/FontName /MathDesign-UT-Regular-T1-10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 47 /slash put
readonly def
/PaintType 0 def
/StrokeWidth 1 def
/FontType 1 def
/FontMatrix [0.001000 0.000000 0.000000 0.001000 0.000000 0.000000] readonly def
/FontBBox {-18 -491 940 750} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC4458BF85598BFFB688F90ED6A048EF34
1E514EB44F263B92302DA62E5D3E0E80DAA99252B0357D057396EB1F16BC20C2
D373CE5AD9C56779F676BE22DD8B5E288823824D460C36D4675A1E5FDDA0BFCA
B18C8EF171F0C7D70A7CE68FE415C852A99C172F20DF292CC04BE996D4D7E022
85BEA198A6A52B56E0D4A7AA76546CAE6E95496F58EF2373667756E9DB93E0C6
5F643442DC11AFFCFED478779F29D2E33FCFFB4AF8BBD57E02657B9481BFFB76
419D6BDEA07299407C5A881A239D065155AAD93DD443A2F5A63DA4B93CF868CC
4092E4018E1381462D1ACAE0FF3C0692AEA4B8DFBBC61B2519EF67131E60BCBD
D4197F3167E18F8337DF38FB55AD92A0732902C03D0477E855CE2D203EB62C5C
308E2D3989D7F942511B655539B135ACDCB76F20282F4EBB3ADE84A391D18AB8
629ABF5C341D148F9BEFB6DDA4128F9A27596E424D25A1A40E70E9A649A5EB75
1ACD3769AD2863E96862BF27530FDCFB9EADD44A87245F13E3B5CE357DD45528
CC07DD34B805C7C5DB3988BE96F467767F57010FAC8F11C8DFF34B5BB2F5DA19
82ABA1F350962917CCCE3754B2B66B0F747BE1288E39D6DF4087336D241E859B
BFE1A7F5121334AEFFDFE19282A2D901819A69CD0FBBA5114E8D5DAE15635651
F2024BF153159D4814E01DB13BBE5B30F1432EE9FB90C38D56AD2A908FDEC9FA
2F535FCDB34CB18D629DC7765B3981D35F35F8B343A677B7BAA0718BC6A6C861
D4264A15F31CD5D3A1712D61DEC88A462362736726309D3C7CA0F91342A1B59A
1B4A0FD09BA84709B66027DED3255F1428C66A14CD6A17F06CC216B2212EFF48
EB9FD25265774FF0C4EDDF26F4E4808CE7FFF5E06886827C5AA50D10E0CFC750
EFD13C10CE309022DC25A63294CC15808974C2D25CDD52A76A5608D21737C613
F1D92DFA645BB095635A2FEC39E0DFE17F5EA33F99D95CAE36CE9E768DDC07EE
5912DE11D07676C5C574B36F319243D6F681AA7E43B89729C75DBCE74179F941
07F9951E478E3ACD7CC3DCDD1E246800D22477A94A889128B5009CC964B16EF5
DE1EF8E472157FD8BDAFAA3F14C53FD878F80BC0A79D576941DC1780BB7EE442
4E17A533EF44942CEA21C149DC01B9D816CCC79B09A04CE6D8751F8CFDE8B0E3
833551E78EAE380960D098510F46B4CD276B00CF0D56E70618DFC4D3EBE88134
5C6B7AE262304E8385ECB2B1E2965118C057515B1EE31660B762196BDACA7A1D
187FA44AEF847F0C2F956BA1A8B0EDDE916E77D53634C137AEEA38805C9475D2
A5F9EE021B2226011209AB94F1A922492234F2AB6E03A62FC3E0C50F55A84F73
AE82AA9B11484D9D6F8B66D150593476FD86671DFF6EA0954CD06EE2B49D86DE
98F2C960EDAC5058C9D407E7CFDFB2332F6230340080AFC08FDF0C33DC9A2A3D
C6CC7EF5541D208242414ED394EEF612814EAD971948A764B3BD8871FF00CE48
5FAC863E0DD1BC6F026952A3A6B8C8A4A0DA2736D6CC78FA7B8CC2C5091DDE81
BC0CC4D130E8524C7D3B23C05026873301EA4BD5A9667FE783C0DDC07E06D549
BD35D8192C3480418A667245C67EA5E61C1A6BA1BF3C00F27ECB88A52983D68C
A4255EB35B3D5F3D3281FC264D195CCE81F6FABF20093EDD019CC81C0E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39200231 55436929 1000 600 600 (DS_3.dvi)
@start /Fb 255[40{}1 53.4661 /MathDesign-UT-Regular-Symbol-10
rf /Fd 255[57{}1 76.3801 /MathDesign-UT-Regular-Symbol-10
rf /Fe 205[28 50[{TeXnANSIEncoding ReEncodeFont}1 53.4661
/Utopia-Regular rf /Ff 143[32 12[24 99[{TeXnANSIEncoding ReEncodeFont}2
53.4661 /Utopia-Italic rf /Fh 194[36 61[{}1 76.3801
/MathDesign-UT-Regular-Italic-MathItalic-10 rf
%DVIPSBitmapFont: Fi ecsx1200 12.1681 18
/Fi 18 233 df<3FFFFFFFFE000000007FFFFFFFFFF0000000FFFFFFFFFFFE000000FFFF
FFFFFFFFC00000FFFFFFFFFFFFE00000FFFFFFFFFFFFF80000FFFFFFFFFFFFFE0000FFFF
FFFFFFFFFF0000FFF800001FFFFF8000FFF8000001FFFFC000FFF80000003FFFE000FFF8
0000000FFFE000FFF800000007FFF000FFF800000003FFF800FFF800000001FFF800FFF8
00000000FFFC00FFF8000000007FFC00FFF8000000003FFE00FFF8000000003FFE00FFF8
000000001FFF00FFF8000000001FFF00FFF8000000001FFF00FFF8000000000FFF80FFF8
000000000FFF80FFF8000000000FFF80FFF8000000000FFF80FFF80000000007FF80FFF8
0000000007FF80FFF80000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF8
0000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF8
0000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF8
0000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF80000000007FFC0FFF8
0000000007FF80FFF80000000007FF80FFF8000000000FFF80FFF8000000000FFF80FFF8
000000000FFF80FFF8000000000FFF00FFF8000000001FFF00FFF8000000001FFF00FFF8
000000003FFF00FFF8000000003FFE00FFF8000000007FFE00FFF8000000007FFC00FFF8
00000000FFFC00FFF800000001FFF800FFF800000007FFF000FFF80000000FFFF000FFF8
0000003FFFE000FFF8000000FFFFC000FFF800001FFFFF8000FFFFFFFFFFFFFF0000FFFF
FFFFFFFFFE0000FFFFFFFFFFFFF80000FFFFFFFFFFFFF00000FFFFFFFFFFFFC00000FFFF
FFFFFFFE0000007FFFFFFFFFF00000003FFFFFFFFE00000000424677C552>68
D<00007FF800000007FFFF8000003FFFFFE00000FFFFFFF80003FFFFFFFC000FFFFFFFFE
000FFFFFFFFF000FFF801FFF800FFC000FFF800FF00007FFC007C00003FFC007800003FF
C007000003FFE006000001FFE000000001FFE000000001FFE000000001FFE000000001FF
E000000001FFE000000001FFE000000001FFE000000001FFE0000003FFFFE00001FFFFFF
E0001FFFFFFFE000FFFFFFFFE003FFFFFFFFE00FFFFFFFFFE01FFFFC01FFE03FFFC001FF
E07FFE0001FFE07FFC0001FFE0FFF80001FFE0FFF80001FFE0FFF00001FFE0FFF00001FF
E0FFF00003FFE0FFF80003FFE0FFF80007FFE07FFC000FFFE07FFE001FFFE07FFF80FFFF
E03FFFFFFFFFE01FFFFFFFFFE01FFFFFFDFFE007FFFFF9FFE003FFFFC1FFE000FFFF00FF
C0003FF00000002B317DAF36>97 D<00003FFC00000003FFFFC000001FFFFFF000007FFF
FFFC0000FFFFFFFE0001FFFFFFFF8003FFFFFFFF8007FFF007FF800FFF8000FF801FFF00
003F001FFE00001F003FFE00000F003FFC000007003FFC000000007FF8000000007FF800
0000007FF8000000007FF000000000FFF000000000FFF000000000FFF000000000FFF000
000000FFF000000000FFF000000000FFF000000000FFF000000000FFF000000000FFF000
000000FFF000000000FFF000000000FFF000000000FFF0000000007FF8000000007FF800
0000007FF8000000007FFC000000003FFC000001803FFE000003801FFE00000F801FFF00
001F800FFF8000FFC007FFF007FFC007FFFFFFFFC003FFFFFFFFC000FFFFFFFFC0007FFF
FFFF00001FFFFFFC000003FFFFE00000007FFC00002A317CAF32>99
D<000000001FF8000000003FFC000000003FFC000000003FFC000000003FFC000000003F
FC000000003FFC000000003FFC000000003FFC000000003FFC000000003FFC000000003F
FC000000003FFC000000003FFC000000003FFC000000003FFC000000003FFC000000003F
FC000000003FFC000000003FFC000000003FFC000000003FFC000000003FFC000000003F
FC000000003FFC000000003FFC000000003FFC0001FF803FFC000FFFF03FFC003FFFFC3F
FC00FFFFFF3FFC01FFFFFFFFFC03FFFFFFFFFC07FFFFFFFFFC0FFFF00FFFFC1FFFC003FF
FC1FFF0000FFFC3FFE00007FFC3FFC00003FFC7FFC00003FFC7FF800003FFC7FF800003F
FC7FF800003FFC7FF800003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003F
FCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003F
FCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFC7FF800003F
FC7FF800003FFC7FF800003FFC7FFC00007FFC3FFC00007FFC3FFE0000FFFC1FFF0001FF
FC1FFF8007FFFC0FFFE01FFFFC07FFFFFFFFFC07FFFFFFFFFC03FFFFFFBFFC00FFFFFE3F
FC003FFFF83FFC000FFFE01FF80001FF0000002E4B7CC93A>I<00003FFC00000003FFFF
8000000FFFFFE000003FFFFFF80000FFFFFFFC0001FFFFFFFE0003FFFFFFFF0007FFF01F
FF800FFF8003FF800FFF0001FFC01FFE0000FFC01FFC00007FE03FFC00007FE03FF80000
3FF07FF800003FF07FF000003FF07FF000003FF07FF000001FF0FFF000001FF8FFF00000
1FF8FFE000001FF8FFE000001FF8FFE000001FF8FFFFFFFFFFF8FFFFFFFFFFF8FFFFFFFF
FFF8FFFFFFFFFFF8FFFFFFFFFFF8FFFFFFFFFFF0FFF000000000FFF0000000007FF00000
00007FF0000000007FF0000000007FF8000000003FF8000000003FFC000000001FFC0000
00601FFE000001E00FFF000007E007FFC0001FE003FFF801FFF001FFFFFFFFF000FFFFFF
FFF0007FFFFFFFF0003FFFFFFFC0000FFFFFFE000001FFFFF00000001FFF00002D317DAF
34>I<000007FF8000007FFFF80001FFFFF80007FFFFF8000FFFFFF8001FFFFFF8003FFF
FFF8003FFE01F8007FF80078007FF0001800FFF0000000FFE0000000FFE0000001FFE000
0001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE00000
01FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001
FFE000003FFFFFF8007FFFFFFC00FFFFFFFC00FFFFFFFC00FFFFFFFC00FFFFFFFC007FFF
FFF80001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0
000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE000
0001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE00000
01FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001
FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FF
E0000001FFE0000000FFE00000007FC00000254B7ECA23>I<0001FFF0001FC0000FFFFE
03FFC0003FFFFF9FFFC000FFFFFFFFFFE003FFFFFFFFFFE007FFFFFFFFFFE007FFC07FFF
FFE00FFF001FFE00000FFE000FFE00001FFC0007FF00001FFC0007FF00003FF80003FF80
003FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF8000
3FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF80003FF80001F
FC0007FF00001FFC0007FF00000FFE000FFE00000FFF001FFE000007FFC07FFC000007FF
FFFFFC000007FFFFFFF8000007FFFFFFE000000FFFFFFF8000000FCFFFFE0000001F81FF
F00000001F8000000000001F8000000000001FC000000000001FC000000000001FE00000
0000001FF000000000001FFFFFFFE000001FFFFFFFFF00000FFFFFFFFFC0000FFFFFFFFF
F00007FFFFFFFFFC0007FFFFFFFFFE000FFFFFFFFFFF001FFFFFFFFFFF003FFFFFFFFFFF
807FFFFFFFFFFF807FF000003FFF807FE0000007FFC0FFE0000003FFC0FFC0000001FFC0
FFC0000000FFC0FFC0000000FFC0FFC0000000FFC0FFC0000000FFC0FFE0000001FFC0FF
E0000001FFC07FF0000003FF807FF8000007FF803FFE00001FFF001FFFC000FFFE000FFF
FFFFFFFC0007FFFFFFFFF80003FFFFFFFFF000007FFFFFFF8000001FFFFFFE00000000FF
FFC0000033457DAE39>I<3FF07FF8FFF8FFF8FFF8FFF8FFF8FFF8FFF8FFF8FFF8FFF87F
F0000000000000000000000000000000000000000000000000000000001FF03FF87FF87F
F87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87F
F87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87FF87F
F87FF87FF87FF87FF83FF81FF00D497AC81B>105 D<000000FFC00000FFC0003FE007FF
F80007FFF8007FF03FFFFE003FFFFE00FFF07FFFFF007FFFFF00FFF1FFFFFF81FFFFFF80
FFF3FFFFFFC3FFFFFFC0FFF7FFFFFFC7FFFFFFC0FFFFF80FFFEFF80FFFE0FFFFE003FFFF
E003FFE0FFFF8003FFFF8003FFE0FFFF0001FFFF0001FFF0FFFE0001FFFE0001FFF0FFFE
0000FFFE0000FFF0FFFC0000FFFC0000FFF0FFFC0000FFFC0000FFF0FFF80000FFF80000
FFF0FFF80000FFF80000FFF0FFF80000FFF80000FFF0FFF00000FFF00000FFF0FFF00000
FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0
FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF0
0000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF0
0000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000
FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000
FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0
FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF00000FFF0FFF00000FFF0
0000FFF07FF000007FF000007FF03FE000003FE000003FE04C2F79AE5B>109
D<000001FF80003FE00FFFF0007FF03FFFFC00FFF0FFFFFE00FFF1FFFFFF00FFF3FFFFFF
80FFF7FFFFFF80FFFFF01FFFC0FFFFC007FFC0FFFF8003FFC0FFFF0003FFE0FFFE0003FF
E0FFFE0001FFE0FFFC0001FFE0FFFC0001FFE0FFF80001FFE0FFF80001FFE0FFF80001FF
E0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FF
E0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FF
E0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FF
E0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FF
E0FFF00001FFE0FFF00001FFE0FFF00001FFE07FF00001FFE03FE00000FFC02B2F79AE3A
>I<00001FFE0000000003FFFFF00000000FFFFFFC0000003FFFFFFF000000FFFFFFFFC0
0001FFFFFFFFE00003FFFFFFFFF00007FFF003FFF8000FFFC000FFFC000FFF00003FFC00
1FFE00001FFE001FFC00000FFE003FFC00000FFF003FF8000007FF007FF8000007FF807F
F8000007FF807FF0000003FF807FF0000003FF807FF0000003FF80FFF0000003FFC0FFF0
000003FFC0FFF0000003FFC0FFF0000003FFC0FFF0000003FFC0FFF0000003FFC0FFF000
0003FFC0FFF0000003FFC0FFF0000003FFC0FFF0000003FFC0FFF0000003FFC0FFF00000
03FFC0FFF0000003FFC07FF8000007FF807FF8000007FF807FF8000007FF807FF8000007
FF803FFC00000FFF003FFE00001FFF001FFE00001FFE001FFF00003FFE000FFFC000FFFC
0007FFF807FFF80003FFFFFFFFF00001FFFFFFFFE00000FFFFFFFFC000007FFFFFFF8000
001FFFFFFE00000003FFFFF0000000003FFF00000032317DAF39>I<000003FF00003FE0
1FFFE0007FF0FFFFF800FFF3FFFFFE00FFF7FFFFFF00FFFFFFFFFF80FFFFFFFFFFC0FFFF
E03FFFC0FFFF000FFFE0FFFE0003FFF0FFFC0003FFF0FFF80001FFF0FFF00000FFF8FFF0
0000FFF8FFF000007FF8FFF000007FF8FFF000007FFCFFF000007FFCFFF000003FFCFFF0
00003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF0
00003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000003FFCFFF000007FFCFFF0
00007FF8FFF000007FF8FFF000007FF8FFF00000FFF8FFF00000FFF0FFF80001FFF0FFFC
0003FFF0FFFE0007FFE0FFFF000FFFE0FFFFC07FFFC0FFFFFFFFFF80FFFFFFFFFF00FFF7
FFFFFE00FFF3FFFFFC00FFF0FFFFF000FFF03FFFC000FFF00FFC0000FFF000000000FFF0
00000000FFF000000000FFF000000000FFF000000000FFF000000000FFF000000000FFF0
00000000FFF000000000FFF000000000FFF000000000FFF000000000FFF000000000FFF0
00000000FFF000000000FFF000000000FFF0000000007FF0000000003FE0000000002E43
79AE3A>I<000000F83FC007F87FE01FF8FFE07FF8FFE0FFF8FFE1FFF8FFE3FFF8FFE7FF
F8FFEFFFF8FFFFFF00FFFFF800FFFFF000FFFFC000FFFF8000FFFF0000FFFE0000FFFE00
00FFFC0000FFFC0000FFF80000FFF80000FFF80000FFF00000FFF00000FFF00000FFF000
00FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF000
00FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF00000FFF000
00FFF000007FF000003FE000001D2F79AE27>114 D<000FFF8000007FFFF80001FFFFFE
0007FFFFFF800FFFFFFFE01FFFFFFFE01FFFFFFFE03FFFFFFFE03FF800FFC03FE0001FC0
7FE00007C07FC00003C07FC00000C07FC00000007FC00000007FE00000007FF00000007F
FC0000003FFFC000003FFFFF00003FFFFFE0001FFFFFF8000FFFFFFE0007FFFFFF0003FF
FFFF8001FFFFFFC0007FFFFFE0001FFFFFE00001FFFFF000000FFFF0000000FFF8000000
3FF80000001FF80000001FF82000000FF87000000FF87C00000FF87E00001FF87F80001F
F87FE0003FF0FFFC00FFF0FFFFFFFFF0FFFFFFFFE0FFFFFFFFC03FFFFFFFC00FFFFFFF00
03FFFFFE00007FFFF8000007FF800025317DAF2C>I<007FC0000000FFE0000001FFE000
0001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE00000
01FFE0000001FFE0000001FFE000003FFFFFFF007FFFFFFF80FFFFFFFF80FFFFFFFF80FF
FFFFFF80FFFFFFFF807FFFFFFF0001FFE0000001FFE0000001FFE0000001FFE0000001FF
E0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0
000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE000
0001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE0000001FFE00000
01FFE0000001FFE0000001FFE0000001FFF0000001FFF000C001FFF003C000FFF81FC000
FFFFFFE000FFFFFFE0007FFFFFE0007FFFFFE0003FFFFF00000FFFF8000003FF0000233C
7EBA29>I<3FE00000FFC07FF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FF
F00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FF
F00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FF
F00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FF
F00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FF
F00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00001FFE0FFF00003FFE0FF
F00003FFE0FFF00007FFE0FFF0000FFFE0FFF0001FFFE0FFF8003FFFE07FFC00FFFFE07F
FFFFFFFFE03FFFFFFDFFE01FFFFFF1FFE00FFFFFE1FFE003FFFF00FFC0007FF80000002B
2F79AD3A>I<FF8000000FF8FFE000001FF8FFF000003FF8FFF000003FF87FF000003FF8
7FF800007FF03FF800007FF03FFC00007FF03FFC0000FFE01FFE0000FFE01FFE0000FFE0
0FFF0001FFC00FFF0001FFC007FF8003FF8007FF8003FF8003FF8003FF8003FFC007FF00
01FFC007FF0001FFE007FF0000FFE00FFE0000FFF00FFE0000FFF00FFE00007FF01FFC00
007FF81FFC00003FF81FF800003FFC1FF800001FFC3FF800001FFC3FF000000FFE3FF000
000FFE7FF0000007FE7FE0000007FE7FE0000003FF7FC0000003FF7FC0000003FFFFC000
0001FFFF80000001FFFF80000000FFFF80000000FFFF000000007FFF000000007FFF0000
00003FFE000000003FFE000000001FFC000000001FFC000000000FFC000000000FF80000
00001FF8000000001FF8000000003FF0000000003FF0000000003FE0000000007FE00000
00007FE000000000FFC000000000FFC000000001FF8000006003FF8000007C07FF000000
7FFFFE0000007FFFFE0000007FFFFC0000007FFFF80000007FFFF00000003FFFC0000000
3FFF8000000007FC000000002D437DAD34>121 D<0001FFE000000001FFF000000000FF
F8000000003FFC000000001FFE000000000FFE0000000007FF0000000001FF8000000000
FFC0000000007FE0000000003FF0000000000FF80000000007FC0000000003FE00000000
01FE0000000000000000000000000000000000000000000000000000000000000000003F
FC00000003FFFF8000000FFFFFE000003FFFFFF80000FFFFFFFC0001FFFFFFFE0003FFFF
FFFF0007FFF01FFF800FFF8003FF800FFF0001FFC01FFE0000FFC01FFC00007FE03FFC00
007FE03FF800003FF07FF800003FF07FF000003FF07FF000003FF07FF000001FF0FFF000
001FF8FFF000001FF8FFE000001FF8FFE000001FF8FFE000001FF8FFFFFFFFFFF8FFFFFF
FFFFF8FFFFFFFFFFF8FFFFFFFFFFF8FFFFFFFFFFF8FFFFFFFFFFF0FFF000000000FFF000
0000007FF0000000007FF0000000007FF0000000007FF8000000003FF8000000003FFC00
0000001FFC000000601FFE000001E00FFF000007E007FFC0001FE003FFF801FFF001FFFF
FFFFF000FFFFFFFFF0007FFFFFFFF0003FFFFFFFC0000FFFFFFE000001FFFFF00000001F
FF00002D457DC334>232 D E
%EndDVIPSBitmapFont
%DVIPSBitmapFont: Fj ecsx1440 14.6017 16
/Fj 16 234 df<0000003F0000000000007F800000000000FF800000000001FF80000000
0007FF80000000001FFF8000000000FFFF800000000FFFFF8000003FFFFFFF8000007FFF
FFFF800000FFFFFFFF800000FFFFFFFF800000FFFFFFFF800000FFFFFFFF800000FFFFBF
FF8000007FF83FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF
80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80
000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF8000
0000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF800000
00003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000
003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF8000000000
3FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003F
FF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF
80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80
000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF8000
0000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF800000
00003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF80000000
003FFF8000001FFFFFFFFFFF003FFFFFFFFFFF803FFFFFFFFFFF803FFFFFFFFFFF803FFF
FFFFFFFF803FFFFFFFFFFF803FFFFFFFFFFF801FFFFFFFFFFF00315576D446>49
D<3FFFFFFFFFFC0000007FFFFFFFFFFFE00000FFFFFFFFFFFFFC0000FFFFFFFFFFFFFF00
00FFFFFFFFFFFFFFC000FFFFFFFFFFFFFFF000FFFFFFFFFFFFFFF800FFFFFFFFFFFFFFFC
00FFFFFFFFFFFFFFFE00FFFF0000007FFFFF00FFFF00000007FFFF80FFFF00000001FFFF
C0FFFF000000007FFFC0FFFF000000003FFFE0FFFF000000001FFFE0FFFF000000000FFF
E0FFFF000000000FFFF0FFFF0000000007FFF0FFFF0000000007FFF0FFFF0000000007FF
F8FFFF0000000007FFF8FFFF0000000003FFF8FFFF0000000003FFF8FFFF0000000003FF
F8FFFF0000000003FFF8FFFF0000000003FFF8FFFF0000000003FFF8FFFF0000000003FF
F8FFFF0000000003FFF8FFFF0000000007FFF8FFFF0000000007FFF0FFFF0000000007FF
F0FFFF0000000007FFF0FFFF000000000FFFF0FFFF000000000FFFE0FFFF000000001FFF
E0FFFF000000003FFFE0FFFF000000007FFFC0FFFF00000001FFFF80FFFF00000007FFFF
80FFFF0000007FFFFF00FFFFFFFFFFFFFFFE00FFFFFFFFFFFFFFFC00FFFFFFFFFFFFFFF8
00FFFFFFFFFFFFFFE000FFFFFFFFFFFFFFC000FFFFFFFFFFFFFF0000FFFFFFFFFFFFF800
00FFFFFFFFFFFF800000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF00000000000000FFFF00000000000000FFFF00000000000000FFFF000000000000
00FFFF000000000000007FFF000000000000003FFE00000000000000455375D259>80
D<000007FFF000000000FFFFFF00000007FFFFFFE000003FFFFFFFF80000FFFFFFFFFC00
03FFFFFFFFFF0003FFFFFFFFFF8003FFFFFFFFFF8003FFF8007FFFC003FFC0001FFFE003
FF00001FFFE001FC00000FFFF001F0000007FFF001E0000007FFF001C0000007FFF80180
000003FFF80000000003FFF80000000003FFF80000000003FFF80000000003FFF8000000
0003FFF80000000003FFF80000000003FFF80000000003FFF8000000003FFFF8000001FF
FFFFF800003FFFFFFFF80003FFFFFFFFF8001FFFFFFFFFF8007FFFFFFFFFF801FFFFFFFF
FFF807FFFFFE03FFF80FFFFFC003FFF81FFFFC0003FFF83FFFF00003FFF83FFFC00003FF
F87FFF800003FFF87FFF000003FFF8FFFF000003FFF8FFFE000003FFF8FFFE000003FFF8
FFFE000003FFF8FFFE000003FFF8FFFE000007FFF8FFFF000007FFF8FFFF00000FFFF87F
FF80001FFFF87FFFC0003FFFF87FFFE0007FFFF83FFFF807FFFFF81FFFFFFFFFFFF81FFF
FFFFFFFFF80FFFFFFFFFFFF807FFFFFFF3FFF801FFFFFFC3FFF800FFFFFF03FFF8003FFF
F801FFF00007FF00000000353A7CB843>97 D<00000000001FFF0000000000003FFF8000
000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF800000000000
3FFF8000000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF8000
000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF800000000000
3FFF8000000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF8000
000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF800000000000
3FFF8000000000003FFF8000000000003FFF8000000000003FFF8000000000003FFF8000
000000003FFF8000001FFE003FFF800000FFFFE03FFF800007FFFFF83FFF80001FFFFFFE
3FFF80007FFFFFFFBFFF8000FFFFFFFFFFFF8001FFFFFFFFFFFF8003FFFFFFFFFFFF8007
FFFFC01FFFFF800FFFFE0003FFFF800FFFF80001FFFF801FFFF00000FFFF801FFFE00000
3FFF803FFFC000003FFF803FFF8000003FFF803FFF8000003FFF807FFF0000003FFF807F
FF0000003FFF807FFF0000003FFF807FFF0000003FFF807FFE0000003FFF80FFFE000000
3FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FF
FE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE000000
3FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FFFE0000003FFF80FF
FE0000003FFF80FFFE0000003FFF807FFF0000003FFF807FFF0000003FFF807FFF000000
3FFF807FFF0000003FFF803FFF8000003FFF803FFF8000003FFF803FFFC000007FFF801F
FFC00000FFFF801FFFE00001FFFF800FFFF00003FFFF800FFFFC000FFFFF8007FFFF803F
FFFF8003FFFFFFFFFFFF8001FFFFFFFFFFFF8000FFFFFFFFBFFF80007FFFFFFE3FFF8000
1FFFFFFC3FFF800007FFFFF03FFF800001FFFF801FFF0000001FFC0000000039577BD548
>100 D<000003FFE0000000007FFFFE00000001FFFFFF80000007FFFFFFE000001FFFFF
FFF800003FFFFFFFFC0000FFFFFFFFFE0001FFFFFFFFFF0003FFFF80FFFF8003FFFC001F
FFC007FFF0000FFFC00FFFE00007FFE00FFFC00003FFE01FFFC00001FFF01FFF800001FF
F03FFF000001FFF03FFF000000FFF87FFF000000FFF87FFE000000FFF87FFE000000FFF8
7FFE0000007FFC7FFE0000007FFCFFFE0000007FFCFFFE0000007FFCFFFC0000007FFCFF
FFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFF
FFFFFFFFFCFFFFFFFFFFFFF8FFFC0000000000FFFE0000000000FFFE0000000000FFFE00
000000007FFE00000000007FFE00000000007FFE00000000007FFF00000000003FFF0000
0000003FFF00000000003FFF80000000001FFF80000000301FFFC0000000700FFFE00000
01F007FFF0000007F007FFF800001FF003FFFE00007FF801FFFFC00FFFF800FFFFFFFFFF
F8007FFFFFFFFFF8003FFFFFFFFFF8000FFFFFFFFFE00003FFFFFFFF800000FFFFFFFC00
00003FFFFFE000000001FFFC0000363A7CB83F>I<3FFE7FFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFE00000000000000000000000000000000000000
000000000000000000000000001FFE3FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7F
FF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7F
FF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7F
FF7FFF7FFF7FFF7FFF7FFF3FFF1FFE105779D620>105 D<00000007FF8000001FFE0000
3FFC003FFFF00000FFFFC0007FFE01FFFFFC0007FFFFF000FFFE07FFFFFF001FFFFFFC00
FFFE0FFFFFFF803FFFFFFE00FFFE3FFFFFFFC0FFFFFFFF00FFFE7FFFFFFFE1FFFFFFFF80
FFFEFFFFFFFFE3FFFFFFFF80FFFFFF807FFFF7FE01FFFFC0FFFFFE001FFFFFF8007FFFC0
FFFFF8000FFFFFE0003FFFC0FFFFF00007FFFFC0001FFFE0FFFFE00007FFFF80001FFFE0
FFFFE00007FFFF80001FFFE0FFFFC00003FFFF00000FFFE0FFFF800003FFFE00000FFFE0
FFFF800003FFFE00000FFFE0FFFF000003FFFC00000FFFE0FFFF000003FFFC00000FFFE0
FFFF000003FFFC00000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE0
FFFE000003FFF800000FFFE0FFFE000003FFF800000FFFE07FFE000001FFF8000007FFE0
3FFC000000FFF0000003FFC05B3877B76E>109 D<00000007FF80003FFC003FFFF0007F
FE01FFFFFC00FFFE07FFFFFF00FFFE0FFFFFFF80FFFE3FFFFFFFC0FFFE7FFFFFFFE0FFFE
FFFFFFFFE0FFFFFF807FFFF0FFFFFE001FFFF0FFFFF8000FFFF0FFFFF00007FFF8FFFFE0
0007FFF8FFFFE00007FFF8FFFFC00003FFF8FFFF800003FFF8FFFF800003FFF8FFFF0000
03FFF8FFFF000003FFF8FFFF000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003
FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FF
F8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8
FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FF
FE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE
000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE00
0003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE0000
03FFF87FFE000003FFF83FFC000001FFF0353877B748>I<000001FFFC00000000003FFF
FFE000000001FFFFFFFC00000007FFFFFFFF0000001FFFFFFFFFC000003FFFFFFFFFE000
007FFFFFFFFFF00000FFFFFFFFFFF80001FFFFC01FFFFC0003FFFC0001FFFE0007FFF800
00FFFF000FFFE000003FFF800FFFC000001FFF801FFFC000001FFFC01FFF8000000FFFC0
3FFF8000000FFFE03FFF00000007FFE03FFF00000007FFE07FFF00000007FFF07FFF0000
0007FFF07FFE00000003FFF07FFE00000003FFF07FFE00000003FFF0FFFE00000003FFF8
FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF8FFFE0000
0003FFF8FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF8
FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF8FFFE00000003FFF87FFE0000
0003FFF07FFF00000007FFF07FFF00000007FFF07FFF00000007FFF03FFF00000007FFE0
3FFF8000000FFFE03FFF8000000FFFE01FFFC000001FFFC01FFFE000003FFFC00FFFF000
007FFF8007FFF80000FFFF0007FFFE0003FFFF0003FFFFC01FFFFE0001FFFFFFFFFFFC00
00FFFFFFFFFFF800007FFFFFFFFFF000001FFFFFFFFFC0000007FFFFFFFF00000001FFFF
FFFC000000003FFFFFE00000000001FFFC0000003D3A7CB846>I<00000003F03FF8001F
F07FFC007FF0FFFC01FFF0FFFC07FFF0FFFC0FFFF0FFFC3FFFF0FFFC7FFFF0FFFCFFFFF0
FFFCFFFFF0FFFDFFFFF0FFFFFFFC00FFFFFFE000FFFFFF8000FFFFFE0000FFFFFC0000FF
FFF80000FFFFF00000FFFFE00000FFFFC00000FFFF800000FFFF800000FFFF000000FFFF
000000FFFF000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE00
0000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE0000
00FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000
FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FFFE000000FF
FE000000FFFE0000007FFE0000003FFC000000243878B72F>114
D<0001FFFE0000000FFFFFE000007FFFFFFC0001FFFFFFFF8003FFFFFFFFE007FFFFFFFF
E00FFFFFFFFFE01FFFFFFFFFE01FFFFFFFFFC03FFF0007FFC03FFC00007FC03FF800001F
C07FF8000007C07FF0000001C07FF0000000807FF0000000007FF0000000007FF8000000
007FFC000000007FFE000000007FFF800000007FFFFE0000003FFFFFF000003FFFFFFF00
001FFFFFFFC0001FFFFFFFF0000FFFFFFFFC0007FFFFFFFE0003FFFFFFFF0001FFFFFFFF
80007FFFFFFFC0003FFFFFFFE0000FFFFFFFE00001FFFFFFF000001FFFFFF00000007FFF
F000000007FFF800000001FFF800000000FFF8000000007FF8200000003FF8380000003F
F87C0000003FF87E0000003FF87F0000003FF87FC000007FF07FF00000FFF07FFC0001FF
F0FFFFC007FFF0FFFFFFFFFFE0FFFFFFFFFFE0FFFFFFFFFFC03FFFFFFFFF800FFFFFFFFF
0003FFFFFFFC0000FFFFFFF800000FFFFFC0000000FFFC00002D3A7CB835>I<003FFC00
0000007FFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE0000003FFFFFFFFE007FFFFFFFFF00FFFFFFFFFF00FFFFFFFF
FF00FFFFFFFFFF00FFFFFFFFFF00FFFFFFFFFF007FFFFFFFFE0000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00000000FFFE00
000000FFFE00000000FFFE00000000FFFE00000000FFFF00000000FFFF00030000FFFF00
0700007FFF801F80007FFFC0FF80007FFFFFFF80007FFFFFFFC0003FFFFFFFC0003FFFFF
FFC0001FFFFFFE00000FFFFFF0000003FFFF80000000FFF000002A477DC532>I<3FFC00
0001FFF07FFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE0000
03FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003
FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FF
F8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8
FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FF
FE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE
000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000003FFF8FFFE00
0003FFF8FFFE000003FFF8FFFE000003FFF8FFFE000007FFF8FFFE000007FFF8FFFE0000
07FFF8FFFE00000FFFF8FFFE00001FFFF8FFFE00001FFFF8FFFE00003FFFF87FFF00007F
FFF87FFF0001FFFFF87FFFC00FFFFFF83FFFFFFFFFFFF83FFFFFFFFBFFF81FFFFFFFE3FF
F80FFFFFFF83FFF803FFFFFE03FFF800FFFFF801FFF0001FFF80000000353877B648>I<
7FF000000003FF00FFF80000000FFF80FFFC0000000FFF807FFE0000001FFF807FFE0000
001FFF003FFF0000001FFF003FFF0000003FFF003FFF8000003FFE001FFF8000007FFE00
1FFF8000007FFC000FFFC000007FFC000FFFC00000FFFC0007FFE00000FFF80007FFE000
00FFF80003FFF00001FFF00003FFF00001FFF00001FFF80003FFF00001FFF80003FFE000
00FFFC0003FFE00000FFFC0007FFE000007FFC0007FFC000007FFE0007FFC000007FFE00
0FFF8000003FFF000FFF8000003FFF000FFF8000001FFF801FFF0000001FFF801FFF0000
000FFF803FFE0000000FFFC03FFE00000007FFC03FFE00000007FFE07FFC00000003FFE0
7FFC00000003FFE07FF800000001FFF07FF800000001FFF0FFF800000000FFF0FFF00000
0000FFF8FFF0000000007FF9FFF0000000007FF9FFE0000000007FFDFFE0000000003FFD
FFC0000000003FFDFFC0000000001FFFFFC0000000001FFFFF80000000000FFFFF800000
00000FFFFF000000000007FFFF000000000007FFFF000000000003FFFE000000000003FF
FE000000000001FFFC000000000001FFFC000000000000FFFC000000000000FFF8000000
0000007FF80000000000007FF8000000000000FFF0000000000000FFF0000000000001FF
E0000000000001FFE0000000000001FFE0000000000003FFC0000000000003FFC0000000
000007FF80000000000007FF8000000000000FFF0000000000001FFF0000000030003FFE
000000003F00FFFE000000003FFFFFFC000000003FFFFFF8000000003FFFFFF000000000
3FFFFFF0000000003FFFFFC0000000001FFFFF80000000001FFFFF00000000001FFFFC00
000000001FFFF0000000000001FF800000000000394F7DB640>121
D<00007FFF00000000007FFF80000000003FFFC0000000000FFFE00000000007FFF00000
000003FFF00000000000FFF800000000007FFC00000000003FFE00000000001FFF000000
000007FF800000000003FFC00000000001FFE000000000007FE000000000003FF0000000
00001FF8000000000007FC000000000003FC000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000003FFE0000000007FFF
FE00000001FFFFFF80000007FFFFFFE000001FFFFFFFF800003FFFFFFFFC0000FFFFFFFF
FE0001FFFFFFFFFF0003FFFF80FFFF8003FFFC001FFFC007FFF0000FFFC00FFFE00007FF
E00FFFC00003FFE01FFFC00001FFF01FFF800001FFF03FFF000001FFF03FFF000000FFF8
7FFF000000FFF87FFE000000FFF87FFE000000FFF87FFE0000007FFC7FFE0000007FFCFF
FE0000007FFCFFFE0000007FFCFFFC0000007FFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFF
FFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFF8FFFC00
00000000FFFE0000000000FFFE0000000000FFFE00000000007FFE00000000007FFE0000
0000007FFE00000000007FFF00000000003FFF00000000003FFF00000000003FFF800000
00001FFF80000000301FFFC0000000700FFFE0000001F007FFF0000007F007FFF800001F
F003FFFE00007FF801FFFFC00FFFF800FFFFFFFFFFF8007FFFFFFFFFF8003FFFFFFFFFF8
000FFFFFFFFFE00003FFFFFFFF800000FFFFFFFC0000003FFFFFE000000001FFFC000036
527CD03F>232 D<0000003FFF80000000007FFF8000000000FFFF0000000001FFFC0000
000003FFF80000000003FFF00000000007FFC0000000000FFF80000000001FFF00000000
003FFE00000000007FF80000000000FFF00000000001FFE00000000001FF800000000003
FF000000000007FE00000000000FF800000000000FF00000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000003FF
E0000000007FFFFE00000001FFFFFF80000007FFFFFFE000001FFFFFFFF800003FFFFFFF
FC0000FFFFFFFFFE0001FFFFFFFFFF0003FFFF80FFFF8003FFFC001FFFC007FFF0000FFF
C00FFFE00007FFE00FFFC00003FFE01FFFC00001FFF01FFF800001FFF03FFF000001FFF0
3FFF000000FFF87FFF000000FFF87FFE000000FFF87FFE000000FFF87FFE0000007FFC7F
FE0000007FFCFFFE0000007FFCFFFE0000007FFCFFFC0000007FFCFFFFFFFFFFFFFCFFFF
FFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFFFFFFFFFCFFFFFF
FFFFFFF8FFFC0000000000FFFE0000000000FFFE0000000000FFFE00000000007FFE0000
0000007FFE00000000007FFE00000000007FFF00000000003FFF00000000003FFF000000
00003FFF80000000001FFF80000000301FFFC0000000700FFFE0000001F007FFF0000007
F007FFF800001FF003FFFE00007FF801FFFFC00FFFF800FFFFFFFFFFF8007FFFFFFFFFF8
003FFFFFFFFFF8000FFFFFFFFFE00003FFFFFFFF800000FFFFFFFC0000003FFFFFE00000
0001FFFC000036527CD03F>I E
%EndDVIPSBitmapFont
/Fk 172[74 17[85 8[74 4[74 1[74 9[33 39[{TeXnANSIEncoding ReEncodeFont}
6 131.985 /Utopia-Bold rf /Fl 55[61 110[60 3[77 61 55
67 3[72 90 57 2[38 1[71 58 61 76 1[67 63 65[{
TeXnANSIEncoding ReEncodeFont}16 97.6685 /Utopia-Bold
rf /Fm 54[36 115[44 35 32 39 1[37 43 42 52 33 2[22 46
2[36 44 39 39 36 65[{TeXnANSIEncoding ReEncodeFont}17
56.5212 /Utopia-Bold rf /Fn 22[35 35 110[36 2[39 47 26
30 31 43 45 41 47 70 23 1[24 24 46 38 1[35 45 34 43 43
37[20 12[20 1[20 4[16 26[46 12[{TeXnANSIEncoding ReEncodeFont}28
76.3801 /Utopia-Italic rf /Fo 22[40 40 7[42 22[48 79[40
40 1[40 48 28 34 34 46 47 45 49 72 24 1[24 24 48 41 26
40 46 38 46 42 12[48 3[50 2[70 45 2[29 4[59 53 8[21 6[43
43 43 2[21 1[21 4[19 39[{TeXnANSIEncoding ReEncodeFont}41
76.3801 /Utopia-Bold rf /Fp 105[46 63[58 12[32 5[63 8[24
5[49 1[49 49 49 48[{TeXnANSIEncoding ReEncodeFont}9 91.6561
/Utopia-Regular rf /Fq 169[43 54 1[37 44 2[52 53 64 3[24
54 2[41 53 1[44 66[{TeXnANSIEncoding ReEncodeFont}12
67.8254 /Utopia-Regular rf /Fr 172[86 14[123 17[84 50[{
TeXnANSIEncoding ReEncodeFont}3 158.412 /Utopia-Regular
rf /Fs 169[74 93 2[75 2[89 2[67 2[41 3[71 69[{
TeXnANSIEncoding ReEncodeFont}7 117.225 /Utopia-Regular
rf /Ft 208[36 47[{}1 76.3801 /MathDesign-UT-Regular-T1-10
rf /Fu 11[44 9[39 39 39 38 4[40 1[40 73[38 28[39 37 1[38
46 26 33 30 45 46 44 47 70 21 40 21 22 46 40 24 39 46
38 46 40 8[48 2[60 47 41 2[46 58 60 72 43 1[27 27 61
2[46 60 52 49 49 5[20 20 1[40 40 1[40 40 40 40 40 40
1[20 30 20 2[27 27 21 26[47 12[{TeXnANSIEncoding ReEncodeFont}66
76.3801 /Utopia-Regular rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop -600 -600 a
SDict begin [/Producer (dvips + Distiller)/Title (SLCI - DS2)/Subject
()/Creator (LaTeX with hyperref package)/Author (Xavier Pessoles)/Keywords
() /DOCINFO pdfmark end
 -600 -600 a -600 -600
a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 -600 -600 a 0 TeXcolorgray -854 -972 a
SDict begin H.S end
 -854 -972 a
0 TeXcolorgray 0 TeXcolorgray -854 -972 a
SDict begin H.R end
 -854 -972 a
-854 -972 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -854 -972 a Black 0 TeXcolorgray -246 -157
a Fu(PT)o(SI)18 b(\226)f(Sciences)i(I)o(ndustr)q(ielles)f(pour)g(l)o
('I)o(ng\351nieur)1718 b(L)l(yc\351e)17 b(J)m(ules)h(H)n(aag)f(\226)h
(Besan\347on)p -246 -126 4258 2 v Black 0 TeXcolorgray
-246 109 a
SDict begin [/Count -0/Dest (section.1) cvn/Title (Pr\351sentation du syst\350me)
/OUT pdfmark end
 -246 109 a -246 109 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 -246 109 a -246 109
a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 -246 109 a -246 109 a
SDict begin H.S end
 -246 109 a -246 109 a
SDict begin 14.39996 H.A end
 -246 109
a -246 109 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 -246 109 a 0 TeXcolorgray 0 TeXcolorgray
1197 220 a Fr(D)t Fs(E)7 b(V)g(O)h(I)g(R)41 b Fr(S)t
Fs(U)8 b(R)d(V)j(E)g(I)g(L)g(L)g(E)38 b Fr(2)1071 596
y Fp(V)r Fq(E)t(N)t(D)t(R)t(E)t(D)t(I)26 b Fp(12)c Fq(N)t(O)s(V)t(E)t
(M)t(B)t(R)t(E)27 b Fp(2010)19 b(\226)h(4)j Fq(H)t(E)t(U)t(R)t(E)t(S)p
-246 1035 4258 2 v 0 TeXcolorgray 0 TeXcolorgray 1803
1241 a Fp(CI)d(:)1803 1380 y(CI)g(:)1803 1520 y(CI)g(:)p
-246 1705 V -121 2503 a Fo(C)o(ontenu)15 b(du)h(sujet)g(:)p
0 TeXcolorgray -121 2622 a Fu(\226)p 0 TeXcolorgray 42
w Fo(P)m(ar)q(tie)e(1)i(:)h(Logique)d(combinatoir)n(e)p
0 TeXcolorgray -121 2742 a Fu(\226)p 0 TeXcolorgray 42
w Fo(P)m(ar)q(tie)g(2)i(:)h(P)o(roductique)p 0 TeXcolorgray
-121 2862 a Fu(\226)p 0 TeXcolorgray 42 w Fo(P)m(ar)q(tie)d(3)i(:)h
(\311)o(tude)f(des)g(syst\350mes)g(asser)r(vis)-121 3659
y(C)o(onsignes)e(et)i(r)n(ecommandations)f(:)p 0 TeXcolorgray
-121 3779 a Fu(\226)p 0 TeXcolorgray 42 w Fo(Il)g(est)h(r)n
(ecommand\351)f(delir)n(e)h(le)f(sujet)h(dans)g(son)g
(int\351gralit\351)e(av)o(ant)h(de)h(r)n(\351pondr)n(e)f(aux)h
(questions)p 0 TeXcolorgray -121 3898 a Fu(\226)p 0 TeXcolorgray
42 w Fo(Les)f(question)g(sont)h(num\351rot\351es)f(et)h(or)n
(donn\351es)e(mais)i(beaucoup)f(d)n('entr)n(e)i(elles)d(sont)i
(ind\351pendantes.)p 0 TeXcolorgray -121 4018 a Fu(\226)p
0 TeXcolorgray 42 w Fo(Il)f(est)h(r)n(ecommand\351)f(de)h(passer)f(une)
h(heur)n(e)g(sur)g(les)f(par)q(teies)g(1)g(et)h(2)g(et)g(une)g(heur)n
(e)g(sur)f(la)h(par)q(tie)f(3)p 0 TeXcolorgray -121 4137
a Fu(\226)p 0 TeXcolorgray 42 w Fo(Les)g(deux)h(par)q(ties)f(seront)g
(not\351es)g(\351quitablement)p 0 TeXcolorgray -121 4257
a Fu(\226)p 0 TeXcolorgray 42 w Fo(Les)g(r)n(\351ponses)g(sont)h(\340)g
(donner)e(dans)i(les)f(documents)h(r)n(\351ponses)f(pr)n(\351uvs)h
(\340)g(cet)f(effet)h(pour)g(les)f(par)q(ties)g(1)h(et)g(2)p
0 TeXcolorgray -121 4376 a Fu(\226)p 0 TeXcolorgray 42
w Fo(Les)f(r)n(\351ponses)g(sont)h(\340)g(donner)e(sur)i(feuille)f
(pour)g(la)h(par)q(tie)f(3.)h(P)m(our)f(cette)h(par)q(tie)f(il)h(est)g
(par)q(ticuli\350r)n(ement)e(r)n(ecommand\351)h(de)h(:)p
0 TeXcolorgray -41 4496 a Fu(\226)p 0 TeXcolorgray 41
w Fn(r)n(appeler)-8 b(,)17 b(sur)g(sa)g(copie)f(le)i(num\351ro)e(de)g
(la)i(question)f(avant)g(de)f(d\351velopper)g(sa)h(r)n(\351ponse)11
b(;)p 0 TeXcolorgray -41 4615 a Fu(\226)p 0 TeXcolorgray
41 w Fn(de)18 b(bien)g(r)n(especter)e(l'ensemble)i(des)f(notations)i
(alphab\351tiques)e(et)h(num\351riques)f(d\351\014nies)h(dans)g(le)g
(sujet)g(et)g(de)f(pr)n(\351ciser)g(ses)g(propr)n(es)38
4735 y(notations)h(lorsque)e(cela)h(s)m('av\350r)n(e)f(n\351cessair)n
(e)10 b(;)p 0 TeXcolorgray -41 4855 a Fu(\226)p 0 TeXcolorgray
41 w Fn(de)17 b(justi\014er)g(ses)f(hypoth\350ses,)h(et)g(de)f(r)n
(\351diger)g(clair)n(ement)h(ses)f(r)n(\351ponses.)p
0 TeXcolorgray 0 TeXcolorgray 1434 5735 a Fo(T)p Fm(O)t(U)t(T)j
Fo(D)r Fm(O)t(C)t(U)t(M)t(E)t(N)t(T)e Fo(I)r Fm(N)t(T)t(E)t(R)t(D)t(I)t
(T)726 5855 y Fo(C)r Fm(A)t(L)s(C)t(U)t(L)6 b(A)q(T)t(R)t(I)t(C)t(E)t
(S)r Fo(,)14 b(T)r Fm(\311)t(L)t(\311)t(P)s(H)t(O)t(N)t(E)t(S)g
Fo(P)r Fm(O)t(R)s(T)q(A)t(B)t(L)t(E)t(S)r Fo(,)g(L)r
Fm(E)t(C)t(T)t(E)t(U)t(R)i Fo(MP3)g(...)h(I)r Fm(N)t(T)t(E)t(R)t(D)t(I)
t(T)s(S)p 0 TeXcolorgray -246 6087 V -246 6187 a Fu(2010)j(\226)d(2011)
1713 b Fo(1)g Fu(DS)17 b(2)h(\226)f(SL)o(CI)p 0 TeXcolorgray
eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray -600 -600 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 -600
-600 a 0 TeXcolorgray -854 -972 a
SDict begin H.S end
 -854 -972 a 0 TeXcolorgray
0 TeXcolorgray -854 -972 a
SDict begin H.R end
 -854 -972 a -854 -972 a
SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
 -854
-972 a 0 TeXcolorgray 0 TeXcolorgray -246 -157 a Fu(PT)o(SI)18
b(\226)f(Sciences)i(I)o(ndustr)q(ielles)f(pour)g(l)o('I)o(ng\351nieur)
1718 b(L)l(yc\351e)17 b(J)m(ules)h(H)n(aag)f(\226)h(Besan\347on)p
-246 -126 4258 2 v 0 TeXcolorgray -246 192 V 0 TeXcolorgray
0 TeXcolorgray 751 477 a Fk(S)s Fl(Y)6 b(S)g(T)g(\310)g(M)g(E)38
b(D)6 b(E)35 b(F)6 b(R)g(E)g(I)g(N)g(A)t(G)g(E)39 b(D)6
b(E)35 b(L)-11 b Fk('A)s Fl(I)6 b(R)g(B)t(U)g(S)33 b
Fk(A318)p -246 663 V -246 813 a
SDict begin H.S end
 -246 813 a -246 813 a
SDict begin 14.39996 H.A end

-246 813 a -246 813 a
SDict begin [/View [/XYZ H.V]/Dest (section.1) cvn /DEST pdfmark end
 -246 813 a 0.07059 0.12941 0.38431
TeXcolorrgb 179 x Fj(1)p 0 TeXcolorgray 70 w(Pr\351sentation)48
b(du)e(syst\350me)p 0 TeXcolorgray 0 TeXcolorgray 1677
1149 a Fu(Airbus)16 b(A318)-121 1352 y(Le)j(fr)n(einage)h(est)f(une)h
(des)e(fonctions)j(vitales)f(d)n('un)f(avion,)h(au)f(m\352me)h(titr)n
(e)g(que)f(la)g(propulsion)h(ou)f(la)g(sustentation.)i(C'est)f(gr)o
(\342ce)e(\340)h(lui)-246 1471 y(que)e(l)o('avion)h(peut)f(s)m
('immobiliser)h(apr)n(\350s)f(l)o('atterr)q(issage)n(,)h(cir)n(culer)e
(au)g(sol)h(en)f(toute)h(s\351cur)q(it\351)g(mais)g(\351galement)h(s)m
('arr)n(\352ter)e(en)h(cas)f(d)n('urgence)-246 1591 y(lors)f(d)n('une)g
(interr)q(uption)h(de)e(d\351collage)h(alors)f(que)h(l)o('avion)h(est)g
(\340)e(pleine)i(charge)d(de)i(carbur)o(ant)f(et)h(lanc\351)f(\340)h
(la)f(vitesse)j(de)d(d\351collage)g(\(m\352me)-246 1710
y(si)21 b(le)g(r)q(isque)g(est)g(de)g(l)o('or)n(dr)n(e)g(de)f(1)h(pour)
g(1)g(million)h(de)f(d\351collages\).)g(Outr)n(e)g(les)g(fr)n(eins)o(,)
h(le)f(pilote)h(peut)g(aussi)f(actionner)h(les)f(inverseurs)h(de)-246
1830 y(pouss\351e)c(des)e(moteurs)i(et)e(les)h(a\351rofr)n(eins)n(.)h
(On)e(s)m('int\351r)n(esse)j(au)d(syst\350me)i(de)e(fr)n(einage)h(des)f
(roues)g(de)g(l)o('Airbus)h(A318,)g(avion)g(commer)n(cial)h(de)-246
1950 y(120)e(places)g(et)f(de)f(r)o(ayon)g(d)n('action)h(de)f(3240)j
(km.)e(La)f(vitesse)j(de)d(d\351collage)h(est)g(estim\351e)i(\340)d
(240)i(km)p Ft(/)p Fu(h.)f(P)n(our)f(les)i(atterr)q(isseurs)o(,)g(on)e
(distingue)-246 2069 y(\(voir)j(\014gur)n(e)h(2\))f(:)p
0 TeXcolorgray -121 2189 a(\226)p 0 TeXcolorgray 42 w(le)j(tr)o(ain)g
(avant)g(qui,)g(en)g(dehors)g(de)g(l)o('appui,)i(est)e(or)q(ientable)g
(ce)g(qui)g(lui)g(per)q(met)h(d)n('agir)e(sur)h(les)g(tr)o(ajectoir)n
(es)i(au)e(sol)g(mais)g(qui)g(n)-6 b('est)-41 2308 y(pas)18
b(\351quip\351)g(de)g(fr)n(eins)c(;)p 0 TeXcolorgray
-121 2428 a(\226)p 0 TeXcolorgray 42 w(les)k(deux)f(tr)o(ains)i(pr)q
(incipaux)f(au)f(niveau)i(des)e(ailes)o(,)i(chacun)f(por)q(tant)g(deux)
g(roues)f(fr)n(ein\351es)i(ind\351pendamment.)-246 2680
y Fi(Description)38 b(du)h(syst\350me)c(de)j(freinage)-246
2718 y
SDict begin H.S end
 -246 2718 a -246 2718 a
SDict begin 14.39996 H.A end
 -246 2718 a -246 2718
a
SDict begin [/View [/XYZ H.V]/Dest (section*.1) cvn /DEST pdfmark end
 -246 2718 a -121 2818 a Fu(Il)17 b(existe)h(deux)g(modes)g(de)f
(commande)i(du)e(syst\350me)i(de)e(fr)n(einage)h(:)p
0 TeXcolorgray -121 2937 a(\226)p 0 TeXcolorgray 42 w(le)26
b Fo(mode)d(nor)q(mal)h Fu(\(N)n(or)q(mal)g(B)o(r)o(aking\))i
(contr\364l\351)g(par)f(un)h(or)n(dinateur)g(d\351nomm\351)h(BSCU)g
(\(B)o(r)o(aking)p Ft(/)p Fu(S)n(teer)q(ing)f(C)o(ontrol)g(U)m(nit\).)h
(Le)-41 3057 y(BSCU)15 b(contr\364le)f(les)g(ser)q(vo)n(valves)i(\(une)
e(par)g(roue\))f(qui)i(alimentent)h(les)f(pistons)g(pr)n(esseurs)n(.)i
(C)o(es)d(pistons)i(exer)n(cent)f(alors)f(une)h(action)-41
3176 y(sur)25 b(les)i(roues)e(qui)i(diminue)f(alors)g(la)g(vitesse)i
(de)d(l)o('avion.)j(La)e(pr)n(ession)h(hydr)o(aulique)f(est)h(four)q
(nie)f(par)f(le)h(groupe)g(hydr)o(aulique)-41 3296 y(pr)q(incipal)13
b(;)p 0 TeXcolorgray -121 3416 a(\226)p 0 TeXcolorgray
42 w(le)i Fo(mode)e(alter)q(natif)g Fu(\(Alter)q(nate)h(br)o(aking\))g
(contr\364l\351)h(par)g(un)g(or)n(dinateur)g(d\351nomm\351)i(ABCU)e
(\(Alter)q(nate)f(B)o(r)o(aking)h(C)o(ontrol)g(U)m(nit\).)h(C)o(e)-41
3535 y(mode)e(pr)n(end)i(automatiquement)i(la)c(r)n(el\350ve)i(du)e
(mode)h(nor)q(mal)g(s)m('il)h(y)e(a)g(dysfonctionnement)j(de)e(ce)f
(der)q(nier)g(ou)h(si)g(le)g(contr\364le)g(anti-)-41
3655 y(d\351r)o(apage)23 b(\(Anti-S)n(kid\))h(de)f(l)o('avion)i(est)g
(suppr)q(im\351)n(.)h(En)d(mode)h(alter)q(natif,)h(la)f(pr)n(ession)h
(hydr)o(aulique)f(est)h(four)q(nie)f(par)g(un)g(groupe)-41
3774 y(hydr)o(aulique)17 b(secondair)n(e)n(.)-121 3894
y(En)g(mode)h(nor)q(mal,)g(il)g(est)g(possible)h(de)e(commander)h(le)g
(fr)n(einage)g(de)g(deux)f(fa\347ons)h(diff\351r)n(entes)i(:)p
0 TeXcolorgray -121 4013 a(\226)p 0 TeXcolorgray 42 w(soit)g
Fo(manuellement)f Fu(par)h(appui)h(sur)f(les)h(p\351dales)g(de)f(fr)n
(ein)i(\(voir)e(\014gur)n(e)g(3\))g(:)g(pour)h(chaque)g(pilote)n(,)h
(les)f(p\351dales)g(gauche)f(et)h(droite)-41 4133 y(sont)g
(ind\351pendantes)n(.)j(L)-10 b('appui)23 b(sur)e(la)g(p\351dale)h
(gauche)g(agit)f(sur)g(le)g(fr)n(einage)i(des)e(roues)g(du)g(tr)o(ain)g
(pr)q(incipal)h(gauche)n(,)g(l)o('appui)h(sur)-41 4252
y(celle)15 b(de)f(droite)g(agit)h(sur)g(le)g(fr)n(einage)g(des)g(roues)
f(du)h(tr)o(ain)g(pr)q(incipal)g(droit.)f(Les)i(unit\351s)g(de)e(tr)o
(ansmission)j(\(B)o(r)o(ake)e(P)n(edal)f(T)-6 b(r)o(ansmitter)-41
4372 y(U)m(nit\))17 b(situ\351es)h(sous)g(les)f(p\351dales)h
(\351mettent)h(des)e(signaux)g(\351lectr)q(iques)h(vers)f(le)g(BSCU)h
(ou)f(vers)g(l)o('ABCU)h(propor)q(tionnels)g(\340)e(la)h(course)-41
4492 y(des)g(p\351dales)i(de)e(fr)n(ein)d(;)p 0 TeXcolorgray
-121 4611 a(\226)p 0 TeXcolorgray 42 w(soit)g Fo(automatiquement)f
Fu(suivant)i(trois)e(modes)i(de)e(d\351c\351l\351r)o(ation)i(:)f(L)o(O)
l(,)h(MED)l(,)e(MAX.)g(La)h(s\351lection)h(se)f(fait)h(\340)e(par)q
(tir)h(de)f(trois)h(boutons)-41 4731 y(situ\351s)j(sur)g(le)g(tableau)f
(de)g(bor)n(d)g(\(voir)g(\014gur)n(e)g(4\).)h(Le)g(mode)f(manuel)i(est)
f(r)n(\351tabli)g(si)g(le)g(pilote)n(,)h(en)f(appuyant)g(sur)g(les)g
(p\351dales)g(de)f(fr)n(ein,)-41 4850 y(g\351n\350r)n(e)f(une)g
(consigne)g(de)f(d\351c\351l\351r)o(ation)h Fn(a)1275
4862 y Ff(p)1331 4850 y Fu(sup\351r)q(ieur)n(e)h(\340)e(la)g(consigne)h
(de)f(d\351c\351l\351r)o(ation)i Fn(a)2768 4862 y Ff(c)2815
4850 y Fu(du)f(mode)f(automatique)i(s\351lectionn\351)n(.)-121
4970 y(Les)e(modes)g(L)o(O)h(et)e(MED)h(sont)g(utilis\351s)h(lors)f(de)
g(l)o('atterr)q(issage)n(.)h(Ils)e(corr)n(espondent)i(r)n
(espectivement)i(\340)c(une)h(d\351c\351l\351r)o(ation)h(de)f(l)o
('avion)h(de)-246 5089 y Fd(\000)p Fu(1,)9 b(7)p Fn(m)h(s)40
5065 y Fb(\000)p Fe(2)130 5089 y Fu(et)18 b(de)f Fd(\000)p
Fu(3)p Fn(m)10 b(s)532 5065 y Fb(\000)p Fe(2)604 5089
y Fu(.)17 b(Le)h(mode)f(MAX)f(est)i(ex)o(clusivement)i
(s\351lectionn\351)g(lors)d(du)g(d\351collage)n(,)h(en)f(cas)h(d)n
('interr)q(uption)g(de)f(ce)g(der)q(nier)-5 b(.)-246
5209 y(Il)17 b(corr)n(espond)h(\340)f(une)i(d\351c\351l\351r)o(ation)f
(th\351or)q(ique)h(de)e(-10)h(ms-2)h(sup\351r)q(ieur)n(e)g(\340)e(la)g
(d\351c\351l\351r)o(ation)i(maximale)g(de)e(l)o('avion.)-121
5328 y(En)27 b(mode)g(nor)q(mal)h(\(manuel)g(ou)f(automatique\),)i(le)e
(BSCU)h(contr\364le)g(l)o('anti-d\351r)o(apage)g(\(Anti)f(S)n(kid\))g
(de)g(chaque)h(roue)e(tant)i(que)f(la)-246 5448 y(vitesse)21
b(de)d(l)o('avion)h(est)g(sup\351r)q(ieur)n(e)h(\340)e(5)e
Fn(m)10 b Fh(=)p Fn(s)g Fu(.)17 b(En)i(mode)f(alter)q(natif,)i(seule)f
(la)g(commande)g(manuelle)h(est)f(disponible)g(avec)g(ou)f(sans)h
(anti-)-246 5567 y(d\351r)o(apage)n(.)p 0 TeXcolorgray
-246 6087 4258 2 v -246 6187 a(2010)h(\226)d(2011)1713
b Fo(2)g Fu(DS)17 b(2)h(\226)f(SL)o(CI)p 0 TeXcolorgray
eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
